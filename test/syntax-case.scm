(import (sagittarius vm))

(%insert-binding '(core base) 'assertion-violation
		 (lambda (who msg . irritans)
		   (error 'who msg irritans)))

(define next-symbol gensym)

(define (expander expr rename compare)
  (define (variable? o)
    (or (symbol? o)
	(identifier? o)))

  (let ((ellipse-specified? (variable? (cadr expr)))
	(count 0)
	(_er-macro-transformer (rename 'er-macro-transformer))
	(_lambda (rename 'lambda))      (_let (rename 'let))
	(_begin (rename 'begin))        (_if (rename 'if))
	(_and (rename 'and))            (_or (rename 'or))
	(_eq? (rename 'eq?))            (_equal? (rename 'equal?))
	(_car (rename 'car))            (_cdr (rename 'cdr))
	(_cons (rename 'cons))          (_pair? (rename 'pair?))
	(_null? (rename 'null?))        (_expr (rename 'expr))
	(_rename (rename 'rename))      (_compare (rename 'compare))
	(_quote (rename 'quote))        (_apply (rename 'apply))
	(_append (rename 'append))      (_map (rename 'map))
	(_vector? (rename 'vector?))    (_list? (rename 'list?))
	(_len (rename 'len))             (_length (rename 'length))
	(_- (rename '-))   (_>= (rename '>=))   (_error (rename 'error))
	(_ls (rename 'ls)) (_res (rename 'res)) (_i (rename 'i))
	(_reverse (rename 'reverse))    (_vector->list (rename 'vector->list))
	(_list->vector (rename 'list->vector))
	(_format (rename 'format)))
    ;; (syntax-rules specified () ...) or (syntax-rules () ...)
    (define ellipse (rename (if ellipse-specified? (cadr expr) '...)))
    (define lits (if ellipse-specified? (caddr expr) (cadr expr)))
    (define forms (if ellipse-specified? (cdddr expr) (cddr expr)))

    (define (expand-pattern pat tmpl)
      (let lp ((p (cdr pat))
	       (x `(,_cdr ,_expr))
	       (dim 0)
	       (vars '())
	       (k (lambda (vars)
		    (or (expand-template tmpl vars)
			`(,_begin #f)))))
	(let ((v (next-symbol "v.")))
	  `(,_let ((,v ,x))
	     ,(cond
	      ((variable? p)
	       (if (any (lambda (l) (compare p l)) lits)
		   `(,_and (,_compare ,v (,_quote ,p)) ,(k vars))
		   `(,_let ((,p ,v)) ,(k (acons p dim vars)))))
	      ((ellipse? p)
	       (cond 
		((not (null? (cddr p)))
		 (or (list? (cddr p))
		     (error 'syntax-rules "dotted ellipse" p))
		 (and (any (lambda (x) (and (variable? x)
					    (compare x ellipse)))
			   (cddr p))
		      (error 'syntax-rules "multiple ellipses" p))
		 (let ((len (length (cddr p)))
		       (_lp (next-symbol "lp.")))
		   `(,_let ((,_len (,_length ,v)))
		      (,_and (,_>= ,_len ,len)
			     (,_let ,_lp ((,_ls ,v)
					  (,_i (,_- ,_len ,len))
					  (,_res (,_quote ())))
			       (,_if (,_>= 0 ,_i)
				     ,(lp `(,@(cddr p) ,(car p) ,(cadr p))
					  `(,_append ,_ls (,_reverse ,_res))
					  dim
					  vars
					  k)
				     (,_lp (,_cdr ,_ls)
					   (,_- ,_i 1)
					   (,_cons (,_car ,_ls) ,_res))))))))
		((variable? (car p))
		 `(,_and (,_list? ,v)
			 (,_let ((,(car p) ,v))
			   ,(k (acons (car p) (+ 1 dim) vars)))))
		(else
		 (let* ((w (next-symbol "w."))
			(_lp (next-symbol "lp."))
			(new-vars (all-vars (car p) (+ dim 1)))
			(ls-vars (map (lambda (x)
					(next-symbol
					 (string-append
					  (symbol->string
					   (identifier->symbol (car x)))
					  "-ls")))
				      new-vars))
			(once
			 (lp (car p) `(,_car ,w) (+ dim 1) '()
			     (lambda (_)
			       `(_lp (,_cdr ,w)
				     ,@(map (lambda (x l)
					      `(,_cons ,(car x) ,l))
					    new-vars
					    ls-vars))))))
		   `(,_let ,_lp ((,w ,v)
				 ,@(map (lambda (x) `(,x ())) ls-vars))
		      `(,_if (,_null? ,w)
			     (,_let ,(map (lambda (x l)
					    `(,(car x) (,_reverse ,l)))
					  new-vars
					  ls-vars)
			       ,(k (append new-vars vars)))
			     (,_and (,_pair? ,w) ,once)))))))
	      ((pair? p)
	       `(,_and (,_pair? ,v)
		       ,(lp (car p) `(,_car ,v) dim vars
			    (lambda (vars)
			      (lp (cdr p) `(,_cdr ,v) dim vars k)))))
	      ((vector? p)
	       `(,_and (,_vector? ,v)
		       ,(lp (vector->list p)
			    `(,_vector->list ,v) dim vars k)))
	      ((null? p)
	       `(,_and (,_null? ,v) ,(k vars)))
	      (else `(,_and (,_equal? ,v ,p) ,(k vars))))))))
    (define (ellipse-escape? x) (and (pair? x) (compare ellipse (car x))))
    (define (ellipse? x) 
      (and (pair? x) (pair? (cdr x)) (compare ellipse (cadr x))))
    (define (ellipse-depth x)
      (if (ellipse? x)
	  (+ 1 (ellipse-depth (cdr x)))
	  0))
    (define (ellipse-tail x)
      (if (ellipse? x)
	  (ellipse-tail (cdr x))
	  (cdr x)))
    (define (all-vars x dim)
      (let lp ((x x) (dim dim) (vars '()))
	(cond ((variable? x)
	       (if (any (lambda (lit) (compare x lit)) lits)
		   vars
		   (acons x dim vars)))
	      ((ellipse? x) (lp (car x) (+ dim 1) vars))
	      ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
	      ((vector? x) (lp (vector->list x) dim vars))
	      (else vars))))
    (define (free-vars x vars dim)
      (let lp ((x x) (free '()))
	(cond ((variable? x)
	       (if (and (not (memq x free))
			(cond ((assq x vars) => (lambda (cell) (>= (cdr cell) dim)))
			      (else #f)))
		   (cons x free)
		   free))
	      ((pair? x) (lp (car x) (lp (cdr x) free)))
	      ((vector? x) (lp (vector->list x) free))
	      (else free))))
    (define (expand-template tmpl vars)
      (let lp ((t tmpl) (dim 0))
	(cond ((variable? t)
	       (cond ((any (lambda (v) (compare t (car v))) vars)
		      => (lambda (cell)
			   (if (<= (cdr cell) dim)
			       t
			       (error 'syntax-rules "too few ...'s"))))
		     (else `(,_rename (,_quote ,t)))))
	      ((pair? t)
	       (cond ((ellipse-escape? t)
		      (if (pair? (cdr t))
			  (if (pair? (cddr t)) (cddr t) (cadr t))
			  (cdr t)))
		     ((ellipse? t)
		      (let* ((depth (ellipse-depth t))
			     (ell-dim (+ dim depth))
			     (ell-vars (free-vars (car t) vars ell-dim)))
			(when (null? ell-vars)
			  (error 'syntax-rules "too many ...'s")
			  (set! ell-dim (- ell-dim 1))
			  (set! ell-vars  (free-vars (car t) vars ell-dim)))
			(let* ((once (lp (car t) ell-dim))
			       (nest (if (and (null? (cdr ell-vars))
					      (variable? once)
					      (eq? once (car vars)))
					 once ;; shortcut
					 `(,_map (,_lambda ,ell-vars ,once)
						 ,@ell-vars)))
			       (many (do ((d depth (- d 1))
					  (many nest
						`(,_apply ,_append ,many)))
					 ((= d 1) many))))
			  (if (null? (ellipse-tail t))
			      many ;; short cut
			      `(,_append ,many ,(lp (ellipse-tail t) dim))))))
		     (else `(,_cons ,(lp (car t) dim) ,(lp (cdr t) dim)))))
	      ((vector? t) `(,_list->vector ,(lp (vector->list t) dim)))
	      ((null? t) `(,_quote ()))
	      (else t))))
#;(format #t "~s~%" (unwrap-syntax 
    `(,_er-macro-transformer
      (,_lambda (,_expr ,_rename ,_compare)
	(,_or ,@(map (lambda (clause)
		       (expand-pattern (car clause) (cadr clause)))
		     forms)
	      ((,_error (,_quote 'syntax-rules) 
			(,_format "no expansion for ~s"
				  (,(rename 'unwrap-syntax) ,_expr)))))))))

    `(,_er-macro-transformer
      (,_lambda (,_expr ,_rename ,_compare)
	(,_or ,@(map (lambda (clause)
		       (expand-pattern (car clause) (cadr clause)))
		     forms)
	      ((,_error (,_quote 'syntax-rules) 
			(,_format "no expansion for ~s"
				  (,(rename 'unwrap-syntax) ,_expr)))))))))

(define-syntax syntax-rules
  (er-macro-transformer
   (lambda (expr rename compare)
     (expander expr rename compare))))

(define-syntax test
  (syntax-rules ()
      ((_ o1 o2 ...)
       (begin
	 (display o1)
	 (test o2 ...)))
      ((_ o)
       (begin (display o)(test)))
      ((_) (newline))))
(test 1 2 3)
(test 3 4 5)
(define-syntax hoge
  (syntax-rules ()
    ((_ r ...)
     (begin
       (list '(r (r ...)) ...)))))
(display (hoge 1 2 3))
