;; -*- mode: scheme; coding: utf-8 -*- 
(library (scribble plugin)
    (export define-scrible-macro
	    define-scrible-plugin
	    lookup)
    (import (rnrs)
	    (sagittarius))
  ;; alist
  (define *macro-table* '())
  (define *plugin-table* '())

  (define (insert-macro/plugin type name var)
    (case type
      ((define-scrible-macro)
       (insert-macro name var))
      ((define-scrible-plugin)
       (insert-plugin name var))))
  
  (define-syntax define-scrible-macro-macro
    (syntax-rules ()
      ((_ def inserter)
       (define-syntax def
	 (syntax-rules (lambda)
	   ((_ (name . args) body (... ...))
	    (def :lambda name (lambda args body (... ...))))
	   ((_ name var)
	    (def :var name var))
	   ((_ :var name (lambda args body (... ...)))
	    (def :lambda name (lambda args body (... ...))))
	   ((_ :var name var) ;; well redefined?
	    (inserter 'name var))
	   ((_ :lambda name var)
	    (inserter 'name var)))))))

  (define-scrible-macro-macro define-scrible-macro insert-macro)

  (define (insert-macro name var)
    (set! *macro-table* (acons name var *macro-table*)))

  (define-scrible-macro-macro define-scrible-plugin insert-plugin)

  (define (insert-plugin name var)
    (set! *plugin-table* (acons name var *plugin-table*)))

  (define (lookup type name)
    (case type
      ((macro)
       (cond ((assq name *macro-table*) => cdr)
	     (else #f)))
      ((plugin)
       (cond ((assq name *plugin-table*) => cdr)
	     (else #f)))
      (else
       (assertion-violation 'lookup
			    "invalid type" type name))
       ))
)

(library (scribble sxml-converter)
    (export scribble->sxml
	    scribble-file->sxml)
    (import (rnrs)
	    (rnrs eval)
	    (pp)
	    (scribble)
	    (scribble plugin)
	    (sagittarius)
	    (sagittarius vm)
	    (srfi :39 parameters))

  ;; phase 1
  (define-scrible-macro (include-section file)
    (if (file-exists? file)
	(call-with-input-file file
	  (lambda (in)
	    (scribble-parse in)))
	(raise-continuable
	 (condition (make-warning)
		    (make-who-condition 'include-section)
		    (make-message-condition (format "file not found [~a]" file))
		    (make-irritants-condition file)))))

  (define (expand-scribble-macro sexp)
    (define (process-1 lst)
      (cond ((pair? lst)
	     (cond ((lookup 'macro (car lst))
		    => (lambda (proc)
			 (apply proc (cdr lst))))
		   (else #f)))
	    (else #f)))
    (define (process sexp)
      (let loop ((sexp sexp)
		 (r '()))
	(cond ((null? sexp) r)
	      ((pair? sexp)
	       (let ((expanded (process-1 (car sexp))))
		 (if expanded
		     (loop (cdr sexp)
			   (append r (process expanded)))
		     (loop (cdr sexp)
			   (append r (list (car sexp)))))))
	      (else (list sexp)))))
    (with-exception-handler
     (lambda (e)
       (cond ((and (warning? e)
		   (message-condition? e))
	      (let ((msg (condition-message e)))
		(display msg (current-error-port))
		(newline (current-error-port))
		msg))
	     ((message-condition? e)
	      (let ((msg (condition-message e)))
		(display msg (current-error-port))
		(newline (current-error-port)))
	      #f)
	     (else #f)))
     (lambda ()
       (process sexp))))

  ;; phase 2
  (define *phase2-processor* (make-parameter #f))

  (define (parse-attribute items)
    (define (keyword->symbol keyword)
      (string->symbol (format "~a" keyword)))
    (let loop ((items items)
	       (attr '()))
      (cond ((null? items)
	     (values attr '())) ;; should not happen
	    ((and (pair? items)
		  (keyword? (car items)))
	     (loop (cddr items)
		   (acons (keyword->symbol (car items)) (list (cadr items)) attr)))
	    (else
	     (values attr items)))))

  (define (generic-processor tag . items)
    (let-values (((attr contents) (parse-attribute items)))
      `(,tag (@ ,@attr)
	     ,@(map (*phase2-processor*) contents))))

  (define-scrible-plugin (th . items)
    (apply generic-processor 'th items))

  (define-scrible-plugin (td . items)
    (apply generic-processor 'td items))

  (define-scrible-plugin (tr . items)
    (apply generic-processor 'tr items))

  (define-scrible-plugin (table . items)
    (apply generic-processor 'table items))

  (define-scrible-plugin (blockquote . items)
    (apply generic-processor 'blockquote items))

  (define-scrible-plugin (hyperlink . items)
    (apply generic-processor 'a items))

  (define-scrible-plugin (define cate name . args)
    ;; stub
    `(define (@ (category ,(format "~a" cate)))
       ,name
       ,@(filter values (map (lambda (arg)
			       (if (pair? arg)
				   ((*phase2-processor*) arg)
				   #f))
			     args))))

  (define (process-section name . args)
    (let ((t (if (keyword? (car args))
		 (cadr args)
		 #f)))
      (if t
	  `(,name (@ (tag ,t)) ,@((*phase2-processor*) (cddr args)))
	  `(,name ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (section . args)
    (apply process-section 'section args))

  (define-scrible-plugin (subsection . args)
    (apply process-section 'subsection args))

  (define-scrible-plugin (subsubsection . args)
    (apply process-section 'subsubsection args))

  (define-scrible-plugin (sub*section . args)
    (apply process-section 'sub*section args))

  (define-scrible-plugin (table-of-contents . maybe-id)
    (let ((i (if (and (not (null? maybe-id))
		      (keyword? (car maybe-id)))
		  (cadr maybe-id)
		  #f)))
      (if i
	  `(table-of-contents (@ (id ,i)))
	  `(table-of-contents))))

  (define-scrible-plugin (snipet . args)
    ;; parse =>
    (let ((expected (if (symbol? (car args))
			(format "~a" (cadr args))
			#f)))
      (if expected
	  `(snipet (@ (result ,expected)) ,@((*phase2-processor*) (cddr args)))
	  `(snipet ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (eval sexp)
    (eval (read (open-string-input-port sexp))
	  (vm-current-library))) ;; <- almost black magic ...

  (define-scrible-plugin (codeblock . args)
    (let ((e (if (symbol? (car args))
		 (format "~a" (cadr args))
		 #f)))
      (if e
	  `(codeblock (@ (result ,e)) ,@((*phase2-processor*) (cddr args)))
	  `(codeblock ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (secref t . args)
    `(secref (@ (tag ,t)) ,@((*phase2-processor*) args)))

  (define (scribble->sxml sexp)
    (define *top* '*TOP*)
    (define *pi* '(*PI* xml "version=\"1.0\" encoding=\"utf-8\""))
    (define (process-1 item)
      (cond ((pair? item)
	     (cond ((lookup 'plugin (car item))
		    => (lambda (proc)
			 (parameterize ((*phase2-processor* process-1))
			   (apply proc (cdr item)))))
		   (else (cons (process-1 (car item))
			       (process-1 (cdr item))))))
	    (else item)))
    (append (list *top* *pi*)
	    (list `(scribble
		    ,@(map process-1 (expand-scribble-macro sexp))))))

  (define (scribble-file->sxml file)
    (scribble->sxml
     (expand-scribble-macro
      (call-with-input-file file
	(lambda (in)
	  (scribble-parse in))))))

)

;; phase-3 generation

(library (scribble generator)
    (export generate-document)
    (import (rnrs)
	    (rnrs eval)
	    (sagittarius))
  (define (generate-document sxml type . opt)
    (let ((lib `(scribble generator ,type))
	  (generator (string->symbol (format "~a-generator" type))))
      (eval `(apply ,generator ',sxml ',opt)
	    (environment '(rnrs) lib))))
)

(library (scribble generator html)
    (export html-generator)
    (import (except (rnrs) define)
	    (rnrs mutable-pairs)
	    (sagittarius)
	    (sagittarius regex)
	    (rename (sagittarius control)
		    (define-with-key define))
	    (match)
	    (util list)
	    (text sxml sxpath)
	    (text sxml tools)
	    (text sxml serializer) ;; for srl:sxml->html
	    (srfi :1 lists)
	    (srfi :19 time)
	    (srfi :39 parameters)
	    (pp))

  ;; collect sections and number it
  ;; section must be only top level
  (define (phase1 sxml)
    (define (list->section-number section)
      (call-with-string-output-port
       (lambda (p)
	 (for-each-with-index
	  (lambda (index number)
	    (if (zero? index)
		(format p "~a" number)
		(format p ".~a" number)))
	  section)))
      )
    (let* ((docpath (sxpath '(scribble))) ;; get top
	   (titlepath (sxpath '(scribble title)))
	   (doc (car (docpath sxml)))
	   (title (titlepath sxml))
	   (current-section '(0)))
      (define (numbering elem)
	(let-syntax ((set-section! (syntax-rules ()
				     ((_ count)
				      (begin
					(unless (= (length current-section) count)
					  (set! current-section (append current-section '(0))))
					(set! current-section (take current-section count))
					(set-car! (list-tail current-section (- count 1))
						  (+ (list-ref current-section (- count 1)) 1)))))))
	(case (car elem)
	  ((section)
	   (set-section! 1))
	  ((subsection)
	   (set-section! 2))
	  ((subsubsection)
	   (set-section! 3))
	  ((sub*section)
	   (set-section! 4)))
	(sxml:set-attr! elem `(number ,(list->section-number current-section)))
	(unless (assq 'tag (sxml:attr-list-node elem))
	  (sxml:set-attr! elem `(tag ,(symbol->string (gensym)))))
	elem))
      (values (if (null? title) #f (car title))
	      (filter values
		      (map (lambda (elem)
			     ;;(display elem)(newline)
			     (cond ((and (pair? elem)
					 (memq (car elem) '(section subsection subsubsection sub*section)))
				    (numbering elem))
				   (else #f))) doc))
	      (cdr doc)))
      )

  (define (center-handler element)
    `(center ,@(phase2/dispath (cdr element))))

  (define *table-of-contents* (make-parameter #f))

  (define *section-classes*
    '((section       . "section")
      (subsection    . "sub-section")
      (subsubsection . "sub-sub-section")
      (sub*section   . "sub-sub-sub-section")))

  ;; output
  ;;(ul (@)
  ;;    (li (@) section1
  ;;	  (ul (@)
  ;;	      (li (@) subsection1
  ;;		  (ul (@)
  ;;		      (li (@) subsubsection1 )))))
  ;;    (li (@) section2))
  (define (content-list-handler element)
    (define (process contents)
      (define (li-gen content class)
	(let* ((attrs (sxml:attr-list-node content))
	       (tag   (cond ((assq 'tag attrs) => cadr)))
	       (section (cond ((assq 'number attrs) => cadr)
			      (else
			       (assertion-violation 'li-gen
						    "section is not defined" content)))))
	  `((li (@ (class ,class))
	       (a (@ (href ,(format "#~a" tag)))
		  (span (@ (class "section-number")) ,section)
		  ,@(map phase2/dispath (sxml:content content)))))))
      (define (ul-gen class)
	`(ul (@ (class ,class))))
      (define (rec contents generator top)
	(let loop ((contents contents)
		   (r top))
	  (if (null? contents)
	      r
	      (let ((content (car contents)))
		(let-values (((class depth) (generator content)))
		  (let loop ((i 0)
			     (r r))
		    (if (= i depth)
			(cond ((and (zero? i) ;; top
				    (eq? (car r) 'ul))
			       (append! r (li-gen content class)))
			      (else
			       (let ((tail (car (list-tail r (- (length r) 1)))))
				 (cond ((eq? (car tail) 'ul)
					(append! tail (li-gen content class))
					r)
				       (else
					(let ((ul (ul-gen class)))
					  (append! ul (li-gen content class))
					  (if (eq? (car tail) 'li)
					      (append! tail (list ul))
					      (append! r (list ul)))
					  r))))))
			(loop (+ i 1)
			      (let((rr (car (list-tail r (- (length r) 1)))))
				(if (eq? (car rr) 'li)
				    rr
				    (car (list-tail rr (- (length rr) 1))))))))
		  (loop (cdr contents) r))))))

	(define (section-generator element)
	  (define len (length *section-classes*))
	  (define sections (map car *section-classes*))
	  (cond ((assq (car element) *section-classes*)
		 => (lambda (slot)
		      (let ((name (car slot))
			    (class (cdr slot)))
			(values class (- len (length (memq name sections)))))))
		(else
		 (assertion-violation 'section-generator
				      "unknown tag" element))))
	;; assume first one is section
	(rec contents section-generator (ul-gen "section")))

    (let* ((contents (*table-of-contents*))
	   (attr (sxml:attr-list-node element))
	   (id   (cond ((and attr (assq 'id attr)) => cadr)
		       (else (symbol->string (gensym))))))
      `(div (@ (id ,id)
	       (class "table-of-contents"))
	    ,(process contents))
      )
    )

  (define *current-section* #f)

  (define (section-handler element)
    (define (ctr tag)
      (let* ((attr (sxml:attr-list-node element))
	     (name (cond ((assq 'tag attr) => cadr)))
	     (num  (cond ((assq 'number attr) => cadr)))
	     (content (phase2/dispath (sxml:content element))))
	;; bit awkward
	(set! *current-section* (cons `(,num " ",@content) name))
	`(,tag (@ (class ,(regex-replace-all (regex "\\*") (symbol->string (car element)) "-")))
	       (a (@ (class "section.anchor")
		     (name ,name))
		  (span (@ (class "section-number"))
			,(format "~a" num))
		  ,@content))))
    (case (car element)
      ((section) (ctr 'h2))
      ((subsection) (ctr 'h3))
      ((subsubsection) (ctr 'h4))
      ((sub*section) (ctr 'h5))))

  (define (title-handler element)
    `(h1 (@ (class "title")) ,(cadr element)))

  (define (define-handler element)
    (let* ((attr (sxml:attr-list-node element))
	   (cate (cond ((assq 'category attr) => cadr))))
      ;; todo name and args tag
      `(div (@ (class "define"))
	    (span (@ (class "define-category")) ,cate)
	    ,@(map phase2/dispath (sxml:content element))))
    )

  (define (codeblock-handler element)
    ;; todo => attributes
    (let ((attr (sxml:attr-list-node element))
	  (code `(pre (@ (class "codeblock"))
		      ,@(map phase2/dispath (sxml:content element)))))
      (if attr
	  (append! code `((span (@ (class "codeblock-arrow")) "=>")
			  (span (@ (class "codeblock-result"))
				,@(map phase2/dispath
				       (cond ((assq 'result attr) => cdr))))))
	  code)))

  (define (snipet-handler element)
    (let ((attr (sxml:attr-list-node element))
	  (code `(pre (@ (class "snipet"))
		      (span (@ (class "snipet-code"))
			    ,@(map phase2/dispath (sxml:content element))))))
      (if attr
	  (append! code `((span (@ (class "snipet-arrow"))
				"=>")
			  (span (@ (class "snipet-result"))
				,@(map phase2/dispath
				       (cond ((assq 'result attr) => cdr))))))
	  code)))

  (define (code-handler element)
    `(code ,@(map phase2/dispath (sxml:content element))))

  (define (itemlist-handler element)
    `(ul (@ (class "itemlist"))
	 ,@(filter values
		   (map (lambda (item)
			  (cond ((and (pair? item)
				      (eq? (car item) 'item))
				 `(li (@ (class "itemlist-item"))
				      ,@(map phase2/dispath (sxml:content item))))
				(else #f))) ;; ignoge
			(sxml:content element)))))
  
  (define *in-desc* (make-parameter #f))

  (define (desc-handler element)
    (parameterize ((*in-desc* #t))
      `(div (@ (class "desc"))
	    ,@(map phase2/dispath (sxml:content element)))))

  (define (secref-handler element)
    (let* ((attr (sxml:attr-list-node element))
	   (tag  (cond ((assq 'tag attr) => cadr))))
      `(a (@ (href ,(format "#~a" tag)))
	  ,@(map phase2/dispath (sxml:content element)))))

  (define (dots-handler element)
    `(b (@ (class "dots")) "..."))

  (define (atmark-handler element) "@")

  ;; assume @name only has one content
  (define *names-for-index* '())
  (define (name-handler element)
    (let ((tag (symbol->string (gensym)))
	  ;; TODO maybe I need to fix this
	  (name (car (sxml:content element))))
      (set! *names-for-index* (acons name (cons tag *current-section*) *names-for-index*))
      `(a (@ (name ,tag))
	  (span (@ (class "name"))
		,@(map phase2/dispath (sxml:content element))))))

  (define (args-handler element)
    `(span (@ (class "args"))
	   ,@(map phase2/dispath (sxml:content element))))

  (define (dllist-handler element)
    `(div (@ (class "dl-list-wrapper"))
	  ,@(map phase2/dispath (sxml:content element))))

  (define (dlitem-handler element)
    (let ((name (cadr element)))
      `(dl (@ (class "dl-list"))
	   (dt (@ (class "dl-item-title"))
	       ,(phase2/dispath name))
	   (dd (@ (class "dl-item-desc"))
	       ,@(map phase2/dispath (cddr element))))))

  (define (dlitemx-handler element)
    (let ((num (cadr element)))
      (let-values (((dds element) (let loop ((i 0)
					     (src (cddr element))
					     (r '()))
				    (if (= i num)
					(values (reverse! r) src)
					(loop (+ i 1)
					      (cdr src)
					      (cons `(dt (@ (class "dl-item-title"))
							 ,(phase2/dispath (car src)))
						    r))))))
	`(dl (@ (class "dl-list"))
	     ,@dds
	     (dd (@ (class "dl-item-desc"))
		 ,@(map phase2/dispath element))))))

  (define (string-handler element)
    `(span (@ (class "string"))
	   ,@(map phase2/dispath (cdr element))))

  (define (table-handler element)
    (let* ((attr (sxml:attr-list-node element))
	   (title (cond ((and attr
			      (assq 'title attr)) => cadr)
			(else #f))))
      `(table (@ (class "table"))
	      ,@(filter values (if title `((caption ,title)) '(#f)))
	      ,@(map phase2/dispath (sxml:content element)))))

  (define (generic-html-handler element)
    (let ((tag (car element))
	  (attr (sxml:attr-list-node element)))
      `(,tag (@ ,@attr)
	     ,@(map phase2/dispath (sxml:content element)))))

  (define (index-table-handler element)
    ;; generates index table
    (let ((lst (list-sort (lambda (pair1 pair2)
			    (let ((name1 (car pair1))
				  (name2 (car pair2)))
			      (string<=? name1 name2))) *names-for-index*))
	  (current-letter #f))
      `(table (@ (class "index-table"))
	      (capture "Index")
	      ,@(map (lambda (pair)
		       (let* ((name (car pair))
			      (tag  (cadr pair))
			      (section (cddr pair))
			      (first-letter (string-ref name 0)))
			 (unless current-letter
			   (set! current-letter first-letter))
			 (unless (char-ci=? first-letter current-letter)
			   (set! current-letter first-letter))
			 `(tr (td (a (@ (href ,(format "#~a" tag))) ,name))
			      (td (a (@ (href ,(format "#~a" (cdr section)))) ,@(car section))))))
		     lst)))
    )

  (define *phase2/dispatcher*
    `((centered . ,center-handler)
      (title . ,title-handler)
      (table-of-contents . ,content-list-handler)
      (section . ,section-handler)
      (subsection . ,section-handler)
      (subsubsection . ,section-handler)
      (sub*section . ,section-handler)
      (define . ,define-handler)
      (codeblock . ,codeblock-handler)
      (code . ,code-handler)
      (snipet . ,snipet-handler)
      (itemlist . ,itemlist-handler)
      (desc . ,desc-handler)
      (name . ,name-handler)
      (args . ,args-handler)
      (secref . ,secref-handler)
      (dots . ,dots-handler)
      (atmark . ,atmark-handler)
      (dl-list . ,dllist-handler)
      (dl-item . ,dlitem-handler)
      (dl-itemx . ,dlitemx-handler)
      (string . ,string-handler)
      (table . ,table-handler)
      (tr . ,generic-html-handler)
      (td . ,generic-html-handler)
      (th . ,generic-html-handler)
      (blockquote . ,generic-html-handler)
      (a . ,generic-html-handler)
      (index-table . ,index-table-handler)
      ))

  (define *had-linefeed?* (make-parameter #f))

  (define (phase2/dispath element)
    (cond ((and (pair? element)
		(assq (car element) *phase2/dispatcher*))
	   => (lambda (slot)
		(*had-linefeed?* #f)
		((cdr slot) element)))
	  ((and (equal? "\n" element)
		(*had-linefeed?*))
	   (*had-linefeed?* #f)
	   '(p))
	  ((equal? "\n" element)
	   (*had-linefeed?* #t)
	   element)
	  (else 
	   (*had-linefeed?* #f)
	   element)))

  (define (html-generator sxml
			  :key (output (current-output-port))
			       (style  #f)
			       (javascript #f)
			       (debug #f))
    (let-values (((title contents doc) (phase1 sxml)))
      (let ((html-metas `(html
			  (head (meta (@ (http-eqiv "Content-Type")
					 (content   "text/html; charset=utf-8")))
				,@(filter values
					  (list (if style
						    `(link (@ (rel "stylesheet")
							      (type "text/css")
							      (href ,style)))
						    #f)
						(if javascript
						    `(script (@ (type "text/javascript")
								(src ,javascript)) " ")
						    #f)))
				(title ,(if title (cadr title) "Auto generated by html-generator"))))))
	(when debug (pp doc))
	(parameterize ((*table-of-contents* contents))
	  (let ((document (append html-metas
				  `((body ,@(map phase2/dispath doc)
					  (hr)
					  (div 
					   (i "This document is generated by Sagittarius gendoc. "
					      "Generated date: " 
					      ,(date->string (current-date) "~4")
					       )))))))
	    (when debug (pp document))
	    (srl:sxml->html document output)))
	))
    )
)

(import (rnrs)
	(srfi :37)
	(scribble sxml-converter)
	(scribble generator)
	(text sxml serializer)
	(pp))

(define (option-handler option name arg output style javascript debug files)
  (case (if (string? name) (string->symbol name) name)
    ((#\o output) (values arg style javascript debug files))
    ((#\s style)  (values output arg javascript debug files))
    ((#\j javascript)  (values output style arg debug files))
    ((#\d debug)  (values output style javascript #t files))
    (else
     (assertion-violation 'option
			  "invalid option" name))))

(define options
  (list (option '(#\o "output") #f #t option-handler)
	(option '(#\s "style") #f #t option-handler)
	(option '(#\j "javascript") #f #t option-handler)
	(option '(#\d "debug") #f #f option-handler)))

(let ((args (command-line)))
  (let-values (((output style javascript debug files)
		(args-fold (cdr args)
			   options
			   (lambda (option name arg . seeds)
			     (assertion-violation 'gendoc
						  "Unrecognized option" name))
			   (lambda (operand output style javascript debug files)
			     (values output style javascript debug (cons operand files)))
			   (current-output-port)
			   #f
			   #f
			   #f
			   '())))
    (unless (file-exists? (car files))
      (usage)
      (exit -1))
    (let ((r (scribble-file->sxml (car files))))
      ;;(srl:sxml->xml r (current-output-port))
      (when (string? output)
	(if (file-exists? output)
	    (delete-file output)))
      (format #t "options: (output ~a) (style ~a) (javascript ~a) (debug ~a)~%"
	      output style javascript debug)
      (generate-document r 'html :output output
			         :style style
				 :javascript javascript
				 :debug debug)
      )))