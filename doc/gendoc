;; -*- mode: scheme; coding: utf-8 -*- 
(library (scribble plugin)
    (export define-scrible-macro
	    define-scrible-plugin
	    lookup)
    (import (rnrs)
	    (sagittarius))
  ;; alist
  (define *macro-table* '())
  (define *plugin-table* '())

  (define (insert-macro/plugin type name var)
    (case type
      ((define-scrible-macro)
       (insert-macro name var))
      ((define-scrible-plugin)
       (insert-plugin name var))))
  
  (define-syntax define-scrible-macro-macro
    (syntax-rules ()
      ((_ def inserter)
       (define-syntax def
	 (syntax-rules (lambda)
	   ((_ (name . args) body (... ...))
	    (def :lambda name (lambda args body (... ...))))
	   ((_ name var)
	    (def :var name var))
	   ((_ :var name (lambda args body (... ...)))
	    (def :lambda name (lambda args body (... ...))))
	   ((_ :var name var) ;; well redefined?
	    (inserter 'name var))
	   ((_ :lambda name var)
	    (inserter 'name var)))))))

  (define-scrible-macro-macro define-scrible-macro insert-macro)

  (define (insert-macro name var)
    (set! *macro-table* (acons name var *macro-table*)))

  (define-scrible-macro-macro define-scrible-plugin insert-plugin)

  (define (insert-plugin name var)
    (set! *plugin-table* (acons name var *plugin-table*)))

  (define (lookup type name)
    (case type
      ((macro)
       (cond ((assq name *macro-table*) => cdr)
	     (else #f)))
      ((plugin)
       (cond ((assq name *plugin-table*) => cdr)
	     (else #f)))
      (else
       (assertion-violation 'lookup
			    "invalid type" type name))
       ))
)

(library (scribble sxml-converter)
    (export scribble->sxml
	    scribble-file->sxml)
    (import (rnrs)
	    (rnrs eval)
	    (scribble)
	    (scribble plugin)
	    (sagittarius)
	    (sagittarius vm)
	    (srfi :39 parameters))

  ;; phase 1
  (define-scrible-macro (include-section file)
    (if (file-exists? file)
	(call-with-input-file file
	  (lambda (in)
	    (scribble-parse in)))
	(raise-continuable
	 (condition (make-warning)
		    (make-who-condition 'include-section)
		    (make-message-condition (format "file not found [~a]" file))
		    (make-irritants-condition file)))))

  (define (expand-scribble-macro sexp)
    (define (process-1 lst)
      (cond ((pair? lst)
	     (cond ((lookup 'macro (car lst))
		    => (lambda (proc)
			 (apply proc (cdr lst))))
		   (else #f)))
	    (else #f)))
    (define (process sexp)
      (let loop ((sexp sexp)
		 (r '()))
	(cond ((null? sexp) r)
	      ((pair? sexp)
	       (let ((expanded (process-1 (car sexp))))
		 (if expanded
		     (loop (cdr sexp)
			   (append r (process expanded)))
		     (loop (cdr sexp)
			   (append r (list (car sexp)))))))
	      (else (list sexp)))))
    (with-exception-handler
     (lambda (e)
       (cond ((and (warning? e)
		   (message-condition? e))
	      (let ((msg (condition-message e)))
		(display msg (current-error-port))
		(newline (current-error-port))
		msg))
	     (else #f)))
     (lambda ()
       (process sexp))))

  ;; phase 2
  (define *phase2-processor* (make-parameter #f))

  (define-scrible-plugin (table . items)
    ;; stub
    `(table ,@(filter values
		      (map (lambda (i)
			     (cond ((and (pair? i)
					 (eq? (car i) 'item))
				    `(item (@ (name ,(cadr i)))
					   ,@((*phase2-processor*) (cddr i))))
				   (else #f)))
			   items))))

  (define-scrible-plugin (define cate name . args)
    ;; stub
    `(define (@ (category ,(format "~a" cate)))
       ,name
       ,@(filter values (map (lambda (arg)
			       (if (pair? arg)
				   ((*phase2-processor*) arg)
				   #f))
			     args))))

  (define (process-section name . args)
    (let ((t (if (keyword? (car args))
		 (cadr args)
		 #f)))
      (if t
	  `(,name (@ (tag ,t)) ,@((*phase2-processor*) (cddr args)))
	  `(,name ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (subsection . args)
    (apply process-section 'subsection args))

  (define-scrible-plugin (subsubsection . args)
    (apply process-section 'subsubsection args))

  (define-scrible-plugin (sub*section . args)
    (apply process-section 'sub*section args))

  (define-scrible-plugin (snipet . args)
    ;; parse =>
    (let ((expected (if (symbol? (car args))
			(format "~a" (cadr args))
			#f)))
      (if expected
	  `(snipet (@ (result ,expected)) ,@((*phase2-processor*) (cddr args)))
	  `(snipet ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (eval sexp)
    (eval (read (open-string-input-port sexp))
	  (vm-current-library))) ;; <- almost black magic ...

  (define-scrible-plugin (codeblock . args)
    (let ((e (if (symbol? (car args))
		 (format "~a" (cadr args))
		 #f)))
      (if e
	  `(codeblock (@ (result ,e)) ,@((*phase2-processor*) (cddr args)))
	  `(codeblock ,@((*phase2-processor*) args)))))

  (define-scrible-plugin (secref t . args)
    `(secref (@ (tag ,t)) ,@((*phase2-processor*) args)))

  (define (scribble->sxml sexp)
    (define *top* '*TOP*)
    (define *pi* '(*PI* xml "version=\"1.0\" encoding=\"utf-8\""))
    (define (process-1 item)
      (cond ((pair? item)
	     (cond ((lookup 'plugin (car item))
		    => (lambda (proc)
			 (parameterize ((*phase2-processor* process-1))
			   (apply proc (cdr item)))))
		   (else (cons (process-1 (car item))
			       (process-1 (cdr item))))))
	    (else item)))
    (append (list *top* *pi*)
	    (list `(scribble
		    ,@(map process-1 (expand-scribble-macro sexp))))))

  (define (scribble-file->sxml file)
    (scribble->sxml
     (expand-scribble-macro
      (call-with-input-file file
	(lambda (in)
	  (scribble-parse in))))))

)

;; phase-3 generation

(library (scribble generator)
    (export generate-document)
    (import (rnrs)
	    (rnrs eval)
	    (sagittarius))
  (define (generate-document sxml type . maybe-port)
    (let ((lib `(scribble generator ,type))
	  (generator (string->symbol (format "~a-generator" type))))
      (eval `(apply ,generator ',sxml ',maybe-port)
	    (environment '(rnrs) lib))))
)

(library (scribble generator html)
    (export html-generator)
    (import (rnrs)
	    (rnrs mutable-pairs)
	    (sagittarius)
	    (match)
	    (util list)
	    (text sxml sxpath)
	    (text sxml tools)
	    (text sxml serializer) ;; for srl:sxml->html
	    (srfi :39 parameters)
	    (srfi :1 lists)
	    (pp))

  ;; collect sections and number it
  ;; section must be only top level
  (define (phase1 sxml)
    (define (list->section-number section)
      (call-with-string-output-port
       (lambda (p)
	 (for-each-with-index
	  (lambda (index number)
	    (if (zero? index)
		(format p "~a" number)
		(format p ".~a" number)))
	  section)))
      )
    (let* ((docpath (sxpath '(scribble))) ;; get top
	   (titlepath (sxpath '(scribble title)))
	   (doc (car (docpath sxml)))
	   (title (titlepath sxml))
	   (current-section '(0)))
      (define (numbering elem)
	(let-syntax ((set-section! (syntax-rules ()
				     ((_ count)
				      (begin
					(unless (= (length current-section) count)
					  (set! current-section (append current-section '(0))))
					(set! current-section (take current-section count))
					(set-car! (list-tail current-section (- count 1))
						  (+ (list-ref current-section (- count 1)) 1)))))))
	(case (car elem)
	  ((section)
	   (set-section! 1))
	  ((subsection)
	   (set-section! 2))
	  ((subsubsection)
	   (set-section! 3))
	  ((sub*section)
	   (set-section! 4)))
	(sxml:set-attr! elem `(number ,(list->section-number current-section)))
	(unless (assq 'tag (sxml:attr-list-node elem))
	  (sxml:set-attr! elem `(tag ,(symbol->string (gensym)))))
	elem))
      (values (if (null? title) #f (car title))
	      (filter values
		      (map (lambda (elem)
			     ;;(display elem)(newline)
			     (cond ((and (pair? elem)
					 (memq (car elem) '(section subsection subsubsection sub*section)))
				    (numbering elem))
				   (else #f))) doc))
	      (cdr doc)))
      )

  (define (center-handler element)
    `(center ,@(phase2/dispath (cdr element))))

  (define *table-of-contents* (make-parameter #f))

  (define (content-list-handler element)
    (define (process contents)
      (define (li-gen content class)
	(let* ((attrs (sxml:attr-list-node content))
	       (tag   (cond ((assq 'tag attrs) => cadr)))
	       (section (cond ((assq 'number attrs) => cadr)
			      (else
			       (assertion-violation 'li-gen
						    "section is not defined" content)))))
	  `(li (@ (class ,class))
	       (a (@ (href ,(format "#~a" tag)))
		  (span (@ (class "section.number")) ,section)
		  ,(phase2/dispath (car (sxml:content content)))))))
      (define (ul-gen content class)
	`(ul (@ (class ,class))
	     ,(li-gen content class)))
      (define (rec contents generator top)
	(define (rec2 contents generator top)
	  (let loop ((contents contents)
		     (r top))
	    (if (null? contents)
		(values r '())
		(let ((content (car contents)))
		  (let-values (((depth class generator) (generator content)))
		    (case depth
		      ((-1)
		       (values (cons r (list (li-gen content class)))
			       (cdr contents)))
		      ((0) 
		       (loop (cdr contents)
			     (append r (list (li-gen content class)))))
		      ((1)
		       (let-values (((top next)
				     (rec2 (cdr contents) generator
					   (ul-gen content class))))
			 ;; ughh, ugly
			 (if (pair? (car top))
			     (loop next  (append r top))
			     (loop next `(,@r ,top)))))))))))
	(let-values (((ret dummy) (rec2 contents generator top)))
	  ret)
	)
      (let-syntax ((define-checker (er-macro-transformer
				    (lambda (f r c)
				      (match f
					((_ name (sym1 class1 g1) (sym2 class2) (sym3 class3 g3))
					 `(define (,name content)
					   (case (car content)
					     ((,sym1) (values -1 ,class1 ,g1))
					     ((,sym2) (values 0 ,class2 ,name))
					     ((,sym3) (values 1 ,class3 ,g3))
					     (else
					      (assertion-violation ',name
								   "invalid tag"
								   content))))))))))
	(define-checker section-generator
	  (#f #f #f)
	  (section "section")
	  (subsection "sub.section" subsection-generator))
	(define-checker subsection-generator
	  (section "section" section-generator)
	  (subsection "sub.section")
	  (subsubsection "sub.sub.section" subsubsection-generator))
	(define-checker subsubsection-generator
	  (subsection "sub.section" subsection-generator)
	  (subsubsection "sub.sub.section")
	  (sub*section "sub.sub.sub.section" sub*section-generator))
	(define-checker sub*section-generator
	  (subsubsection "sub.sub.section" subsubsection-generator)
	  (sub*section "sub.sub.sub.section")
	  (#f #f #f))
	;; assume first one is section
	(rec contents (lambda (_) (values 1 "section" section-generator)) '() )))

    (let ((contents (*table-of-contents*)))
      ;;`(table-of-contents ,@contents)
      `(div (@ (class "table-of-contents"))
	    ,@(process contents)))
      )

  (define (section-handler element)
    (define (ctr tag)
      (let* ((attr (sxml:attr-list-node element))
	     (name (cond ((assq 'tag attr) => cadr)))
	     (num  (cond ((assq 'number attr) => cadr))))
	`(,tag (@ (class ,(symbol->string (car element))))
	       (a (@ (class "section.anchor")
		     (name ,name))
		  ,(format "~a " num)
		  ,@(phase2/dispath (sxml:content element))))))
    (case (car element)
      ((section) (ctr 'h2))
      ((subsection) (ctr 'h3))
      ((subsubsection) (ctr 'h4))
      ((sub*section) (ctr 'h5))))

  (define (title-handler element)
    `(h1 ,(cadr element)))

  (define (define-handler element)
    (let* ((attr (sxml:attr-list-node element))
	   (cate (cond ((assq 'category attr) => cadr))))
      ;; todo name and args tag
      `(div (@ (class "define"))
	    (span (@ (class "define.category")) ,cate)
	    ,@(phase2/dispath (sxml:content element))))
    )

  (define (codeblock-handler element)
    ;; todo => attributes
    (let ((attr (sxml:attr-list-node element))
	  (code `(pre (@ (class "codeblock"))
		      ,@(map phase2/dispath (sxml:content element)))))
      (if attr
	  (append! code `((span (@class "codeblock.result")
				"=> "
				,@(map phase2/dispath
				       (cond ((assq 'result attr) => cdr))))))
	  code)))

  (define (snipet-handler element)
    (let ((attr (sxml:attr-list-node element))
	  (code `(pre (@ (class "snipet"))
		      (span (@ (class "snipet.code"))
			    ,@(map phase2/dispath (sxml:content element))))))
      (if attr
	  (append! code `((span (@ (class "snipet.result"))
				"=> "
				,@(map phase2/dispath
				       (cond ((assq 'result attr) => cdr))))))
	  code)))

  (define (itemlist-handler element)
    `(ul (@ (class "itemlist"))
	 ,@(filter values
		   (map (lambda (item)
			  (cond ((and (pair? item)
				      (eq? (car item) 'item))
				 `(li (@ (class "itemlist.item"))
				      ,@(map phase2/dispath (sxml:content item))))
				(else #f))) ;; ignoge
			(sxml:content element)))))
  
  (define (desc-handler element)
    `(div (@ (class "desc"))
	  ,@(map phase2/dispath (sxml:content element))))

  (define (secref-handler element)
    (let* ((attr (sxml:attr-list-node element))
	   (tag  (cond ((assq 'tag attr) => cadr))))
      `(a (@ (href ,(format "#~a" tag)))
	  ,@(map phase2/dispath (sxml:content element)))))

  (define (dots-handler element)
    `(b (@ (class "dots")) "..."))

  (define *phase2/dispatcher*
    `((centered . ,center-handler)
      (title . ,title-handler)
      (table-of-contents . ,content-list-handler)
      (section . ,section-handler)
      (subsection . ,section-handler)
      (subsubsection . ,section-handler)
      (sub*section . ,section-handler)
      (define . ,define-handler)
      (codeblock . ,codeblock-handler)
      (snipet . ,snipet-handler)
      (itemlist . ,itemlist-handler)
      (desc . ,desc-handler)
      (secref . ,secref-handler)
      (dots . ,dots-handler)
      ))

  (define *had-linefeed?* (make-parameter #f))

  (define (phase2/dispath element)
    (cond ((and (pair? element)
		(assq (car element) *phase2/dispatcher*))
	   => (lambda (slot)
		(*had-linefeed?* #f)
		((cdr slot) element)))
	  ((and (equal? "\n" element)
		(*had-linefeed?*))
	   (*had-linefeed?* #f)
	   '(br))
	  ((equal? "\n" element)
	   (*had-linefeed?* #t)
	   element)
	  (else 
	   (*had-linefeed?* #f)
	   element)))

  (define (html-generator sxml . maybe-port)
    (let-values (((title contents doc) (phase1 sxml)))
      (let ((html-metas `(html
			  (head (meta (@ (http-eqiv "Content-Type")
					 (content   "text/html; charset=utf-8")))
				(title ,(if title (cadr title) "Auto generated by html-generator"))))))
	(parameterize ((*table-of-contents* contents))
	  (let ((document (append html-metas
				  `((body ,@(map phase2/dispath doc))))))
	    ;;(pp document)
	    (srl:sxml->html document
			    (if (null? maybe-port)
				(current-output-port)
				(car maybe-port)))))
	))
    )
)

(import (rnrs)
	(srfi :37)
	(scribble sxml-converter)
	(scribble generator)
	(text sxml serializer)
	(pp))

(define (option-handler option name arg output files)
  (case (if (string? name) (symbol->string name) name)
    ((#\o output) (values arg files))
    (else
     (assertion-violation 'option
			  "invalid option" name))))

(define options
  (list (option '(#\o "output") #f #t option-handler)))

(let ((args (command-line)))
  (let-values (((output files) (args-fold (cdr args)
					  options
					  (lambda (option name arg . seeds)
					    (assertion-violation 'gendoc
								 "Unrecognized option" name))
					  (lambda (operand output files)
					    (values output (cons operand files)))
					  (current-output-port)
					  '())))
    (unless (file-exists? (car files))
      (usage)
      (exit -1))
    (let ((r (scribble-file->sxml (car files))))
      ;;(srl:sxml->xml r (current-output-port))
      (when (string? output)
	(if (file-exists? output)
	    (delete-file output)))
      (generate-document r 'html output)
  ;;(pp r)
      )))