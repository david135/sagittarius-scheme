;; -*- scheme -*-
;; for Ypsilon
#!compatible
(library (sagittarius) ;; redefine but no problem
    (export identifier?
	    identifier=?
	    id-name
	    id-memq
	    identifier->symbol
	    ;; generics
	    make-generic
	    register-generic
	    generic-ref
	    generic-set!
	    retrieve-generic
	    create-instance

	    ;; closure
	    closure? make-toplevel-closure

	    ;; list
	    circular-list? dotted-list?
	    reverse!

	    ;; vector
	    vector-copy

	    ;; misc
	    current-exception-handler
	    parent-exception-handler
	    variable? arity
	    unbound undefined undefined?
	    add-load-path load
	    gensym unwrap-syntax wrap-syntax
	    current-dynamic-environment
	    add-dynamic-load-path
	    load-dynamic-library
	    sagittarius-version
	    report-error
	    ;; string
	    string-scan
	    ;; for srfi-13
	    %maybe-substring

	    ;; filesystem
	    file-size-in-bytes
	    file-regular?
	    file-directory?
	    file-symbolic-link?
	    file-readable?
	    file-writable?
	    file-executable?
	    file-stat-ctime
	    file-stat-mtime
	    create-symbolic-link
	    create-hard-link
	    rename-file
	    delete-directory
	    create-directory
	    read-directory
	    current-directory
	    set-current-directory

	    ;; hashtable
	    hashtable-keys-list hashtable-values-list
	    hashtable-values
	    hashtable-type hashtable-compare hashtable-hasher
	    ;; extra hashtable
	    make-equal-hashtable make-string-hashtable

	    ;; error
	    ;; from Gauche
	    with-error-handler

	    ;; io
	    port-closed? format write/ss
	    make-codec

	    ;; profiler
	    profiler-start profiler-stop profiler-reset
	    profiler-raw-result

	    ;; keyword
	    make-keyword

	    ;; cache
	    clean-cache
	    ;; env
	    getenv
	    )
    (import :null)
  (decl-code
   (.include <sagittarius/cache.h>))

  (define-cgen-stmt assertion-violation
    ((_ who msg)
     (dispatch
      `(begin
	 (Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) '())
	 (return SG_UNDEF))))
    ((_ who msg irritants)
     (dispatch
      `(begin
	 (Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,irritants)
	 (return SG_UNDEF)))))

  (define-cgen-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got '())
	 (result SG_UNDEF))))
    ((_ who msg got irritants)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got ,irritants)
	 (result SG_UNDEF)))))

  ;; for library dependency
  (define-c-proc identifier=? (use_env x mac_env y) ::boolean
    (result (Sg_IdentifierEqP use_env x mac_env y)))

  (define-c-proc id-name (id) ::Object
    (cond ((SG_IDENTIFIERP id)
	   (result (SG_IDENTIFIER_NAME id)))
	  ((SG_USER_DEFINED_SYNTXP id)
	   (result (SG_SYNTAX_NAME id)))
	  (else
	   (wrong-type-of-argument-violation 'id-name
					     "identifier"
					     id))))

  (define-c-proc identifier->symbol (id) ::Object
    (unless (or (SG_SYMBOLP id)
		(SG_IDENTIFIERP id))
      (wrong-type-of-argument-violation 'identifier->symbol
					"symbol or identifier"
					id))
    (if (SG_SYMBOLP id)
	(result id)
	(result (SG_IDENTIFIER_NAME id))))

  (define-c-proc id-memq (id lst) ::Object
    (if (SG_IDENTIFIERP id)
	(result (Sg_Memq (SG_IDENTIFIER_NAME id) lst))
	(result (Sg_Memq id lst))))

  ;; generics
  (define-c-proc make-generic (name::Symbol printer ctr :rest fields) ::Object
    (result (Sg_MakeGeneric name printer ctr fields)))
  
  (define-c-proc register-generic (name::Symbol g::Generic lib::Library) ::void
    (Sg_RegisterGeneric name g lib))

  (define-c-proc generic-ref (g name::Symbol) ::Object
    (result (Sg_GenericRef g name)))

  (define-c-proc generic-set! (g name::Symbol value) ::void
    (Sg_GenericSet g name value))

  (define-c-proc retrieve-generic (name::Symbol :optional (maybeLibrary #f)) ::Object
    (result (Sg_RetrieveGeneric name maybeLibrary)))

  (define-c-proc create-instance (g::Generic) ::Object
    (result (Sg_CreateInstance g)))

  ;; closure?
  (define-c-proc closure? (cl) ::boolean
    (result (SG_CLOSUREP cl)))

  (define-c-proc make-toplevel-closure (cb::CodeBuilder) ::Object
    ;; topleve closure should not have any free variables
    (result (Sg_MakeClosure cb NULL)))

  ;; list
  (define-c-proc dotted-list? (lst) ::boolean
    (result (SG_DOTTED_LISTP lst)))

  (define-c-proc circular-list? (lst) ::boolean
    (result (SG_CIRCULAR_LISTP lst)))

  (define-c-proc reverse! (lis) ::Object
    (result (Sg_ReverseX lis)))

  ;; vector
  (define-c-proc vector-copy (vec::Vector :optional (start::fixnum 0)
					            (end::fixnum -1)
						    fill) ::Object
    (result (Sg_VectorCopy vec start end fill)))

  (define-c-proc current-exception-handler (:optional handle) ::Object
    (if (SG_UNBOUNDP handle)
	(result (-> (Sg_VM) exceptionHandler))
	(begin
	  (set! (-> (Sg_VM) exceptionHandler) handle)
	  (result SG_UNDEF))))

  (define-c-proc parent-exception-handler (:optional handle) ::Object
    (if (SG_UNBOUNDP handle)
	(result (-> (Sg_VM) parentExHandler))
	(begin
	  (set! (-> (Sg_VM) parentExHandler) handle)
	  (result SG_UNDEF))))

  ;; misc
  (define-c-proc variable? (o) ::boolean
    (result (or (SG_SYMBOLP o)
		(SG_IDENTIFIERP o))))

  ;; arity returns pair of required and optional arguments count.
  ;; returned pair is structured like this : (<required> . <optional>)
  ;; <required> : # of required arguments
  ;; <optional> : #t or #f
  (define-c-proc arity (p::Procedure) ::Object
    (let ((req::int (SG_PROCEDURE_REQUIRED p))
	  (opt::int (SG_PROCEDURE_OPTIONAL p)))
      (if (> opt 0)
	  (result (Sg_Cons (SG_MAKE_INT req) #t))
	  (result (Sg_Cons (SG_MAKE_INT req) #f)))))

  (define-c-proc unbound () ::Object
    (result SG_UNBOUND))

  (define-c-proc undefined () ::Object
    (result SG_UNDEF))

  (define-c-proc undefined? (o) ::boolean
    (result (SG_UNDEFP o)))

  (define-c-proc add-load-path (path::String) ::Object
    (result (Sg_AddLoadPath path)))

  (define-c-proc load (path::String) ::Object
    (result (Sg_VMLoad path)))

  (define-c-proc gensym (:optional (prefix::String NULL)) ::Object
    (result (Sg_Gensym prefix)))

  (define-c-proc unwrap-syntax (form) ::Object
    (result (Sg_UnwrapSyntax form)))

  (define-c-proc wrap-syntax (form p1env::Vector :optional (seen NULL) (partialP #f)) ::Object
    (result (Sg_WrapSyntax form p1env seen (not (SG_FALSEP partialP)))))

  (define-c-proc current-dynamic-environment (:optional (other::HashTable SG_UNBOUND)) ::Object
    (if (SG_UNBOUNDP other)
	(result (-> (Sg_VM) parameters))
	(begin
	  (set! (-> (Sg_VM) parameters) other)
	  (result SG_UNDEF))))

  (define-c-proc add-dynamic-load-path (path::String) ::Object
    (result (Sg_AddDynamicLoadPath path)))

  (define-c-proc load-dynamic-library (name::String :optional init) ::Object
    (result (Sg_DynLoad name init 0)))

  (define-c-proc sagittarius-version () ::Object
    (result (Sg_MakeString (UC SAGITTARIUS_VERSION) SG_LITERAL_STRING)))

  (define-c-proc report-error (e) ::void
    (Sg_ReportError e))

  ;; filesystem
  (define-c-proc file-size-in-bytes (path::String) ::Object
    (let ((size (Sg_FileSize path)))
      (if (SG_UNDEFP size)
	  (Sg_AssertionViolation procedureName
				 (Sg_GetLastErrorMessage)
				 path))
      (result size)))
  
  (define-c-proc file-regular? (path::String) ::boolean
    (result (Sg_FileRegularP path)))

  (define-c-proc file-directory? (path::String) ::boolean
    (result (Sg_DirectoryP path)))

  (define-c-proc file-symbolic-link? (path::String) ::boolean
    (result (Sg_FileSymbolicLinkP path)))

  (define-c-proc file-readable? (path::String) ::boolean
    (result (Sg_FileReadableP path)))

  (define-c-proc file-writable? (path::String) ::boolean
    (result (Sg_FileWritableP path)))

  (define-c-proc file-executable? (path::String) ::boolean
    (result (Sg_FileExecutableP path)))

  (define-c-proc file-stat-ctime (path::String) ::Object
    (let ((tm (Sg_FileChangeTime path)))
      (if (SG_UNDEFP tm)
	  (Sg_AssertionViolation procedureName
				 (Sg_GetLastErrorMessage)
				 path))
      (result tm)))

  (define-c-proc file-stat-mtime (path::String) ::Object
    (let ((tm (Sg_FileModifyTime path)))
      (if (SG_UNDEFP tm)
	  (Sg_AssertionViolation procedureName
				 (Sg_GetLastErrorMessage)
				 path))
      (result tm)))

  (define-c-proc file-stat-atime (path::String) ::Object
    (let ((tm (Sg_FileAccessTime path)))
      (if (SG_UNDEFP tm)
	  (Sg_AssertionViolation procedureName
				 (Sg_GetLastErrorMessage)
				 path))
      (result tm)))

  (define-c-proc create-symbolic-link (oldpath::String newpath::String) ::void
    (unless (Sg_CreateSymbolicLink oldpath newpath)
      (Sg_AssertionViolation procedureName
			     (Sg_GetLastErrorMessage)
			     (SG_LIST2 oldpath newpath))))

  (define-c-proc rename-file (oldpath::String newpath::String) ::void
    (unless (Sg_FileRename oldpath newpath)
      (Sg_AssertionViolation procedureName
			     (Sg_GetLastErrorMessage)
			     (SG_LIST2 oldpath newpath))))

  (define-c-proc delete-directory (path::String) ::void
    (unless (Sg_DeleteFileOrDirectory path)
      (Sg_AssertionViolation procedureName
			     (Sg_GetLastErrorMessage)
			     path)))

  (define-c-proc create-directory (path::String) ::void
    (unless (Sg_CreateDirectory path)
      (Sg_AssertionViolation procedureName
			     (Sg_GetLastErrorMessage)
			     path)))

  (define-c-proc read-directory (path::String) ::Object
    (result (Sg_ReadDirectory path)))

  (define-c-proc current-directory () ::Object
    (result (Sg_CurrentDirectory)))

  (define-c-proc set-current-directory (path::String) ::void
    (Sg_SetCurrentDirectory path))

  ;; string
  (define-c-proc string-scan (s1::String s2 :optional (mode 'index)) ::Object
    (let ((rmode::int 0))
      (cond ((SG_EQ mode 'index)   (set! rmode SG_STRING_SCAN_INDEX))
	    ((SG_EQ mode 'before)  (set! rmode SG_STRING_SCAN_BEFORE))
	    ((SG_EQ mode 'after)   (set! rmode SG_STRING_SCAN_AFTER))
	    ((SG_EQ mode 'before*) (set! rmode SG_STRING_SCAN_BEFORE2))
	    ((SG_EQ mode 'after*)  (set! rmode SG_STRING_SCAN_AFTER2))
	    ((SG_EQ mode 'both)    (set! rmode SG_STRING_SCAN_BOTH))
	    (else
	     (assertion-violation 'string-scan
				  "bad value in mode argument. it must be one of 'index, 'before, 'after, 'before*, 'after* or 'both"
				  mode)))
      (cond ((SG_STRINGP s2) (result (Sg_StringScan s1 (SG_STRING s2) rmode)))
	    ((SG_CHARP s2)   (result (Sg_StringScanChar s1 (SG_CHAR_VALUE s2) rmode)))
	    (else
	     (wrong-type-of-argument-violation 'string-scan
					       "string or char"
					       s2
					       (SG_LIST3 s1 s2 mode))))))

  (define-c-proc %maybe-substring (s::String :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (result (Sg_MaybeSubstring s start end)))

  ;; hashtable
  (define-c-proc make-equal-hashtable (:optional (k::fixnum 200)) ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_EQUAL k)))

  (define-c-proc make-string-hashtable (:optional (k::fixnum 200)) ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_STRING k)))

  (define-c-proc hashtable-keys-list (ht::HashTable) ::Object
    (result (Sg_HashTableKeys ht)))

  (define-c-proc  hashtable-values-list (ht::HashTable) ::Object
    (result (Sg_HashTableValues ht)))

  (define-c-proc hashtable-type (ht::HashTable) ::Object
    (cond ((== (-> ht type) SG_HASH_EQ)
	   (result 'eq))
	  ((== (-> ht type) SG_HASH_EQV)
	   (result 'eqv))
	  ((== (-> ht type) SG_HASH_EQUAL)
	   (result 'equal))
	  ((== (-> ht type) SG_HASH_STRING)
	   (result 'string))
	  ((== (-> ht type) SG_HASH_GENERAL)
	   (result 'general))
	  (else
	   (assertion-violation 'hashtable-type
				"invalid hashtable type"
				ht))))

  (define-c-proc hashtable-compare (ht::HashTable) ::Object
    (result (-> (SG_HASHTABLE_CORE ht) generalCompare)))

  (define-c-proc hashtable-hasher (ht::HashTable) ::Object
    (result (-> (SG_HASHTABLE_CORE ht) generalHasher)))

  ;; just for consistancy
  (define-c-proc hashtable-values (ht::HashTable) ::Object
    (result (Sg_ListToVector (Sg_HashTableValues ht) 0 -1)))

  ;; error
  (define-c-proc with-error-handler (handler thunk) ::Object
    (result (Sg_VMWithErrorHandler handler thunk)))

  ;; io
  (define-cgen-stmt check-output-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_OUTPORTP ,p)
		   (SG_INOUTPORTP ,p))
	 (wrong-type-of-argument-violation ',name
					   "output port"
					   ,p)))))
  
  (define-c-proc port-closed? (p::Port) ::boolean
    (result (Sg_PortClosedP p)))

  (define-cgen-stmt check-port-open
    ((_ name p)
     (dispatch
      `(when (Sg_PortClosedP ,p)
	 (wrong-type-of-argument-violation ',name
					   "opened port"
					   ,p)))))

  (define-c-proc write/ss (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (check-port-open write/ss p)
    (check-output-port write/ss p)
    (Sg_Write o p SG_WRITE_SHARED))

  (define-c-proc format (p :rest rest) ::Object
    (cond ((SG_PORTP p)
	   (check-port-open format p)
	   (check-output-port format p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (Sg_Format p fmt objs FALSE)
	     (result SG_UNDEF)))
	  ((SG_BOOLP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (if (SG_FALSEP p)
		 (let ((out (Sg_MakeStringOutputPort 16)))
		   (Sg_Format out fmt objs FALSE)
		   (result (Sg_GetStringFromStringPort out)))
		 (let ((out (Sg_CurrentOutputPort)))
		   (Sg_Format out fmt objs FALSE)
		   (result SG_UNDEF)))))
	  ((SG_STRINGP p)
	   (let ((out (Sg_MakeStringOutputPort 16)))
	     (Sg_Format out p rest FALSE)
	     (result (Sg_GetStringFromStringPort out))))))

  (define-c-proc make-codec (name::Symbol g::Procedure p::Procedure data) ::Object
    (result (Sg_MakeCustomCodecSimple name g p data)))

  ;; profiler
  (define-c-proc profiler-start () ::void
    (Sg_ProfilerStart))
  (define-c-proc profiler-stop () ::fixnum
    (result (Sg_ProfilerStop)))
  (define-c-proc profiler-reset () ::void
    (Sg_ProfilerReset))

  (define-c-proc profiler-raw-result () ::Object
    (result (Sg_ProfilerRawResult)))

  ;; keyword
  (define-c-proc make-keyword (key::Symbol) ::Object
    (result (Sg_MakeKeyword (-> (SG_SYMBOL key) name))))

  ;; cache
  (define-c-proc clean-cache () ::void
    (Sg_CleanCache))

  ;; getenv
  (define-c-proc getenv (path::String) ::Object
    (result (Sg_Getenv (SG_STRING_VALUE path))))
)