;; -*- scheme -*-
;; for Ypsilon
#!compatible
(library (sagittarius) ;; redefine but no problem
    (export identifier?
	    identifier=?
	    id-name
	    id-memq
	    identifier->symbol
	    ;; generics
	    make-generic
	    register-generic
	    generic-ref
	    generic-set!
	    retrieve-generic
	    create-instance

	    ;; closure
	    closure? make-toplevel-closure

	    ;; list
	    circular-list?

	    ;; vector
	    vector-copy

	    ;; hashtable
	    hashtable->alist
	    hashtable-values

	    ;; misc
	    current-exception-handler
	    variable? arity
	    unbound undefined undefined?
	    add-load-path load
	    gensym unwrap-syntax wrap-syntax

	    ;; io
	    port-closed? format write/ss

	    ;; profiler
	    profiler-start profiler-stop profiler-reset
	    profiler-raw-result
	    )
    (import :null)

  (define-cgen-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got '())
	 (result SG_UNDEF))))
    ((_ who msg got irritants)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got ,irritants)
	 (result SG_UNDEF)))))

  ;; for library dependency
  (define-c-proc identifier? (id) ::boolean
    (result (or (SG_IDENTIFIERP id)
		(SG_USER_DEFINED_SYNTXP id))))
  
  (define-c-proc identifier=? (use_env x mac_env y) ::boolean
    (result (Sg_IdentifierEqP use_env x mac_env y)))

  (define-c-proc id-name (id) ::Object
    (cond ((SG_IDENTIFIERP id)
	   (result (SG_IDENTIFIER_NAME id)))
	  ((SG_USER_DEFINED_SYNTXP id)
	   (result (SG_SYNTAX_NAME id)))
	  (else
	   (wrong-type-of-argument-violation 'id-name
					     "identifier"
					     id))))

  (define-c-proc identifier->symbol (id) ::Object
    (unless (or (SG_SYMBOLP id)
		(SG_IDENTIFIERP id))
      (wrong-type-of-argument-violation 'identifier->symbol
					"symbol or identifier"
					id))
    (if (SG_SYMBOLP id)
	(result id)
	(result (SG_IDENTIFIER_NAME id))))

  (define-c-proc id-memq (id lst) ::Object
    (if (SG_IDENTIFIERP id)
	(result (Sg_Memq (SG_IDENTIFIER_NAME id) lst))
	(result (Sg_Memq id lst))))

  ;; generics
  (define-c-proc make-generic (name::Symbol printer ctr :rest fields) ::Object
    (result (Sg_MakeGeneric name printer ctr fields)))
  
  (define-c-proc register-generic (name::Symbol g::Generic lib::Library) ::void
    (Sg_RegisterGeneric name g lib))

  (define-c-proc generic-ref (g name::Symbol) ::Object
    (result (Sg_GenericRef g name)))

  (define-c-proc generic-set! (g name::Symbol value) ::void
    (Sg_GenericSet g name value))

  (define-c-proc retrieve-generic (name::Symbol :optional (maybeLibrary #f)) ::Object
    (result (Sg_RetrieveGeneric name maybeLibrary)))

  (define-c-proc create-instance (g::Generic) ::Object
    (result (Sg_CreateInstance g)))

  ;; closure?
  (define-c-proc closure? (cl) ::boolean
    (result (SG_CLOSUREP cl)))

  (define-c-proc make-toplevel-closure (cb::CodeBuilder) ::Object
    ;; topleve closure should not have any free variables
    (result (Sg_MakeClosure cb NULL)))

  ;; list
  (define-c-proc circular-list? (lst) ::boolean
    (result (SG_CIRCULAR_LISTP lst)))

  ;; vector
  (define-c-proc vector-copy (vec::Vector :optional (start::fixnum 0)
					            (end::fixnum -1)
						    fill) ::Object
    (result (Sg_VectorCopy vec start end fill)))

  ;; hashtable
  (define-c-proc hashtable-keys (ht::HashTable) ::Object
    (result (Sg_HashTableKeys ht)))

  (define-c-proc hashtable-values (ht::HashTable) ::Object
    (result (Sg_HashTableValues ht)))


  (define-c-proc current-exception-handler (:optional handle) ::Object
    (if (SG_UNBOUNDP handle)
	(result (-> (Sg_VM) exceptionHandler))
	(begin
	  (set! (-> (Sg_VM) exceptionHandler) handle)
	  (result SG_UNDEF))))

  (define-c-proc parent-exception-handler (:optional handle) ::Object
    (if (SG_UNBOUNDP handle)
	(result (-> (Sg_VM) parentExHandler))
	(begin
	  (set! (-> (Sg_VM) parentExHandler) handle)
	  (result SG_UNDEF))))

  ;; misc
  (define-c-proc variable? (o) ::boolean
    (result (or (SG_SYMBOLP o)
		(SG_IDENTIFIERP o))))

  ;; arity returns pair of required and optional arguments count.
  ;; returned pair is structured like this : (<required> . <optional>)
  ;; <required> : # of required arguments
  ;; <optional> : #t or #f
  (define-c-proc arity (p::Procedure) ::Object
    (let ((req (SG_PROCEDURE_REQUIRED p))
	  (opt (SG_PROCEDURE_OPTIONAL p)))
      (if (> opt 0)
	  (result (Sg_Cons (SG_MAKE_INT req) #t))
	  (result (Sg_Cons (SG_MAKE_INT req) #f)))))

  (define-c-proc unbound () ::Object
    (result SG_UNBOUND))

  (define-c-proc undefined () ::Object
    (result SG_UNDEF))

  (define-c-proc undefined? (o) ::boolean
    (result (SG_UNDEFP o)))

  (define-c-proc add-load-path (path::String) ::Object
    (result (Sg_AddLoadPath path)))

  (define-c-proc load (path::String) ::Object
    (result (Sg_VMLoad path)))

  (define-c-proc gensym (:optional (prefix::String NULL)) ::Object
    (result (Sg_Gensym prefix)))

  (define-c-proc unwrap-syntax (form) ::Object
    (result (Sg_UnwrapSyntax form)))

  (define-c-proc wrap-syntax (form p1env::Vector) ::Object
    (result (Sg_WrapSyntax form p1env)))

  ;; io
  (define-cgen-stmt check-output-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_OUTPORTP ,p)
		   (SG_INOUTPORTP ,p))
	 (wrong-type-of-argument-violation ',name
					   "output port"
					   ,p)))))
  
  (define-c-proc port-closed? (p::Port) ::boolean
    (result (Sg_PortClosedP p)))

  (define-c-proc write/ss (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (check-output-port write/ss p)
    (Sg_Write o p SG_WRITE_SHARED))

  (define-c-proc format (p :rest rest) ::Object
    (cond ((SG_PORTP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (Sg_Format p fmt objs FALSE)
	     (result SG_UNDEF)))
	  ((SG_BOOLP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (if (SG_FALSEP p)
		 (let ((out (Sg_MakeStringOutputPort 16)))
		   (Sg_Format out fmt objs FALSE)
		   (result (Sg_GetStringFromStringPort out)))
		 (let ((out (Sg_CurrentOutputPort)))
		   (Sg_Format out fmt objs FALSE)
		   (result SG_UNDEF)))))
	  ((SG_STRINGP p)
	   (let ((out (Sg_MakeStringOutputPort 16)))
	     (Sg_Format out p rest FALSE)
	     (result (Sg_GetStringFromStringPort out))))))

  ;; profiler
  (define-c-proc profiler-start () ::void
    (Sg_ProfilerStart))
  (define-c-proc profiler-stop () ::fixnum
    (result (Sg_ProfilerStop)))
  (define-c-proc profiler-reset () ::void
    (Sg_ProfilerReset))

  (define-c-proc profiler-raw-result () ::Object
    (result (Sg_ProfilerRawResult)))
)