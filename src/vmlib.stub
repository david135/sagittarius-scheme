;; -*- scheme -*-
;; for Ypsilon
#!compatible
(library (sagittarius vm)
    (export :all)
    (import :none)
  (decl-code
   (.define "LIBSAGITTARIUS_BODY")
   (.include <sagittarius.h>
	     <sagittarius/instruction.h>))

  (define-cise-stmt assertion-violation
    ((_ who msg)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) '())))
    ((_ who msg irritants)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) ,irritants)
	 )))

  (define-cise-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got '())))
    ((_ who msg got irritants)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got ,irritants))))

  (define-c-proc insn-name (insn::<fixnum>) ::<top>
    (let ((info::InsnInfo* (Sg_LookupInsnName insn)))
      (result (Sg_MakeStringC (-> info name)))))

  ;; identifier
  (define-c-proc make-identifier (name envs maybe-library)
    (unless (or (SG_SYMBOLP name) (SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation 'make-identifier 
					"symbol or identifier" name))
    (unless (SG_LIBRARYP maybe-library)
      (set! maybe-library (Sg_FindLibrary maybe-library FALSE)))
    (result (Sg_MakeIdentifier name envs maybe-library)))

  (define-c-proc make-pattern-identifier (name envs maybe-library)
    (unless (or (SG_SYMBOLP name) (SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation 'make-identifier 
					"symbol or identifier" name))
    (unless (SG_LIBRARYP maybe-library)
      (set! maybe-library (Sg_FindLibrary maybe-library FALSE)))
    (let ((id (Sg_MakeIdentifier name SG_NIL maybe-library)))
      (set! (SG_IDENTIFIER_ENVS id) envs)
      (result id)))

  (define-c-proc pattern-variable? (o) ::<boolean>
    (result (and (SG_IDENTIFIERP o)
		 (not (SG_NULLP (SG_IDENTIFIER_ENVS o)))
		 (SG_SYMBOLP (SG_CAR (SG_IDENTIFIER_ENVS o))))))

  (define-c-proc id-envs (id::<identifier>) ::<top>
    (result (SG_IDENTIFIER_ENVS id)))

  (define-c-proc id-library (id::<identifier>) ::<top>
    (result (SG_IDENTIFIER_LIBRARY id)))

  (define-c-proc copy-identifier (id::<identifier> 
				  :optional (tmpl-var #f))
    (let ((r (Sg_CopyIdentifier id)))
      (unless (SG_FALSEP tmpl-var)
	(set! (SG_IDENTIFIER_ENVS r) tmpl-var))
      (result r)))

  (define-c-proc id-has-parent? (id::<identifier>)
    ::<boolean>
    (result (cast int (SG_IDENTIFIER_PARENT id))))

  (define-c-proc id-has-same-parent? (id1::<identifier> id2::<identifier>)
    ::<boolean>
    (for (() id1 (set! id1 (SG_IDENTIFIER_PARENT id1)))
	 (for (() id2 (set! id2 (SG_IDENTIFIER_PARENT id2)))
	      (if (SG_EQ id1 id2) (return #t))))
    (result FALSE))

  ;; syntax
  (define-c-proc make-syntax (name::<symbol> proc) Sg_MakeSyntax)

  (define-c-proc syntax-name (arg0::<syntax>) SG_SYNTAX_NAME)

  (define-c-proc syntax-proc (arg0::<syntax>) SG_SYNTAX_PROC)

  (define-c-proc syntax? (arg0) ::<boolean> SG_SYNTAXP)

  (define-c-proc call-syntax-handler (s::<syntax> expr p1env) ::<top>
    (result (Sg_VMApply2 (SG_SYNTAX_PROC s) expr p1env)))

  ;; macro
  (define-c-proc macro? (obj) ::<boolean> SG_MACROP)

  (define-c-proc make-macro 
    (name transformer data p1env :optional (maybe_library #f))
    Sg_MakeMacro)

  (define-c-proc make-macro-transformer (name proc p1env library)
    Sg_MakeMacroTransformer)

  (define-c-proc call-macro-expander (macro::<macro> expr p1env)
    (result (Sg_VMApply4 (-> macro transformer)
			 macro expr p1env (-> macro data))))

  (define-c-proc %internal-macro-expand (expr p1env onceP::<boolean>)
    Sg_MacroExpand)

  (define-c-proc reversible-gensym (sym::<symbol>) Sg_ReversibleGensym)

  ;; library
  (define-c-proc make-library (name) Sg_MakeLibrary)

  (define-c-proc library? (arg0) ::<boolean> SG_LIBRARYP)

  (define-c-proc library-name (arg0::<library>) SG_LIBRARY_NAME)

  (define-c-proc library-imported (arg0::<library>) SG_LIBRARY_IMPORTED)

  (define-c-proc library-imported-set! (arg0::<library> arg1) ::<void>
    (set! (SG_LIBRARY_IMPORTED arg0) arg1))

  (define-c-proc library-exported (arg0::<library>) SG_LIBRARY_EXPORTED)

  (define-c-proc library-exported-set! (arg0::<library> arg1) ::<void>
    (if (SG_FALSEP (SG_LIBRARY_EXPORTED arg0)) ;; not set yet
	(set! (SG_LIBRARY_EXPORTED arg0)  arg1)
	(let* ((exports (SG_CAR (SG_LIBRARY_EXPORTED arg0)))
	       (renames (SG_CDR (SG_LIBRARY_EXPORTED arg0))))
	  (set! (SG_LIBRARY_EXPORTED arg0)
		(Sg_Cons (Sg_Append2X exports (SG_CAR arg1))
			 (Sg_Append2X renames (SG_CDR arg1)))))))

  (define-c-proc library-defined (lib) 
    (cond ((SG_LIBRARYP lib) (result (SG_LIBRARY_DEFINEED lib)))
	  ((SG_FALSEP lib) (result (SG_LIBRARY_DEFINEED (Sg_VMCurrentLibrary))))
	  (else (wrong-type-of-argument-violation 'library-defined 
						  "library or #f" lib))))

  (define-c-proc library-defined-add! (lib::<library> v) ::<void>
    (unless (or (SG_SYMBOLP v) (SG_IDENTIFIERP v))
      (wrong-type-of-argument-violation 'library-defined-add!
					"symbol or identifier" v))
    (when (SG_IDENTIFIERP v) (set! v (SG_IDENTIFIER_NAME v)))
    (let ((def (SG_LIBRARY_DEFINEED lib)))
      (set! (SG_LIBRARY_DEFINEED lib) (Sg_Cons v def))))

  (define-c-proc library-table (lib::<library>) SG_LIBRARY_TABLE)

  (define-c-proc library-parents (lib::<library>)
    (result (-> lib parents)))

  (define-c-proc find-library (arg0 createp::<boolean>) Sg_FindLibrary)

  (define-c-proc %insert-binding (libname name value) ::<void>
    (unless (or (SG_SYMBOLP name)
		(SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation '%insert-binding
					"symbol or identifier"
					name))
    (let ((lib::SgObject (Sg_FindLibrary libname TRUE)))
      (Sg_InsertBinding lib name value)))

  (define-c-proc find-binding (arg0 arg1::<symbol> callback) Sg_FindBinding)

  (define-c-proc import-library (to from spec transp)
    (Sg_ImportLibraryFullSpec to from spec))

  (define-c-proc vm-current-library (:optional name::<library>)
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP name)
	  (result (-> vm currentLibrary))
	  (begin
	    (set! (-> vm currentLibrary) name)
	    ; dummy
	    (result SG_UNDEF)))))

  ;; gloc
  (define-c-proc gloc-ref (g::<gloc>) SG_GLOC_GET)

  (define-c-proc gloc-set! (g::<gloc> value) ::<void>
    (SG_GLOC_SET g value))

  (define-c-proc gloc-bound? (g::<gloc>) ::<boolean>
    (result (not (SG_UNBOUNDP (SG_GLOC_GET g)))))

  (define-c-proc gloc-const? (g::<gloc>) ::<boolean>
    (result (Sg_GlocConstP g)))

  (define-c-proc gloc-library (g::<gloc>) ::<top>
    (result (-> g library)))

  (define-c-proc gloc-name (g::<gloc>) ::<top>
    (result (-> g name)))

  ;; closure
  (define-c-proc make-toplevel-closure (cb::<code-builder>)
    ;; topleve closure should not have any free variables
    (result (Sg_MakeClosure cb NULL)))


  ;; code-builder
  (define-c-proc make-code-builder () ::<top>
    (result (Sg_MakeCodeBuilder 2)))

  (define-c-proc cb-emit0! (cb::<code-builder> insn::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF))

  (define-c-proc cb-emit1! (cb::<code-builder> insn::<fixnum> arg0::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF))

  (define-c-proc cb-emit2! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> arg1::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF))

  (define-c-proc cb-emit0i! (cb::<code-builder> insn::<fixnum> src) ::<void>    
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1i! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit2i! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> arg1::<fixnum> src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit0o! (cb::<code-builder> insn::<fixnum> obj) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj))

  (define-c-proc cb-emit0oi! (cb::<code-builder> insn::<fixnum> obj src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1oi! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> obj src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 arg0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-label-set! (cb::<code-builder> label) ::<void>
    (Sg_CodeBuilderLabelSet cb label))

  (define-c-proc cb-emit-closure! (cb::<code-builder> 
				   insn::<fixnum>
				   lambda_cb::<code-builder>
				   name 
				   req_argc::<fixnum>
				   opt::<boolean>
				   freec::<fixnum>
				   max_stack::<fixnum>
				   src) ::<void>
    (set! (SG_CODE_BUILDER_NAME lambda_cb) name)
    (set! (SG_CODE_BUILDER_ARGC lambda_cb) req_argc)
    (set! (SG_CODE_BUILDER_OPTIONAL lambda_cb) opt)
    (set! (SG_CODE_BUILDER_FREEC lambda_cb) freec)
    (set! (SG_CODE_BUILDER_MAX_STACK lambda_cb) max_stack)
    (Sg_CodeBuilderFlush lambda_cb)
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 lambda_cb)
    (Sg_CodeBuilderAddSrc lambda_cb insn src))

  (define-c-proc code-builder-label-defs (cb::<code-builder>) ::<top>
    (result (-> cb labelDefs)))

  (define-c-proc code-builder-finish-builder (cb::<code-builder> last::<fixnum>)
    (result (Sg_CodeBuilderFinishBuilder cb last)))

  ;; misc
  (define-c-proc vm-r6rs-mode? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_R6RS_MODE)))
  (define-c-proc vm-core-mode? () ::<boolean>
    (result (== (logand (ashr (-> (Sg_VM) flags) 8) #xFF) 0)))
  (define-c-proc vm-no-overwrite? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_OVERWRITE)))

  ;; (%map-cons l1 l2) = (map cons l1 l2)
  (define-c-proc %map-cons (l1 l2)
    (let ((h SG_NIL) (t SG_NIL))
      (while (and (SG_PAIRP l1) (SG_PAIRP l2))
	(SG_APPEND1 h t (Sg_Cons (SG_CAR l1) (SG_CAR l2)))
	(set! l1 (SG_CDR l1))
	(set! l2 (SG_CDR l2)))
      (result h)))

  ;; for better performance.
  ;; check if the given identifier shares the same environment
  (define-cfn p1env-lookup-aux (frame id) ::int :static
    (let ((env (SG_IDENTIFIER_ENVS id)))
      (unless (SG_EQ (SG_IDENTIFIER_LIBRARY id) (Sg_VMCurrentLibrary))
	(return FALSE))
      (dopairs (fp frame)
	(when (SG_EQ env fp) (return TRUE)))
      (return FALSE)))
  ;; NB: we skip some test, because we assume the frame is well-formed.
  (define-cfn p1env-lookup-inner (p1env::SgVector* name lookup_as frame?::int)
    :static
    (let ((name_identp::int (SG_IDENTIFIERP name))
	  (same-env?::int FALSE)
	  (frames (SG_VECTOR_ELEMENT p1env 1)))
;;      (label entry)
      (dopairs (fp frames)
	(when (and name_identp
		   (== (SG_IDENTIFIER_ENVS name) fp))
	  (set! same-env? TRUE)
	  ;; strip identifier if we're in the same env
	  (set! name (SG_OBJ (SG_IDENTIFIER_NAME name))))
	(when (> (SG_CAAR fp) lookup_as)
	  (continue))
	(dolist (vp (SG_CDAR fp))
	  (when (or (SG_EQ name (SG_CAR vp))
		    (and (SG_IDENTIFIERP (SG_CAR vp))
			 (SG_EQ name (SG_IDENTIFIER_NAME (SG_CAR vp)))
			 (or same-env?
			     (and (not name_identp)
				  (p1env-lookup-aux fp (SG_CAR vp))))))
	    (if frame?
		(return fp)
		(return (SG_CDR vp))))))
      ;; if the target reaches here and still an identifier,
      ;; which means either global variable or lexical variable but
      ;; copied identifier.
      ;; if the latter case, then we need to check parent as well.
;; no longer copy-identifier is used
;;      (when (and (not top?)
;;		 (SG_IDENTIFIERP name) (SG_IDENTIFIER_PARENT name)
;;		 (not (SG_NULLP frames)))
;;	(set! name (SG_IDENTIFIER_PARENT name))
;;	(goto entry))
      (return name)))

  (define-cfn p1env-lookup-rec (p1env::SgVector* name lookup-as)
    (return (p1env-lookup-inner p1env name lookup-as FALSE)))

  (define-c-proc p1env-lookup (p1env::<vector> name lookup_as)
    (let ((r (p1env-lookup-rec p1env name lookup_as)))
      (if (SG_SYMBOLP r)
	  (let ((lib (SG_VECTOR_ELEMENT p1env 0)))
	    (result (Sg_MakeIdentifier (SG_SYMBOL r) '() (SG_LIBRARY lib))))
	  (result r))))

  (define-c-proc p1env-lookup-frame (p1env::<vector> name lookup-as)
    (let ((r (p1env-lookup-inner p1env name lookup-as TRUE)))
      (if (or (SG_SYMBOLP r) (SG_IDENTIFIERP r))
	  (result SG_NIL)
	  (result r))))

  ;; check all env frames are macro
  (define-cfn check-env-frame (frames) ::int :static
    (dolist (frame frames)
      (unless (and (SG_PAIRP frame) (SG_MACROP (SG_CDR frame)))
	(return TRUE)))
    (return FALSE))

  (define-c-proc p1env-toplevel? (p1env) ::<boolean>
    (dolist (fp (SG_VECTOR_ELEMENT p1env 1))
      (let ((r6rs?::int (SG_VM_IS_SET_FLAG (Sg_VM) SG_R6RS_MODE)))
	(when (and (== (SG_CAR fp) (SG_MAKE_INT 0))
		   ;; this might cause some problem...
		   (or (not r6rs?) (check-env-frame (SG_CDR fp))))
	  (return SG_FALSE))))
    (result TRUE))

  ;; identifier is also syntax object, so it might contain some
  ;; other syntax info. this procedure checks it.
  (define-c-proc syntax-object=? (id1::<identifier> id2::<identifier>)
    ::<boolean>
    (result (and (SG_EQ (SG_IDENTIFIER_NAME id1) (SG_IDENTIFIER_NAME id2))
		 (SG_IDENTIFIER_TEMPLATE id1)
		 (SG_IDENTIFIER_TEMPLATE id2)
		 (or (SG_EQ (SG_IDENTIFIER_TEMPLATE id1)
			    (SG_IDENTIFIER_TEMPLATE id2))
		     (and (SG_IDENTIFIER_PARENT (SG_IDENTIFIER_TEMPLATE id1))
			  (SG_IDENTIFIER_PARENT (SG_IDENTIFIER_TEMPLATE id2))
			  (SG_EQ (SG_IDENTIFIER_PARENT
				  (SG_IDENTIFIER_TEMPLATE id1))
				 (SG_IDENTIFIER_PARENT
				  (SG_IDENTIFIER_TEMPLATE id2))))))))

  ;; TODO it's almost the same process as p1env-lookup
  ;; lookup pvar from p1env.
  ;; when we change the value of PATTERN in macro.scm(for now we don't use it
  ;; in compiler.scm), it needs to be changed as well.
  (define-c-proc p1env-pvar-lookup (p1env::<vector> name) ::<top>
    (let ((name_identp::int (SG_IDENTIFIERP name))
	  (frames (SG_VECTOR_ELEMENT p1env 1))
	  ;; for identifier=? we need a size 2 vector.
	  (dummy_env (Sg_MakeVector 2 SG_UNDEF)))
      (when name_identp
	(set! (SG_VECTOR_ELEMENT dummy_env 0) (SG_IDENTIFIER_LIBRARY name))
	(set! (SG_VECTOR_ELEMENT dummy_env 1) (SG_IDENTIFIER_ENVS name)))
      (dopairs (fp frames)
	(unless (== (SG_CAAR fp) (SG_MAKE_INT 2))
	  (continue))
	(dolist (vp (SG_CDAR fp))
	  (when (or (and name_identp
			 ;; global id.
			 (SG_NULLP (SG_IDENTIFIER_ENVS name))
			 (SG_EQ (SG_IDENTIFIER_NAME name) (SG_CAR vp)))
		    (and name_identp
			 (Sg_IdentifierEqP p1env name
					   dummy_env (SG_CAR vp)))
		    (SG_EQ name (SG_CAR vp)))
	    (return (SG_CDR vp)))))
      ;; no variable found in p1env.
      (if (SG_SYMBOLP name)
	  (let ((lib (SG_VECTOR_ELEMENT p1env 0)))
	    (result (Sg_MakeIdentifier (SG_SYMBOL name)
				       '()
				       (SG_LIBRARY lib))))
	  (result name))))

  (define-c-proc vm-frame-size () ::<fixnum>
    (result SG_FRAME_SIZE))

  (define-c-proc print-stack-frames () ::<void>
    (Sg_VMPrintFrame))

  (define-c-proc get-stack-trace-object () ::<top>
    (result (Sg_GetStackTrace)))

  ;; optimize
  (define-c-proc vm-noinline-locals? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_INLINE_LOCAL)))

  (define-c-proc vm-nolambda-lifting? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_LAMBDA_LIFT)))

  (define-c-proc vm-nolibrary-inlining? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_LIBRARY_INLINING)))

  (define-c-proc vm-noconstant-inlining? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_CONST_INLINING)))

  (define-c-proc gc () ::<void> Sg_GC)

  ;; call/pc
  (define-c-proc %call/pc (p::<procedure>)
    (result (Sg_VMCallPC p)))

  (define-c-proc %apply0 (p) Sg_Apply0)

  ;; the env needs to be used both transcribe and wrap-symbol
  ;; so that the same symboll will be renamed to the same identifier
  ;; in the same macro.
  (define-c-proc lookup-transformer-env (o)
    (unless (or (SG_SYMBOLP o) (SG_IDENTIFIERP o))
      (wrong-type-of-argument-violation 'add-to-transformer-env!
					"identifier or symbol" o))
    (let* ((vm::SgVM* (Sg_VM)))
      (cond ((SG_IDENTIFIERP o)
	     (let ((r (Sg_Assq (SG_IDENTIFIER_NAME o) (-> vm transEnv))))
	       (if (SG_FALSEP r)
		   (result r)
		   (if (SG_EQ (SG_IDENTIFIER_LIBRARY o) (SG_CADR r))
		       (result (SG_CDDR r))
		       (result SG_FALSE)))))
	    (else
	     (let ((r (Sg_Assq o (-> vm transEnv))))
	       (cond ((SG_FALSEP r) (result r))
		     ((SG_PAIRP (SG_CDR r)) (result #f))
		     (else (result (SG_CDR r)))))))))

  (define-c-proc add-to-transformer-env! (o n)
    (unless (or (SG_SYMBOLP o) (SG_IDENTIFIERP o))
      (wrong-type-of-argument-violation 'add-to-transformer-env!
					"identifier or symbol" o))
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_IDENTIFIERP o)
	  (set! (-> vm transEnv) (Sg_Acons (SG_IDENTIFIER_NAME o)
					   (Sg_Cons (SG_IDENTIFIER_LIBRARY o)
						    n)
					   (-> vm transEnv)))
	  (set! (-> vm transEnv) (Sg_Acons o n (-> vm transEnv))))
      (result n)))

  (define-c-proc current-transformer-env () (result (-> (Sg_VM) transEnv)))
)
