;; -*- scheme -*-
;; for Ypsilon
#!compatible
(library (sagittarius vm)
    (export insn-name
	    ;; identifier
	    make-identifier id-name-set!
	    id-envs id-envs-set! id-library
	    id-library-set!
	    copy-identifier
	    identifier-binding-eqv?
	    bound-id->symbol
	    
	    ;; syntax
	    make-syntax syntax? syntax-name syntax-proc
	    builtin-syntax? user-defined-syntax?
	    call-syntax-handler

	    ;; macro
	    make-macro macro-name macro-transformer
	    macro-data macro-library macro?
	    make-macro-transformer %internal-macro-expand
	    call-macro-expander

	    ;; library
	    make-library library? library-name library-imported
	    library-imported-set! library-exported library-exported-set!
	    library-table #;%set-library %insert-binding find-library
	    find-binding vm-current-library

	    ;; gloc
	    gloc-ref gloc-set! gloc-bound?
	    ;; for apropos
	    gloc-library
	    ;; for macro
	    gloc-name

	    ;; code-builder
	    make-code-builder cb-emit0! cb-emit1! cb-emit2! cb-emit0i!
	    cb-emit1i! cb-emit2i! cb-emit0o! cb-emit0oi! cb-emit1oi!
	    cb-label-set! cb-emit-closure! code-builder-finish-builder

	    ;; misc
	    import-library
	    vm-r6rs-mode? %map-cons
	    p1env-lookup p1env-toplevel? p1env-pvar-lookup
	    pass3/let-frame-size pass3/frame-size
	    print-stack-frames
	    get-stack-trace-object
	    set-toplevel-variable!
	    get-toplevel-variables
	    ;; for macro
	    rename-id
	    renamed-id?
	    )
    (import :none)
  (decl-code
   (.include <sagittarius/instruction.h>))

  (define-cgen-stmt assertion-violation
    ((_ who msg)
     (dispatch
      `(Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) '())))
    ((_ who msg irritants)
     (dispatch
      `(Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,irritants))))

  (define-cgen-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     (dispatch
      `(Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got '())))
    ((_ who msg got irritants)
     (dispatch
      `(Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got ,irritants))))


  (define-c-proc insn-name (insn::fixnum) ::Object
    (let ((info::InsnInfo* (Sg_LookupInsnName insn)))
      (result (Sg_MakeStringC info->name))))

  ;; identifier
  (define-c-proc make-identifier (name::Symbol envs library::Library) ::Object
    (result (Sg_MakeIdentifier name envs library)))

  (define-c-proc id-envs (id::Identifier) ::Object
    (result (SG_IDENTIFIER_ENVS id)))

  (define-c-proc id-library (id::Identifier) ::Object
    (result (SG_IDENTIFIER_LIBRARY id)))

  (define-c-proc copy-identifier (id::Identifier) ::Object
    (result (Sg_CopyIdentifier id)))

  (define-c-proc bound-id->symbol (id::Identifier) ::Object
    (if (SG_NULLP (SG_IDENTIFIER_ENVS id))
	(let ((s (Sg_Sprintf "%A.%x" (SG_IDENTIFIER_NAME id) id)))
	  (result (Sg_Intern s)))
	(result id)))

  ;; syntax
  (define-c-proc make-syntax (name::Symbol proc :optional (userDefined::boolean FALSE)) ::Object
    (result (Sg_MakeSyntax name proc userDefined)))

  (define-c-proc syntax-name (arg0::Syntax) ::Object
    (result (SG_SYNTAX_NAME arg0)))

  (define-c-proc syntax-proc (arg0::Syntax) ::Object
    (result (SG_SYNTAX_PROC arg0)))

  (define-c-proc syntax? (arg0) ::boolean
    (result (SG_SYNTAXP arg0)))

  (define-c-proc call-syntax-handler (s::Syntax expr p1env) ::Object
    (result (Sg_Apply (SG_SYNTAX_PROC s) (SG_LIST2 expr p1env))))

  ;; macro
  (define-c-proc macro? (obj) ::boolean
    (result (SG_MACROP obj)))

  (define-c-proc make-macro (name transformer data p1env :optional (maybe_library #f)) ::Object
    (result (Sg_MakeMacro name transformer data p1env maybe_library)))

  (define-c-proc make-macro-transformer (name proc p1env library) ::Object
    (result (Sg_MakeMacroTransformer name proc p1env library)))

  (define-c-proc call-macro-expander (macro::Macro expr p1env) ::Object
    (result (Sg_Apply4 (-> macro transformer)
		       macro expr p1env (-> macro data))))

  (define-c-proc %internal-macro-expand (expr p1env onceP::boolean) ::Object
    (result (Sg_MacroExpand expr p1env onceP)))

  ;; library
  (define-c-proc make-library (name) ::Object
    (result (Sg_MakeLibrary name)))

  (define-c-proc library? (arg0) ::boolean
    (result (SG_LIBRARYP arg0)))

  (define-c-proc library-name (arg0::Library) ::Object
    (result (SG_LIBRARY_NAME arg0)))

  (define-c-proc library-imported (arg0::Library) ::Object
    (result (SG_LIBRARY_IMPORTED arg0)))

  (define-c-proc library-imported-set! (arg0::Library arg1) ::void
    (set! (SG_LIBRARY_IMPORTED arg0) arg1))

  (define-c-proc library-exported (arg0::Library) ::Object
    (result (SG_LIBRARY_IMPORTED arg0)))

  (define-c-proc library-exported-set! (arg0::Library arg1) ::void
    (set! (SG_LIBRARY_EXPORTED arg0) arg1))

  (define-c-proc library-table (lib::Library) ::Object
    (result (SG_LIBRARY_TABLE lib)))

  #;(define-c-proc %set-library (arg0::Library) ::void
    (Sg_SetLibrary arg0))

  (define-c-proc find-library (arg0 createp::boolean) ::Object
    (result (Sg_FindLibrary arg0 createp)))

  (define-c-proc %insert-binding (libname name value) ::void
    (unless (or (SG_SYMBOLP name)
		(SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation '%insert-binding
					"symbol or identifier"
					name))
    (let ((lib::SgObject (Sg_FindLibrary libname TRUE)))
      (Sg_InsertBinding lib name value)))

  (define-c-proc find-binding (arg0 arg1::Symbol callback) ::Object
    (result (Sg_FindBinding arg0 arg1 callback)))

  (define-c-proc import-library (to from only except rename prefix transp) ::void
    (Sg_ImportLibraryFullSpec to from only except rename prefix))

  (define-c-proc vm-current-library (:optional (name::Library SG_UNBOUND)) ::Object
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP name)
	  (result vm->currentLibrary)
	  (begin
	    (set! vm->currentLibrary name)
	    ; dummy
	    (result SG_UNDEF)))))

  ;; gloc
  (define-c-proc gloc-ref (g::Gloc) ::Object
    (result (SG_GLOC_GET g)))

  (define-c-proc gloc-set! (g::Gloc value) ::void
    (SG_GLOC_SET g value))

  (define-c-proc gloc-bound? (g::Gloc) ::boolean
    (result (SG_UNBOUNDP (SG_GLOC_GET g))))

  (define-c-proc gloc-library (g::Gloc) ::Object
    (result (-> g library)))

  (define-c-proc gloc-name (g::Gloc) ::Object
    (result (-> g name)))

  ;; code-builder
  (define-c-proc make-code-builder () ::Object
    (result (Sg_MakeCodeBuilder 2)))

  (define-c-proc cb-emit0! (cb::CodeBuilder insn::fixnum) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF))

  (define-c-proc cb-emit1! (cb::CodeBuilder insn::fixnum arg0::fixnum) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF))

  (define-c-proc cb-emit2! (cb::CodeBuilder insn::fixnum arg0::fixnum arg1::fixnum) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF))

  (define-c-proc cb-emit0i! (cb::CodeBuilder insn::fixnum src) ::void    
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1i! (cb::CodeBuilder insn::fixnum arg0::fixnum src) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit2i! (cb::CodeBuilder insn::fixnum arg0::fixnum arg1::fixnum src) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit0o! (cb::CodeBuilder insn::fixnum obj) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj))

  (define-c-proc cb-emit0oi! (cb::CodeBuilder insn::fixnum obj src) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1oi! (cb::CodeBuilder insn::fixnum arg0::fixnum obj src) ::void
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 arg0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-label-set! (cb::CodeBuilder label) ::void
    (Sg_CodeBuilderLabelSet cb label))

  (define-c-proc cb-emit-closure! (cb::CodeBuilder 
				   insn::fixnum
				   lambda_cb::CodeBuilder
				   name 
				   req_argc::fixnum
				   opt::boolean
				   freec::fixnum
				   max_stack::fixnum
				   src) ::void
    (set! (SG_CODE_BUILDER_NAME lambda_cb) name)
    (set! (SG_CODE_BUILDER_ARGC lambda_cb) req_argc)
    (set! (SG_CODE_BUILDER_OPTIONAL lambda_cb) opt)
    (set! (SG_CODE_BUILDER_FREEC lambda_cb) freec)
    (set! (SG_CODE_BUILDER_MAX_STACK lambda_cb) max_stack)
    (Sg_CodeBuilderFlush lambda_cb)
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 lambda_cb)
    (Sg_CodeBuilderAddSrc lambda_cb insn src))

  (define-c-proc code-builder-finish-builder (cb::CodeBuilder last::fixnum) ::Object
    (result (Sg_CodeBuilderFinishBuilder cb last)))

  ;; misc
  (define-c-proc vm-r6rs-mode? () ::boolean
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_R6RS_MODE)))

  ;; (%map-cons l1 l2) = (map cons l1 l2)
  (define-c-proc %map-cons (l1 l2) ::Object
    (let ((h SG_NIL) (t SG_NIL))
      (while (and (SG_PAIRP l1) (SG_PAIRP l2))
	(SG_APPEND1 h t (Sg_Cons (SG_CAR l1) (SG_CAR l2)))
	(set! l1 (SG_CDR l1))
	(set! l2 (SG_CDR l2)))
      (result h)))

  ;; for better performance.
  ;; NB: we skip some test, because we assume the frame is well-formed.
  (define-c-proc p1env-lookup (p1env::Vector name lookup_as) ::Object
    (let ((name_identp::int (SG_IDENTIFIERP name))
	  (frames (SG_VECTOR_ELEMENT p1env 1)))
      (dopairs (fp frames)
	(when (and name_identp
		   (== (SG_IDENTIFIER_ENVS name) fp))
	  ;; strip identifier if we're in the same env
	  (set! name (SG_OBJ (SG_IDENTIFIER_NAME name))))
	(when (> (SG_CAAR fp) lookup_as)
	  (continue))
	(dolist (vp (SG_CDAR fp))
	  (when (SG_EQ name (SG_CAR vp))
	    (return (SG_CDR vp)))))
      (if (SG_SYMBOLP name)
	  (let ((lib (SG_VECTOR_ELEMENT p1env 0)))
	    (result (Sg_MakeIdentifier (SG_SYMBOL name) '() (SG_LIBRARY lib))))
	  (result name))))

  (define-c-proc p1env-toplevel? (p1env) ::boolean
    (result TRUE)
    (dolist (fp (SG_VECTOR_ELEMENT p1env 1))
      (if (== (SG_CAR fp) (SG_MAKE_INT 0)) (result FALSE))))

  ;; TODO it's almost the same process as p1env-lookup
  ;; lookup pvar from p1env.
  ;; when we change the value of PATTERN in macro.scm(for now we don't use it
  ;; in compiler.scm), it needs to be changed as well.
  (define-c-proc p1env-pvar-lookup (p1env::Vector name) ::Object
    (let ((name_identp::int (SG_IDENTIFIERP name))
	  (frames (SG_VECTOR_ELEMENT p1env 1))
	  ;; for identifier=? we need a size 2 vector.
	  (dummy_env (Sg_MakeVector 2 SG_UNDEF)))
      (when name_identp
	(set! (SG_VECTOR_ELEMENT dummy_env 0) (SG_IDENTIFIER_LIBRARY name))
	(set! (SG_VECTOR_ELEMENT dummy_env 1) (SG_IDENTIFIER_ENVS name)))
      (dopairs (fp frames)
	(unless (== (SG_CAAR fp) (SG_MAKE_INT 2))
	  (continue))
	(dolist (vp (SG_CDAR fp))
	  (when (or (and name_identp
			 ;; global id.
			 (SG_NULLP (SG_IDENTIFIER_ENVS name))
			 (SG_EQ (SG_IDENTIFIER_NAME name) (SG_CAR vp)))
		    (and name_identp
			 (Sg_IdentifierEqP p1env name
					   dummy_env (SG_CAR vp)))
		    (SG_EQ name (SG_CAR vp)))
	    (return (SG_CDR vp)))))
      ;; no variable found in p1env.
      (if (SG_SYMBOLP name)
	  (let ((lib (SG_VECTOR_ELEMENT p1env 0)))
	    (result (Sg_MakeIdentifier (SG_SYMBOL name)
				       '()
				       (SG_LIBRARY lib))))
	  (result name))))

  (define-c-proc pass3/frame-size () ::fixnum
    (result SG_FRAME_SIZE))

  (define-c-proc pass3/let-frame-size () ::fixnum
    (result SG_LET_FRAME_SIZE))

  (define-c-proc print-stack-frames () ::void
    (Sg_VMPrintFrame))

  (define-c-proc get-stack-trace-object () ::Object
    (result (Sg_GetStackTrace)))

  (define-c-proc set-toplevel-variable! (s::Symbol obj) ::void
    (Sg_VMSetToplevelVariable s obj))

  (define-c-proc get-toplevel-variables () ::Object
    (result (-> (Sg_VM) toplevelVariables)))
)
