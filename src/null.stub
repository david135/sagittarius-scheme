;; -*- scheme -*-
#!compatible ;; for ypsilon
(library null
    (export ;; R6RS (rnrs base (6))
	    ;; 11.1 base type
	    boolean? pair? symbol?
	    number? char? string?
	    vector? procedure? null?

	    ;; 11.5 equivalence predicates
	    eqv? eq? equal?
	    
	    ;; 11.7.4 numerical operations
	    ;; 11.7.4.1 numerical type predicates
	    complex? real? rational? integer?
	    real-valued? rational-valued?
	    integer-valued? exact? inexact?
	    ;; 11.7.4.2 generic conversions
	    inexact exact
	    ;; 11.7.4.3 arithmetic operations
	    = < > <= >=
	    zero? positive? negative? odd?
	    even? finite? infinite? nan?
	    max min
	    + +. - -. * *. / /. ;; added special operation from Gauche
	    abs div-and-mod div mod
	    div0 mod0
	    ;;div0-and-mod0 this is in arith.scm
	    
	    %gcd ;; real r6rs implementation is in scmlib.scm
	    numerator denominator 
	    floor ceiling truncate round
	    rationalize
	    exp log sin cos tan asin acos atan
	    sqrt exact-integer-sqrt expt
	    make-rectangular make-polar
	    real-part imag-part magnitude angle
	    ;; for r5rs comaptibility
	    quotient remainder modulo
	    ;; misc
	    integer-length
	    ;; 11.7.4.4 numerical input and output
	    number->string string->number

	    ;; 11.8 booleans
	    not boolean=?

	    ;; 11.9 pairs and lists
	    cons car cdr caar cadr cdar cddr
	    list? list length append reverse
	    list-tail list-ref
	    ;; map for-each ;; these are in scmlib.scm
	    acons append! ;; misc
	    list-transpose+ last-pair

	    ;; 11.10 symbols
	    symbol->string symbol=? string->symbol

	    ;; 11.11 characters
	    char->integer integer->char
	    char=? char<? char>? char<=? char>=?
	    
	    ;; 11.12 strings
	    make-string string string-length string-ref
	    string=? string<? string>? string<=? string>=? 
	    substring string-append string->list
	    list->string string-copy
	    ;; string-for-each ;; this is in scmlib.scm

	    ;; 11.13 vectors
	    make-vector vector vector-length
	    vector-ref vector-set!
	    vector->list list->vector
	    vector-fill!
	    ;; vector-map vector-for-each ;; these are in scmlib.scm

	    ;; 11.14 errors and violations
	    ;; error  ;; this in exception.c
	    assertion-violation ;; it's kinda ugly to define twice
	    syntax-error
	    scheme-error

	    ;; 11.15 control features
	    apply call-with-current-continuation call/cc
	    values
	    ;; call-with-values ;; this is in scmlib.scm
	    dynamic-wind

	    ;; standard libraries
	    ;; 1 Unicode
	    ;; 1.1 characters
	    char-upcase char-downcase char-titlecase char-foldcase
	    ;; char-ci related are in scmlib.scm
	    char-alphabetic? char-numeric? char-whitespace?
	    char-upper-case? char-lower-case? char-title-case?
	    char-general-category
	    ;; 1.2 strings
	    string-upcase string-downcase string-titlecase
	    string-foldcase
	    ;; string-ci related are in scmlib.scm(but not yet)
	    string-normalize-nfd string-normalize-nfkd
	    string-normalize-nfc string-normalize-nfkc

	    ;; 2 Bytevectors
	    ;; 2.2 general operations
	    native-endianness
	    bytevector? make-bytevector bytevector-length bytevector=?
	    bytevector-fill! bytevector-copy! bytevector-copy
	    ;; 2.3 operations on bytes and octets
	    bytevector-u8-ref bytevector-s8-ref bytevector-u8-set! bytevector-s8-set!
	    bytevector->u8-list u8-list->bytevector
	    ;; 2.4 operations on integers of arbitrary size
	    ;; these are in scmlib.scm
	    ;;bytevector-uint-ref bytevector-sint-ref
	    ;;bytevector-uint-set!  bytevector-sint-set!
	    ;;bytevector->uint-list bytevector->sint-list
	    ;;uint-list->bytevector sint-list->bytevector
	    ;; 2.5 operations on 16-bit integers
	    bytevector-u16-ref bytevector-s16-ref bytevector-u16-native-ref bytevector-s16-native-ref
	    bytevector-u16-set! bytevector-s16-set! bytevector-u16-native-set! bytevector-s16-native-set!
	    ;; 2.6 operations on 32-bit integers
	    bytevector-u32-ref bytevector-s32-ref bytevector-u32-native-ref bytevector-s32-native-ref
	    bytevector-u32-set! bytevector-s32-set! bytevector-u32-native-set! bytevector-s32-native-set!
	    ;; 2.7 operations on 64-bit integers
	    bytevector-u64-ref bytevector-s64-ref bytevector-u64-native-ref bytevector-s64-native-ref
	    bytevector-u64-set! bytevector-s64-set! bytevector-u64-native-set! bytevector-s64-native-set!
	    ;; 2.8 operations on ieee-754 representations
	    bytevector-ieee-single-ref bytevector-ieee-single-native-ref
	    bytevector-ieee-single-set! bytevector-ieee-single-native-set!
	    bytevector-ieee-double-ref bytevector-ieee-double-native-ref
	    bytevector-ieee-double-set! bytevector-ieee-double-native-set!
	    ;; 2.9 operations on strings
	    string->utf8 utf8->string
	    string->utf16 utf16->string
	    string->utf32 utf32->string

	    ;; 3 List utilities
	    memq memv ;;member ;; in scmlib.scm
	    assq assv ;;assoc  ;; in scmlib.scm
	    cons*

	    ;; 7 Exceptions and conditions
	    ;; 7.1 exceptions
	    with-exception-handler
	    raise raise-continuable
	    ;;rest of chapter 7 are in exceptions.c

	    ;; io
	    write/ss
	    ;; 8 I/O
	    ;; 8.1 condition types
	    ;; i/o condition types are in exception.c

	    ;; 8.2 port i/o
	    ;; 8.2.3 buffer modes
	    buffer-mode?

	    ;; 8.2.4 transcoders
	    latin-1-codec
	    utf-8-codec
	    utf-16-codec
	    native-eol-style
	    ;;; conditions are in exception.c
	    make-transcoder
	    native-transcoder
	    transcoder-codec
	    transcoder-eol-style
	    transcoder-error-handling-mode
	    bytevector->string
	    string->bytevector

	    ;; 8.2.5 end-of-file object
	    eof-object eof-object?

	    ;; 8.2.6 input port and output port
	    port?
	    port-transcoder
	    textual-port?
	    binary-port?
	    transcoded-port
	    port-has-port-position?
	    port-position
	    port-has-set-port-position!?
	    set-port-position
	    close-port
	    ;;call-with-port

	    ;; 8.2.7 input port
	    input-port?
	    port-eof?
	    open-file-input-port
	    open-bytevector-input-port
	    open-string-input-port
	    standard-input-port
	    current-input-port
	    make-custom-binary-input-port
	    make-custom-textual-input-port

	    ;; 8.2.8 binary input
	    get-u8
	    lookahead-u8
	    get-bytevector-n
	    get-bytevector-n!
	    get-bytevector-some
	    get-bytevector-all

	    ;; 8.2.9 textual port
	    get-char
	    lookahead-char
	    get-string-n
	    get-string-n!
	    get-string-all
	    get-line
	    get-dutum

	    ;; 8.2.10 output port
	    output-port?
	    flush-output-port
	    output-port-buffer-mode
	    open-file-output-port
	    ;; these functions are in scmlib.scm
	    ;; open-bytevector-output-port
	    ;; call-with-bytevector-output-port
	    ;; open-string-output-port
	    ;; call-with-string-output-port
	    ;; to implement above we provide these
	    open-output-bytevector
	    get-output-bytevector
	    open-output-string
	    get-output-string
	    standard-output-port
	    standard-error-port
	    current-output-port
	    current-error-port
	    make-custom-binary-output-port

	    ;; 8.2.11 binary output
	    put-u8
	    put-bytevector

	    ;; 8.2.12 textual output port
	    put-char
	    put-string
	    put-datum

	    ;; 8.2.13 input/output port
	    open-file-input/output-port
	    make-custom-binary-input/output-port
	    make-custom-textual-input/output-port

	    ;; 8.3 simple i/o
	    ;; these are in scmlib.scm
	    ;; call-with-input-file
	    ;; call-with-output-file
	    ;; with-input-from-file
	    ;; with-output-to-file
	    ;; open-input-file
	    ;; open-output-file
	    close-input-port
	    close-output-port
	    read-char peek-char read
	    write-char newline display write

	    ;; 9 File system
	    file-exists? delete-file

	    ;; 10 Command-line access and exit values
	    command-line exit

	    ;; 11 Arithmetic
	    ;; 11.2 fixnums
	    fixnum? fixnum-width least-fixnum greatest-fixnum
	    fx=? fx<? fx>? fx<=? fx>=?
	    fxzero? fxpositive? fxnegative? fxodd? fxeven?
	    fxmax fxmin
	    fx+ fx* fx-
	    fxdiv fxmod ;;fxdiv-and-mod
	    fxdiv0 fxmod0 ;; fxdiv0-and-mod0
	    ;;fx+/carry fx-/carry fx*/carry ;; these are in arith.scm
	    fxnot fxand fxior fxxor fxif
	    fxbit-count fxlength
	    fxfirst-bit-set
	    fxbit-set?
	    fxcopy-bit fxbit-field
	    fxcopy-bit-field
	    fxarithmetic-shift
	    fxarithmetic-shift-left
	    fxarithmetic-shift-right
	    ;; fxrotate-bit-field ;; this is in arith.scm
	    fxreverse-bit-field

	    ;; 11.3 flonums
	    flonum? real->flonum
	    fl=? fl<? fl>? fl<=? fl>=?
	    flinteger? flzero?
	    flpositive? flnegative?
	    flodd? fleven?
	    flfinite? flinfinite?
	    flnan? flmax flmin
	    fl+ fl* fl- fl/
	    fldiv flmod fldiv0 flmod0
	    ;; fldiv-and-mod fldiv0-and-mod0
	    flnumerator fldenominator
	    flfloor flceiling
	    fltruncate flround
	    flexp flexpt
	    fllog flsin
	    flcos fltan
	    flasin flacos
	    flatan flabs
	    flsqrt fixnum->flonum

	    ;; 11.4 exact bitwise arithmetic
	    bitwise-not bitwise-and bitwise-ior
	    bitwise-xor bitwise-if
	    bitwise-bit-count bitwise-length
	    bitwise-first-bit-set bitwise-bit-set?
	    bitwise-copy-bit bitwise-bit-field
	    bitwise-copy-bit-field
	    bitwise-arithmetic-shift
	    bitwise-arithmetic-shift-left
	    bitwise-arithmetic-shift-right
	    ;; in scmlib.scm
	    ;;bitwise-rotate-bit-field
	    ;;bitwise-reverse-bit-field


	    ;; 12 Syntax-case
	    ;; 12.5
	    identifier? bound-identifier=? free-identifier=?
	    
	    ;; 13 Hashtables
	    ;; 13.1 constructors
	    make-eq-hashtable
	    make-eqv-hashtable
	    make-hashtable

	    ;; 13.2 procedures
	    hashtable? hashtable-size
	    hashtable-ref hashtable-set! hashtable-delete!
	    hashtable-contains? 
	    #;hashtable-update! ;; in scmlib.scm
	    hashtable-copy hashtable-clear! hashtable-keys

	    ;; 13.3 inspection
	    ;; these are in scmlib.scm
	    ;;hashtable-equivalence-function hashtable-hash-function
	    hashtable-mutable?

	    ;; 13.4 hash functions
	    equal-hash string-hash string-ci-hash symbol-hash

	    ;; 15 composit library
	    ;; 16 eval
	    eval

	    ;; 17 mutable pairs
	    set-car! set-cdr!

	    ;; 18 mutable strings
	    string-set! string-fill!

	    ;; conditions
	    condition simple-conditions compound-condition-component
	    compound-condition? simple-condition? condition?
	    condition-predicate condition-accessor

	    ;; record
	    make-record-type
	    record-type-rtd record-type-rcd
	    make-record-type-descriptor
	    make-record-constructor-descriptor
	    record? record-rtd
	    record-type-descriptor?
	    record-constructor-descriptor?
	    record-constructor
	    record-accessor record-predicate record-mutator
	    record-type-name record-type-parent
	    record-type-uid record-type-generative?
	    record-type-opaque? record-type-sealed?
	    record-type-field-names
	    record-field-mutable?
	    ;; record helpers
	    rtd-fields
	    rtd-inherited-field-count rtd-total-field-count
	    rtd-ancestor?
	    rcd-protocol rcd-parent
	    ;; tuple for record helper
	    make-tuple tuple-list-set! tuple-ref ruple-set!)
    (import :none)
;; for Ypsilon
#!compatible
  (decl-code
   (.include <sagittarius/instruction.h>)
   (.include <sagittarius/builtin-symbols.h>))

  (define-cgen-stmt assertion-violation
    ((_ who msg)
     (dispatch
      `(begin
	 (Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) '())
	 (return SG_UNDEF))))
    ((_ who msg irritants)
     (dispatch
      `(begin
	 (Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,irritants)
	 (return SG_UNDEF)))))

  (define-cgen-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got '())
	 (return SG_UNDEF))))
    ((_ who msg got irritants)
     (dispatch
      `(begin
	 (Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got ,irritants)
	 (return SG_UNDEF)))))

  (define-cgen-stmt implementation-restriction-violation
    ((_ who msg)
     (dispatch
      `(begin
	 (Sg_ImplementationRestrictionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) '())
	 (return SG_UNDEF))))
    ((_ who msg irritants)
     (dispatch
      `(begin
	 (Sg_ImplementationRestrictionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,irritants)
	 (return SG_UNDEF)))))

  (define-cgen-stmt throw-i/o-error
    ((_ type who msg file)
     (dispatch
      `(begin
	 (Sg_IOError ,type ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,file SG_UNDEF)
	 (return SG_UNDEF)))))

  ;; x=? macro
  (define-cgen-stmt x=?
    ((_ checker compare name first second rest)
     (dispatch
      `(begin
	 (,checker ,name ,first)
	 (,checker ,name ,second)
	 (cond ((SG_NULLP ,rest)
		(result (,compare ,first ,second)))
	       ((not (,compare ,first ,second))
		(result FALSE))
	       (else
		(let ((prev ,second))
		  (dolist (p ,rest)
		    (,checker ,name p)
		    (unless (,compare prev p)
		      (return #f))
		    (set! prev p))
		  (result TRUE))))))))

  ;; 11.1 base type
  (define-c-proc boolean? (o) ::boolean
    (result (SG_BOOLP o)))

  (define-c-proc pair? (arg0::Object) (inline PAIRP) ::boolean
    (result (SG_PAIRP arg0)))

  (define-c-proc symbol? (arg0::Object) (inline SYMBOLP) ::boolean
    (result (SG_SYMBOLP arg0)))

  (define-c-proc number? (o) ::boolean
    (result (SG_NUMBERP o)))

  (define-c-proc char? (o) ::boolean
    (result (SG_CHARP o)))

  (define-c-proc string? (s) ::boolean
    (result (SG_STRINGP s)))

  (define-c-proc vector? (arg0::Object) (inline VECTORP) ::boolean
    (result (SG_VECTORP arg0)))

  (define-c-proc procedure? (arg0) ::boolean
    (result (SG_PROCEDUREP arg0)))

  (define-c-proc null? (arg0::Object) (inline NULLP) ::boolean
    (result (SG_NULLP arg0)))

  ;; 11.5 equivalence predicates
  (define-c-proc eq? (a b) (inline EQ) ::boolean
    (result (SG_EQ a b)))

  (define-c-proc eqv? (a b) (inline EQV) ::boolean
    (result (Sg_EqvP a b)))

  (define-c-proc equal? (a b) ::boolean
    (result (Sg_EqualP a b)))


  ;; 11.7.4.1 numerical type predicates
  (define-c-proc complex? (o) ::boolean
    (result (SG_NUMBERP o)))

  (define-c-proc real? (o) ::boolean
    (result (SG_REALP o)))

  (define-c-proc rational? (o) ::boolean
    (result (Sg_RationalP o)))

  (define-c-proc integer? (o) ::boolean
    (result (Sg_IntegerP o)))

  (define-c-proc real-valued? (o) ::boolean
    (result (Sg_RealValuedP o)))

  (define-c-proc rational-valued? (o) ::boolean
    (result (Sg_RationalValuedP o)))

  (define-c-proc integer-valued? (o) ::boolean
    (result (Sg_IntegerValuedP o)))

  (define-c-proc exact? (o) ::boolean
    (result (Sg_ExactP o)))

  (define-c-proc inexact? (o) ::boolean
    (result (Sg_InexactP o)))

  ;; 11.7.4.2 generic conversions
  (define-c-proc inexact (z::number) ::Object
    (result (Sg_Inexact z)))

  (define-c-proc exact (z::number) ::Object
    (result (Sg_Exact z)))

  ;; 11.7.4.3 arithmetic operations
  (define-cgen-stmt check-real
    ((_ name o)
     (dispatch
      `(unless (SG_REALP ,o)
	 (wrong-type-of-argument-violation ',name "real number" ,o)))))

  (define-cgen-stmt numcmp
    ((_ op compar)
     (dispatch 
      `(loop (cond ((not (,op (,compar arg0 arg1) 0)) (break))
		   ((SG_NULLP rest) (result TRUE) (break))
		   (else (set! arg0 arg1)
			 (set! arg1 (SG_CAR rest))
			 (set! rest (SG_CDR rest))))))))
  ;; = < > <= >=
  (define-c-proc = (arg0 arg1 :rest rest) ::boolean
    (result FALSE)
    (numcmp == Sg_NumEq))
  (define-c-proc < (arg0 arg1 :rest rest) ::boolean
    (result FALSE)
    (numcmp < Sg_NumCmp))
  (define-c-proc <= (arg0 arg1 :rest rest) ::boolean
    (result FALSE)
    (numcmp <= Sg_NumCmp))
  (define-c-proc > (arg0 arg1 :rest rest) ::boolean
    (result FALSE)
    (numcmp > Sg_NumCmp))
  (define-c-proc >= (arg0 arg1 :rest rest) ::boolean
    (result FALSE)
    (numcmp >= Sg_NumCmp))

  (define-c-proc zero? (arg0::number) ::boolean
    (result (and (SG_REALP arg0) (== (Sg_Sign arg0) 0))))

  (define-c-proc positive? (x::number) ::boolean
    (result (Sg_PositiveP x)))

  (define-c-proc negative? (x::number) ::boolean
    (result (Sg_NegativeP x)))

  (define-c-proc odd? (x::number) ::boolean
    (result (Sg_OddP x)))

  (define-c-proc even? (x::number) ::boolean
    (result (not (Sg_OddP x))))

  (define-c-proc finite? (x::number) ::boolean
    (result (Sg_FiniteP x)))

  (define-c-proc infinite? (x::number) ::boolean
    (result (Sg_InfiniteP x)))

  (define-c-proc nan? (x::number) ::boolean
    (result (Sg_NanP x)))
    
  (define-c-proc max (arg0 :rest rest) ::Object
    (Sg_MinMax arg0 rest NULL (& SG_RETURN)))

  (define-c-proc min (arg0 :rest rest) ::Object
    (Sg_MinMax arg0 rest (& SG_RETURN) NULL))


  ;; arithmetic
  (define-cgen-stmt check-number
    ((_ name v)
     (dispatch
      `(unless (SG_NUMBERP ,v)
	 (wrong-type-of-argument-violation ',name
					   "number"
					   ,v)))))

  (define-c-proc + (:rest rest) ::Object
    (cond ((not (SG_PAIRP rest)) (result (SG_MAKE_INT 0)))
	  ((not (SG_NUMBERP (SG_CAR rest)))
	   (wrong-type-of-argument-violation '+ "number" (SG_CAR rest) rest)
	   (result SG_UNDEF))		; dummy
	  (else 
	   (let ((r (SG_CAR rest)))
	     (dolist (v (SG_CDR rest))
	       (check-number + v)
	       (set! r (Sg_Add r v)))
	     (result r)))))

  (define-c-proc +. (:rest rest) ::Object
    (let ((a (Sg_MakeFlonum 0.0)))
      (dolist (x rest)
	(check-number +. x)
	(set! a (Sg_Add a (Sg_Inexact x))))
      (result a)))

  (define-c-proc * (:rest rest) ::Object
    (cond ((not (SG_PAIRP rest)) (result (SG_MAKE_INT 1)))
	  ((not (SG_NUMBERP (SG_CAR rest)))
	   (wrong-type-of-argument-violation '+ "number" (SG_CAR rest) rest)
	   (result SG_UNDEF))		; dummy
	  (else 
	   (let ((r (SG_CAR rest)))
	     (dolist (v (SG_CDR rest))
	       (check-number * v)
	       (set! r (Sg_Mul r v)))
	     (result r)))))

  (define-c-proc *. (:rest rest) ::Object
    (let ((a (Sg_MakeFlonum 0.0)))
      (dolist (x rest)
	(check-number *. x)
	(set! a (Sg_Mul a (Sg_Inexact x))))
      (result a)))

  (define-c-proc - (arg1::number :rest rest) ::Object
    (if (SG_NULLP rest)
	(result (Sg_Negate arg1))
	(begin 
	  (dolist (v rest)
	    (check-number - v)
	    (set! arg1 (Sg_Sub arg1 v)))
	  (result arg1))))
  (define-c-proc -. (arg1::number :rest rest) ::Object
    (cond ((SG_NULLP rest) (result (Sg_Negate (Sg_Inexact arg1))))
	  (else 
	   (dolist (x rest)
	     (check-number -. x)
	     (set! arg1 (Sg_Sub arg1 (Sg_Inexact x))))
	   (result arg1))))

  (define-c-proc / (arg1::number :rest rest) ::Object
    (if (SG_NULLP rest)
	(result (Sg_Inverse arg1))
	(let ((exact::int (Sg_ExactP arg1)))
	  (dolist (v rest)
	    (check-number / v)
	    ;; if inexact numbers have already appeared, 
	    ;; we can skip checking
	    (when exact
	      (set! exact (Sg_ExactP v)))
	    (if (and exact
		     (SG_VM_IS_SET_FLAG (Sg_VM) SG_R6RS_MODE)
		     (Sg_ZeroP v))
		(assertion-violation '/
				     "undefined for 0"
				     (Sg_Cons arg1 rest)))
	    (set! arg1 (Sg_Div arg1 v)))
	  (result arg1))))

  (define-c-proc /. (arg1::number :rest rest) ::Object
    (if (SG_NULLP rest)
	(result (Sg_Inverse (Sg_Inexact arg1)))
	(begin
	  (dolist (x rest)
	    (check-number / x)
	    (set! arg1 (Sg_Div arg1 (Sg_Inexact x))))
	  (result arg1))))

  ;; base arithmetic
  (define-c-proc abs (x::number) ::Object
    (result (Sg_Abs x)))

  (define-c-proc numerator (x::number) ::Object
    (result (Sg_Numerator x)))

  (define-c-proc denominator (x::number) ::Object
    (result (Sg_Denominator x)))

  (define-cgen-stmt check-real-valued
    ((_ name n)
     (dispatch
      `(unless (Sg_RealValuedP ,n)
	 (wrong-type-of-argument-violation ',name "real number" ,n)))))

  (define-c-proc floor (x::number) ::Object
    (check-real-valued floor x)
    (result (Sg_Round x SG_ROUND_FLOOR)))

  (define-c-proc ceiling (x::number) ::Object
    (check-real-valued ceiling x)
    (result (Sg_Round x SG_ROUND_CEIL)))

  (define-c-proc truncate (x::number) ::Object
    (check-real-valued truncate x)
    (result (Sg_Round x SG_ROUND_TRUNC)))

  (define-c-proc round (x::number) ::Object
    (check-real-valued round x)
    (result (Sg_Round x SG_ROUND_ROUND)))

  (define-cgen-stmt check-finite
    ((_ name n)
     (dispatch
      `(unless (Sg_FiniteP ,n)
	 (wrong-type-of-argument-violation ',name "finite" ,n)))))

  (define-cgen-stmt check-not-nan
    ((_ name n)
     (dispatch
      `(when (Sg_NanP ,n)
	 (wrong-type-of-argument-violation ',name "non nan" ,n)))))

  (define-cgen-stmt check-not-zero
    ((_ name n)
     (dispatch
      `(when (Sg_ZeroP ,n)
	 (wrong-type-of-argument-violation ',name "not zero" ,n)))))

  (define-cgen-stmt check-integer-arith-argument
    ((_ name x y)
     (dispatch
      `(begin
	 (check-finite ,name ,x)
	 (check-not-nan ,name ,x)
	 (check-not-zero ,name ,y)))))

  (define-c-proc div (x::number y::number) ::Object
    (check-integer-arith-argument div x y)
    (result (Sg_IntegerDiv x y)))

  (define-c-proc mod (x::number y::number) ::Object
    (check-integer-arith-argument mod x y)
    (result (Sg_IntegerMod x y)))

  (define-c-proc div0 (x::number y::number) ::Object
    (check-integer-arith-argument div0 x y)
    (result (Sg_IntegerDiv0 x y)))

  (define-c-proc mod0 (x::number y::number) ::Object
    (check-integer-arith-argument mod0 x y)
    (result (Sg_IntegerMod0 x y)))

  ;; takes 2. r6rs implementation is in scmlib.scm
  (define-c-proc %gcd (x::number y::number) ::Object
    (result (Sg_Gcd x y)))

  (define-c-proc exp (x::number) ::Object
    (result (Sg_Exp x)))

  (define-c-proc expt (x::number y::number) ::Object
    (result (Sg_Expt x y)))

  (define-c-proc log (x::number :optional (base::number SG_UNBOUND)) ::Object
    (if (SG_UNBOUNDP base)
	(if (== x (SG_MAKE_INT 0))
	    (assertion-violation 'log
				 "undefined for 0"
				 x)
	    (result (Sg_Log x)))
	(result (Sg_Div (Sg_Log x) (Sg_Log base)))))

  (define-c-proc make-rectangular (a::number b::number) ::Object
    (unless (SG_REALP a)
      (wrong-type-of-argument-violation 'make-rectangular "real number required" a (SG_LIST2 a b)))
    (unless (SG_REALP b)
      (wrong-type-of-argument-violation 'make-rectangular "real number required" b (SG_LIST2 a b)))
    (result (Sg_MakeComplex a b)))

  (define-c-proc make-polar (r::number t::number) ::Object
    (unless (SG_REALP r)
      (wrong-type-of-argument-violation 'make-polar "real number required" r (SG_LIST2 r t)))
    (unless (SG_REALP t)
      (wrong-type-of-argument-violation 'make-polar "real number required" t (SG_LIST2 r t)))
    (result (Sg_MakeComplexPolar r t)))

  (define-c-proc real-part (r::number) ::Object
    (cond ((SG_COMPLEXP r)
	   (result (-> (SG_COMPLEX r) real)))
	  ((SG_REALP r)
	   (result (SG_MAKE_INT 0)))
	  (else
	   ;; never happen
	   (wrong-type-of-argument-violation 'real-part "number required" r))))

  (define-c-proc imag-part (r::number) ::Object
    (cond ((SG_COMPLEXP r)
	   (result (-> (SG_COMPLEX r) imag)))
	  ((SG_REALP r)
	   (result (SG_MAKE_INT 0)))
	  (else
	   (wrong-type-of-argument-violation 'imag-part "number required" r))))  

  (define-c-proc magnitude (n::number) ::Object
    (result (Sg_Magnitude n)))

  (define-c-proc angle (n::number) ::Object
    (result (Sg_Angle n)))

  (define-c-proc sin (n::number) ::Object
    (check-real-valued sin n)
    (result (Sg_Sin n)))

  (define-c-proc cos (n::number) ::Object
    (check-real-valued cos n)
    (result (Sg_Cos n)))

  (define-c-proc tan (n::number) ::Object
    (check-real-valued tan n)
    (result (Sg_Tan n)))

  (define-c-proc asin (n::number) ::Object
    (check-real-valued asin n)
    (result (Sg_Asin n)))

  (define-c-proc acos (n::number) ::Object
    (check-real-valued acos n)
    (result (Sg_Acos n)))

  (define-c-proc atan (n::number :optional (n2::number SG_UNBOUND)) ::Object
    (check-real-valued atan n)
    (cond ((SG_UNBOUNDP n2)
	   (when (Sg_ZeroP n)
	     (assertion-violation 'atan "division by zero" n))
	   (result (Sg_Atan n)))
	  (else
	   (check-real-valued atan n2)
	   (result (Sg_Atan2 n n2)))))

  (define-c-proc sqrt (n::number) ::Object
    (result (Sg_Sqrt n)))

  (define-c-proc exact-integer-sqrt (n::number) ::Object
    (when (or (Sg_NegativeP n)
	      (not (SG_EXACT_INTP n)))
      (wrong-type-of-argument-violation 'exact-integer-sqrt "non-negative exact integer required" n))
    (result (Sg_ExactIntegerSqrt n)))

  (define-c-proc rationalize (x::number e::number) ::Object
    (check-real rationalize x)
    (check-real rationalize e)
    (result (Sg_Rationalize x e)))

  ;; r5rs compatible
  (define-c-proc quotient (n1::number n2::number) ::Object
    (result (Sg_Quotient n1 n2 NULL)))

  (define-c-proc remainder (n1::number n2::number) ::Object
    (result (Sg_Modulo n1 n2 TRUE)))

  (define-c-proc modulo (n1::number n2::number) ::Object
    (result (Sg_Modulo n1 n2 FALSE)))

  (define-c-proc integer-length (n::number) ::fixnum
    (result (Sg_IntegerLength n)))

  ;; 11.7.4.4 numerical input and output
  (define-c-proc number->string (z::number
				 :optional (radix::fixnum 10)
				           (precision::fixnum 1)) ::Object
    ;; ignore precision
    (result (Sg_NumberToString z radix FALSE)))

  (define-c-proc string->number (s::String :optional (radix::fixnum 10)) ::Object
    (result (Sg_StringToNumber s radix FALSE)))

  ;; 11.8 booleans
  (define-c-proc not (arg0) ::boolean
    (result (SG_FALSEP arg0)))

  (define-cgen-stmt check-boolean
    ((_ name b)
     (dispatch
      `(unless (SG_BOOLP ,b)
	 (wrong-type-of-argument-violation ',name "boolean" ,b)))))

  (define-c-proc boolean=? (b1 b2 :rest rest) ::boolean
    (x=? check-boolean SG_EQ boolean=? b1 b2 rest))

  ;; 11.9 pairs and lists
  (define-c-proc cons (o1 o2) (inline CONS) ::Object
    (result (Sg_Cons o1 o2)))

  (define-c-proc car (o) (inline CAR) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'car "pair" o))
    (result (SG_CAR o)))

  (define-c-proc cdr (o) (inline CDR) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cdr "pair" o))
    (result (SG_CDR o)))

  (define-c-proc caar (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'caar "pair" o))
    (unless (SG_PAIRP (SG_CAR o))
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (result (SG_CAAR o)))

  (define-c-proc cadr (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (unless (SG_PAIRP (SG_CDR o))
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (result (SG_CADR o)))

  (define-c-proc cdar (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cdar "pair" o))
    (unless (SG_PAIRP (SG_CAR o))
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (result (SG_CDAR o)))

  (define-c-proc cddr (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cddr "pair" o))
    (unless (SG_PAIRP (SG_CDR o))
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (result (SG_CDDR o)))

  (define-c-proc list? (arg0::Object) ::boolean
    (result (SG_PROPER_LISTP arg0)))

  (define-c-proc list (:rest rest) (inline LIST) ::Object
    (result rest))

  (define-c-proc length (lst) ::fixnum
    (result (Sg_Length lst)))

  (define-c-proc append (:rest lst) ::Object
    (result (Sg_Append lst)))

  (define-c-proc reverse (lst) ::Object
    (result (Sg_Reverse lst)))

  (define-c-proc list-tail (lst k::fixnum :optional fallback) ::Object
    (result (Sg_ListTail lst k fallback)))

  (define-c-proc list-ref (lst k::fixnum :optional fallback) ::Object
    (result (Sg_ListRef lst k fallback)))
  ;; list miscs
  (define-c-proc acons (a b alist) ::Object
    (result (Sg_Acons a b alist)))

  (define-c-proc append! (:rest lst) ::Object
    (let ((h '()) (t '()))
      (dopairs (cp lst)
	(when (and (not (SG_PAIRP (SG_CAR cp)))
		   (SG_NULLP (SG_CDR cp)))
	  (if (SG_NULLP h)
	      (set! h (SG_CAR cp))
	      (SG_SET_CDR t (SG_CAR cp)))
	  (break))
	(SG_APPEND h t (SG_CAR cp)))
      (result h)))

;;  (define-cgen-stmt do-transpose
;;    ((_ lst)
;;     (dispatch
;;      `(let ((h '())(t '())
;;	     (count::int (Sg_Length ,lst))
;;	     (argv (Sg_ListToVector ,lst 0 -1))
;;	     (lst0 (SG_VECTOR_ELEMENT argv 0)))
;;	 (dolist (l lst0)
;;	   (let ((elt (Sg_Cons l '()))
;;		 (elt_tail elt)
;;		 (n::int 1))
;;	     (while (< n count)
;;	       (SG_SET_CDR elt_tail (Sg_Cons (SG_CAR (SG_VECTOR_ELEMENT argv n)) '()))
;;	       (set! elt_tail (SG_CDR elt_tail))
;;	       (set! (SG_VECTOR_ELEMENT argv n)
;;		     (SG_CDR (SG_VECTOR_ELEMENT argv n)))
;;	       (set! n (+ n 1)))
;;	     (SG_APPEND1 h t elt)))
;;	 (result h)))))
;;
;;  (define-c-proc list-transpose+ (lst0 :rest rest) ::Object
;;    (cond ((not (SG_LISTP lst0)) (result #f))
;;	  (else
;;	   (let ((each_len::int (Sg_Length lst0)))
;;	     #;(dolist (x rest)
;;	       (if (SG_LISTP x)
;;		   (unless (not (== (Sg_Length x) each_len))
;;		     (return #f))
;;		   (return #f)))
;;	     (let ((tmp (Sg_Cons lst0 rest)))
;;	       (do-transpose tmp))))))

  (define-c-proc last-pair (lst) ::Object
    (result (Sg_LastPair lst)))

  ;; 11.10 symbols
  (define-c-proc symbol->string (z::Symbol) ::Object
    (result (Sg_CopyString (-> z name))))

  (define-cgen-stmt check-symbol
    ((_ name s)
     (dispatch
      `(unless (SG_SYMBOLP ,s)
	 (wrong-type-of-argument-violation ',name "symbol" ,s)))))

  (define-c-proc symbol=? (s1::Symbol s2::Symbol :rest rest) ::boolean
    (x=? check-symbol SG_EQ symbol=? s1 s2 rest))

  (define-c-proc string->symbol (z::String) ::Object
    (result (Sg_Intern z)))

  ;; 11.11 characters
  (define-cgen-stmt check-char
    ((_ name c)
     (dispatch
      `(unless (SG_CHARP ,c)
	 (wrong-type-of-argument-violation ',name "char" ,c)))))

  (define-c-proc char->integer (c) ::Object
    (check-char char->integer c)
    (result (SG_MAKE_INT (SG_CHAR_VALUE c))))

  (define-c-proc integer->char (ch::fixnum) ::Object
    (unless (or (and (<= 0 ch)
		     (<= ch #xD7FF))
		(and (<= #xE000 ch)
		     (<= ch #x10FFFF)))
      (assertion-violation 'integer->char "code point out of range"
			   (SG_MAKE_INT ch)))
    (result (SG_MAKE_CHAR ch)))

  (define-c-proc char=? (c1 c2 :rest rest) ::boolean
    (x=? check-char SG_EQ char=? c1 c2 rest))

  (define-cgen-stmt char<>=?
    ((_ compare name first second rest)
     (dispatch
      `(begin
	 (check-char ,name ,first)
	 (check-char ,name ,second)
	 (cond ((SG_NULLP ,rest)
		(result (,compare ,first ,second)))
	       ((not (,compare ,first ,second))
		(result FALSE))
	       (else
		(let ((prev ,second))
		  (dolist (p ,rest)
		    (check-char ,name p)
		    (unless (,compare prev p)
		      (return #f))
		    (set! prev p))
		  (result TRUE))))))))

  (define-c-proc char<? (c1 c2 :rest rest) ::boolean
    (char<>=? < char<? c1 c2 rest))

  (define-c-proc char>? (c1 c2 :rest rest) ::boolean
    (char<>=? > char>? c1 c2 rest))

  (define-c-proc char<=? (c1 c2 :rest rest) ::boolean
    (char<>=? <= char<=? c1 c2 rest))

  (define-c-proc char>=? (c1 c2 :rest rest) ::boolean
    (char<>=? >= char>=? c1 c2 rest))

  ;; 11.12 strings
  (define-cgen-stmt check-string
    ((_ name s)
     (dispatch
      `(unless (SG_STRINGP ,s)
	 (wrong-type-of-argument-violation ',name "string" ,s)))))

  (define-c-proc make-string (k::fixnum :optional (c (SG_MAKE_CHAR #\space))) ::Object
    (unless (SG_CHARP c)
      (wrong-type-of-argument-violation 'make-string "char" c (SG_LIST2 (SG_MAKE_INT k) c)))
    (result (Sg_ReserveString k (SG_CHAR_VALUE c))))

  (define-c-proc string (:rest rest) ::Object
    (result (Sg_ListToString rest)))

  (define-c-proc string-length (s::String) ::fixnum
    (result s->size))

  (define-c-proc string-ref (s::String k::fixnum :optional fallback) ::Object
    (cond ((or (< k 0)
	       (>= k (SG_STRING_SIZE s)))
	   (when (SG_UNBOUNDP fallback)
	     (assertion-violation 'string-ref "index out of bounds"
				  (SG_LIST2 s (SG_MAKE_INT k))))
	   (result fallback))
	  (else (result (SG_MAKE_CHAR (SG_STRING_VALUE_AT s k))))))

  ;; string compares
  (define-c-proc string=? (s1::String s2::String :rest rest) ::boolean
    (x=? check-string Sg_StringEqual string=? s1 s2 rest))

  (define-cgen-stmt string-compare
    ((_ compare value name first second rest)
     (dispatch
      `(begin
	 (cond ((SG_NULLP ,rest)
		(result (,compare (Sg_StringCompare ,first ,second) ,value)))
	       ((not (,compare (Sg_StringCompare ,first ,second) ,value))
		(result FALSE))
	       (else
		(let ((prev ,second))
		  (dolist (p ,rest)
		    (check-string ,name p)
		    (unless (,compare (Sg_StringCompare prev p) ,value)
		      (return #f))
		    (set! prev p))
		  (result TRUE))))))))

  (define-c-proc string<? (s1::String s2::String :rest rest) ::boolean
    (string-compare == -1 string<? s1 s2 rest))

  (define-c-proc string>? (s1::String s2::String :rest rest) ::boolean
    (string-compare == 1 string>? s1 s2 rest))

  (define-c-proc string<=? (s1::String s2::String :rest rest) ::boolean
    (string-compare <= 0 string<=? s1 s2 rest))

  (define-c-proc string>=? (s1::String s2::String :rest rest) ::boolean
    (string-compare >= 0 string>=? s1 s2 rest))

  (define-c-proc substring (s::String start::fixnum end::fixnum) ::Object
    (when (< start 0)
      (wrong-type-of-argument-violation 'substring "non negative exact integer"
					(SG_MAKE_INT start)
					(SG_LIST3 s (SG_MAKE_INT start) (SG_MAKE_INT end))))
    (when (< end 0)
      (wrong-type-of-argument-violation 'substring "non negative exact integer"
					(SG_MAKE_INT end)
					(SG_LIST3 s (SG_MAKE_INT start) (SG_MAKE_INT end))))
    (when (< end start)
      (assertion-violation 'substring "end index is smaller than start index"
			   (SG_LIST3 s (SG_MAKE_INT start) (SG_MAKE_INT end))))
    (when (< (SG_STRING_SIZE s) end)
      (assertion-violation 'substring "end index out of bounds"
			   (SG_LIST3 s (SG_MAKE_INT start) (SG_MAKE_INT end))))
    (result (Sg_Substring s start end)))

  (define-c-proc string-append (:rest rest) ::Object
    (result (Sg_StringAppend rest)))

  ;; we take start+end as optional arguments for srfi-13
  (define-c-proc string->list (s::String :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (result (Sg_StringToList s start end)))

  (define-c-proc list->string (o) ::Object
    (result (Sg_ListToString o)))

  ;; we take start+end as optional arguments for srfi-13
  (define-c-proc string-copy (s::String :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (result (Sg_Substring s start end)))

  ;; 11.13 vectors
  (define-c-proc make-vector (size::fixnum :optional (fill SG_UNDEF)) ::Object
    (result (Sg_MakeVector size fill)))

  (define-c-proc vector (:rest rest) (inline VECTOR) ::Object
    (result (Sg_ListToVector rest 0 -1)))

  (define-c-proc vector-length (vec::Vector) (inline VEC_LEN) ::fixnum
    (result (SG_VECTOR_SIZE vec)))

  (define-c-proc vector-ref (vec::Vector i::fixnum :optional fallback) ::Object
    (cond ((or (< i 0)
	       (>= i (SG_VECTOR_SIZE vec)))
	   (when (SG_UNBOUNDP fallback)
	     (assertion-violation 'vector-ref "index out of range" (SG_MAKE_INT i)))
	   (result fallback))
	  (else (result (SG_VECTOR_ELEMENT vec i)))))
     
  (define-c-proc vector-set! (vec::Vector i::fixnum obj) ::void
    (when (SG_LITERAL_VECTORP vec)
      (assertion-violation 'vector-set "attempt to modify immutable vector"
			   (SG_LIST1 vec)))
    (cond ((or (< i 0)
	       (>= i (SG_VECTOR_SIZE vec)))
	   (assertion-violation 'vector-ref "index out of range" (SG_MAKE_INT i)))
	  (else (set! (SG_VECTOR_ELEMENT vec i) obj))))

  (define-c-proc vector->list (vec::Vector :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (result (Sg_VectorToList vec start end)))
  
  (define-c-proc list->vector (lst :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (unless (SG_LISTP lst)
      (wrong-type-of-argument-violation 'list->vector "propert list" lst))
    (result (Sg_ListToVector lst start end)))

  (define-c-proc vector-fill! (vec::Vector fill) ::Object
    (Sg_VectorFill vec fill 0 -1))

  ;; 11.14 errors and violations
  (define-c-proc assertion-violation (who message :rest irritants) ::void
    (Sg_AssertionViolation who message irritants))

  ;; we might remove this
  (define-c-proc scheme-error (who msg :rest irritant) ::void
    (Sg_Error "%S %A %S" who msg irritant))

  (define-c-proc syntax-error (form :rest irritant) ::void
    (Sg_SyntaxError form irritant))

  ;; 11.15 control features
  (define-c-proc apply (proc::Procedure arg1 :rest rest) (inline APPLY) ::Object
    (let ((head::SgObject '()) (tail::SgObject '()))
      (cond ((SG_NULLP rest) (result (Sg_VMApply proc arg1)))
	    (else 
	     (set! head (Sg_Cons arg1 '()))
	     (set! tail head)
	     (dopairs (cp rest)
	       (when (SG_NULLP (SG_CDR cp))
		 (SG_APPEND head tail (SG_CAR cp))
		 (break))
	       (unless (SG_PAIRP (SG_CDR cp))
		 (assertion-violation 'apply "improper list not allowed"
				      rest))
	       (SG_APPEND1 head tail (SG_CAR cp)))
	     (result (Sg_VMApply proc head))))))

  ;; call/cc
  (define-c-proc call/cc (proc::Procedure) ::Object
    (result (Sg_VMCallCC proc)))
  
  (define-c-proc call-with-current-continuation (proc::Procedure) ::Object
    (result (Sg_VMCallCC proc)))

  (define-c-proc values (:rest rest) (inline VALUES) ::Object
    (let ((len::int (Sg_Length rest)))
      (cond ((== len 0) (result (Sg_MakeValues 0)))
	    ((== len 1) (result (SG_CAR rest)))
	    (else
	     (let ((v (Sg_MakeValues len))
		   (i::int 0))
	       (dolist (e rest)
		 (set! (SG_VALUES_ELEMENT v i) e)
		 (post++ i))
	       (result v))))))

  (define-c-proc dynamic-wind (before thunk after) ::Object
    (result (Sg_VMDynamicWind before thunk after)))

  ;; standard libraries
  ;; 1 Unicode
  ;; 1.1 characters
  (define-cgen-stmt check-char
    ((_ name c)
     (dispatch
      `(unless (SG_CHARP ,c)
	 (wrong-type-of-argument-violation ',name "character" ,c)))))

  (define-c-proc char-upcase (c) ::Object
    (check-char char-upcase c)
    (result (SG_MAKE_CHAR (Sg_CharUpCase (SG_CHAR_VALUE c)))))

  (define-c-proc char-downcase (c) ::Object
    (check-char char-downcase c)
    (result (SG_MAKE_CHAR (Sg_CharDownCase (SG_CHAR_VALUE c)))))

  (define-c-proc char-titlecase (c) ::Object
    (check-char char-titlecase c)
    (result (SG_MAKE_CHAR (Sg_CharTitleCase (SG_CHAR_VALUE c)))))

  (define-c-proc char-foldcase (c) ::Object
    (check-char char-foldcase c)
    (result (SG_MAKE_CHAR (Sg_CharFoldCase (SG_CHAR_VALUE c)))))

  (define-c-proc char-general-category (c) ::Object
    (check-char char-general-category c)
    (result (Sg_CategroyToSymbol (Sg_CharGeneralCategory (SG_CHAR_VALUE c)))))

  (define-c-proc char-alphabetic? (c) ::boolean
    (check-char char-alphabetic? c)
    (result (Sg_CharAlphabeticP (SG_CHAR_VALUE c))))

  (define-c-proc char-numeric? (c) ::boolean
    (check-char char-numeric? c)
    (result (Sg_CharNumericP (SG_CHAR_VALUE c))))

  (define-c-proc char-whitespace? (c) ::boolean
    (check-char char-whitespace? c)
    (result (Sg_Ucs4WhiteSpaceP (SG_CHAR_VALUE c))))

  (define-c-proc char-upper-case? (c) ::boolean
    (check-char char-upper-case? c)
    (result (Sg_CharUpperCaseP (SG_CHAR_VALUE c))))

  (define-c-proc char-lower-case? (c) ::boolean
    (check-char char-lower-case? c)
    (result (Sg_CharLowerCaseP (SG_CHAR_VALUE c))))

  (define-c-proc char-title-case? (c) ::boolean
    (check-char char-title-case? c)
    (result (Sg_CharTitleCaseP (SG_CHAR_VALUE c))))

  ;; 1.2 strings
  (define-c-proc string-upcase (s::String) ::Object
    (result (Sg_StringUpCase s)))

  (define-c-proc string-downcase (s::String) ::Object
    (result (Sg_StringDownCase s)))

  (define-c-proc string-titlecase (s::String) ::Object
    (result (Sg_StringTitleCase s)))

  (define-c-proc string-foldcase (s::String) ::Object
    (result (Sg_StringFoldCase s)))

  (define-c-proc string-normalize-nfd (s::String) ::Object
    (result (Sg_StringNormalizeNfd s)))

  (define-c-proc string-normalize-nfkd (s::String) ::Object
    (result (Sg_StringNormalizeNfkd s)))

  (define-c-proc string-normalize-nfc  (s::String) ::Object
    (result (Sg_StringNormalizeNfc s)))
  
  (define-c-proc string-normalize-nfkc (s::String) ::Object
    (result (Sg_StringNormalizeNfkc s)))

  ;; 2 Bytevectors
  ;; 2.2 general operations
  (define-c-proc native-endianness () ::Object
    (result (Sg_NativeEndianness)))

  (define-c-proc bytevector=? (bv1::ByteVector bv2::ByteVector) ::boolean
    (result (Sg_ByteVectorEqP bv1 bv2)))

  (define-c-proc bytevector-copy (src::ByteVector) ::Object
    (result (Sg_ByteVectorCopy src)))

  (define-c-proc bytevector-copy! (src::ByteVector sstart::fixnum
				   dst::ByteVector dstart::fixnum
				   k::fixnum) ::void
    (Sg_ByteVectorCopyX src sstart dst dstart k))

  (define-c-proc make-bytevector (len::fixnum :optional (fill::fixnum 0)) ::Object
    (result (Sg_MakeByteVector len fill)))

  (define-c-proc bytevector? (o) ::boolean
    (result (SG_BVECTORP o)))

  (define-c-proc bytevector-length (bv::ByteVector) ::fixnum
    (result (SG_BVECTOR_SIZE bv)))

  (define-c-proc bytevector-fill! (bv::ByteVector fill::fixnum) ::void
    (Sg_ByteVectorFill bv fill))
  
  ;; 2.3 operations on bytes and octets
  (define-c-proc u8-list->bytevector (lst) ::Object
    (result (Sg_ListToByteVector lst 8 FALSE)))

  (define-c-proc bytevector->u8-list (lst) ::Object
    (result (Sg_ByteVectorToList lst 8 FALSE)))

  (define-cgen-stmt bv-check-index
    ((_ name bv index)
     (dispatch
      `(unless (> (SG_BVECTOR_SIZE ,bv) ,index)
	 (assertion-violation ',name "index out of range" (SG_MAKE_INT ,index)))))
    ((_ name bv index offset)
     (dispatch
      `(let ((len::int (SG_BVECTOR_SIZE ,bv)))
	 (unless (and (> len ,offset)
		      (< ,index (- len ,offset)))
	   (assertion-violation ',name "index out of range" (SG_MAKE_INT ,index)))))))

  (define-c-proc bytevector-u8-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bytevector-u8-ref bv index)
    (result (Sg_ByteVectorU8Ref bv index)))

  (define-c-proc bytevector-u8-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bytevector-u8-set! bv index)
    (unless (SG_IS_OCTET value)
      (assertion-violation 'bytevector-u8-set!
			   "value out of range. must be 0 <= value <= 255"
			   (SG_MAKE_INT value)))
    (Sg_ByteVectorU8Set bv index value))

  (define-c-proc bytevector-s8-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bytevector-s8-ref bv index)
    (result (Sg_ByteVectorS8Ref bv index)))

  (define-c-proc bytevector-s8-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bytevector-s8-set! bv index)
    (unless (SG_IS_BYTE value)
      (assertion-violation 'bytevector-s8-set! 
			   "value out of range. must be -127 <= value <= 128"
			   (SG_MAKE_INT value)))
    (Sg_ByteVectorS8Set bv index value))

  (define-cgen-stmt bv-check-align
    ((_ name index align)
     (dispatch
      `(unless (== (% ,index ,align) 0)
	 (assertion-violation ',name "index not aligned" 
			      (SG_MAKE_INT ,index))))))

  (define-cgen-stmt bv-check-value
    ((_ name value min max)
     (dispatch
      `(unless (and (<= ,min ,value)
		    (<= ,value ,max))
	 (assertion-violation ',name "value out of range %S"
			      (SG_MAKE_INT ,value))))))
  ;; 2.5 operations on 16-bit integers
  ;; u16
  (define-c-proc bytevector-u16-native-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bytevector-u16-native-ref bv index 1)
    (bv-check-align bytevector-u16-native-ref index 2)
    (result (Sg_ByteVectorU16NativeRef bv index)))

  (define-c-proc bytevector-u16-native-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bytevector-u16-native-set! bv index 1)
    (bv-check-value bytevector-u16-native-set! value 0 #xFFFF)
    (Sg_ByteVectorU16NativeSet bv index value))

  (define-c-proc bytevector-u16-ref (bv::ByteVector index::fixnum endian::Symbol) ::fixnum
    (bv-check-index bytevector-u16-ref bv index 1)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_ByteVectorU16BigRef bv index)))
	  ((SG_EQ endian 'little)
	   (result (Sg_ByteVectorU16LittleRef bv index)))
	  (else
	   (assertion-violation 'bytevector-u16-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u16-set! (bv::ByteVector index::fixnum value::fixnum endian::Symbol) ::void
    (bv-check-index bytevector-u16-set! bv index 1)
    (bv-check-value bytevector-u16-set! value 0 #xFFFF)
    (cond ((SG_EQ endian 'big)
	   (Sg_ByteVectorU16BigSet bv index value))
	  ((SG_EQ endian 'little)
	   (Sg_ByteVectorU16LittleSet bv index value))
	  (else
	   (assertion-violation 'bytevector-u16-set! "unsupported endianness" endian))))

  ;; s16
  (define-c-proc bytevector-s16-native-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bytevector-s16-native-ref bv index 1)
    (bv-check-align bytevector-s16-native-ref index 2)
    (result (Sg_ByteVectorS16NativeRef bv index)))

  (define-c-proc bytevector-s16-native-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bytevector-s16-native-set! bv index 1)
    (bv-check-value bytevector-s16-native-set! value #x-8000 #x7FFF)
    (Sg_ByteVectorS16NativeSet bv index value))

  (define-c-proc bytevector-s16-ref (bv::ByteVector index::fixnum endian::Symbol) ::fixnum
    (bv-check-index bytevector-s16-ref bv index 1)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_ByteVectorS16BigRef bv index)))
	  ((SG_EQ endian 'little)
	   (result (Sg_ByteVectorS16LittleRef bv index)))
	  (else
	   (assertion-violation 'bytevector-s16-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s16-set! (bv::ByteVector index::fixnum value::fixnum endian::Symbol) ::void
    (bv-check-index bytevector-s16-set! bv index 1)
    (bv-check-value bytevector-s16-set! value #x-8000 #x7FFF)
    (cond ((SG_EQ endian 'big)
	   (Sg_ByteVectorS16BigSet bv index value))
	  ((SG_EQ endian 'little)
	   (Sg_ByteVectorS16LittleSet bv index value))
	  (else
	   (assertion-violation 'bytevector-s16-set! "unsupported endianness" endian))))
  ;; 2.6 operations on 32-bit integers
  ;; u32
  (define-c-proc bytevector-u32-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-u32-native-ref bv index 3)
    (bv-check-align bytevector-u32-native-ref index 4)
    (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32NativeRef bv index))))

  (define-c-proc bytevector-u32-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-u32-native-set! bv index 3)
    (let ((value::uint32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u32-native-set! "value out of range" v))
	     (set! value (cast uint32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u32-native-set! "exact integer" v)))
      (Sg_ByteVectorU32NativeSet bv index value)))

  (define-c-proc bytevector-u32-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-u32-ref bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-u32-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u32-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-u32-set! bv index 3)
    (let ((value::uint32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u32-set! "value out of range" v))
	     (set! value (cast uint32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u32-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorU32BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorU32LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-u32-set! "unsupported endianness" endian)))))
  ;; s32
  (define-c-proc bytevector-s32-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-s32-native-ref bv index 3)
    (bv-check-align bytevector-s32-native-ref index 4)
    (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32NativeRef bv index))))

  (define-c-proc bytevector-s32-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-s32-native-set! bv index 3)
    (let ((value::int32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s32-native-set! "value out of range" v))
	     (set! value (cast int32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s32-native-set! "exact integer" v)))
      (Sg_ByteVectorS32NativeSet bv index value)))

  (define-c-proc bytevector-s32-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-s32-ref bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-s32-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s32-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-s32-set! bv index 3)
    (let ((value::int32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s32-set! "value out of range" v))
	     (set! value (cast int32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s32-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorS32BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorS32LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-s32-set! "unsupported endianness" endian)))))
  ;; 2.7 operations on 64-bit integers
  ;; u64
  (define-c-proc bytevector-u64-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-u64-native-ref bv index 7)
    (bv-check-align bytevector-u64-native-ref index 8)
    (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64NativeRef bv index))))

  (define-c-proc bytevector-u64-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-u64-native-set! bv index 7)
    (let ((value::uint64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u64-native-set! "value out of range" v))
	     (set! value (cast uint64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u64-native-set! "exact integer" v)))
      (Sg_ByteVectorU64NativeSet bv index value)))

  (define-c-proc bytevector-u64-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-u64-ref bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-u64-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u64-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-u64-set! bv index 7)
    (let ((value::uint64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u64-set!  "value out of range" v))
	     (set! value (cast uint64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u64-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorU64BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorU64LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-u64-set! "unsupported endianness" endian)))))
  ;; s64
  (define-c-proc bytevector-s64-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-s64-native-ref bv index 7)
    (bv-check-align bytevector-s64-native-ref index 8)
    (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64NativeRef bv index))))

  (define-c-proc bytevector-s64-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-s64-native-set! bv index 7)
    (let ((value::int64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s64-native-set! "value out of range" v))
	     (set! value (cast int64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s64-native-set! "exact integer" v)))
      (Sg_ByteVectorS64NativeSet bv index value)))

  (define-c-proc bytevector-s64-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-s64-ref bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-s64-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s64-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-s64-set! bv index 7)
    (let ((value::int64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s64-set! "value out of range" v))
	     (set! value (cast int64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s64-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorS64BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorS64LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-s64-set! "unsupported endianness" endian)))))
  ;; 2.8 operations on ieee-754 representations
  ;; ieee-single
  (define-c-proc bytevector-ieee-single-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-ieee-single-native-ref bv index 3)
    (bv-check-align bytevector-ieee-single-native-ref index 4)
    (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleNativeRef bv index))))

  (define-c-proc bytevector-ieee-single-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-ieee-single-ref bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleBigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleLittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-ieee-single-ref "unsupported endianness" endian))))
  
  (define-c-proc bytevector-ieee-single-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-ieee-single-native-set! bv index 3)
    (bv-check-align bytevector-ieee-single-native-set! index 4)
    (check-real bytevector-ieee-single-native-set! v)
    (let ((value::double (Sg_GetDouble v)))
      (Sg_ByteVectorIEEESingleNativeSet bv index (cast float value))))

  (define-c-proc bytevector-ieee-single-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-ieee-single-set! bv index 3)
    (check-real bytevector-ieee-single-set! v)
    (let ((value::double (Sg_GetDouble v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorIEEESingleBigSet bv index (cast float value)))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorIEEESingleLittleSet bv index (cast float value)))
	    (else
	     (assertion-violation 'bytevector-ieee-single-set! "unsupported endianness" endian)))))
  ;; ieee-double
  (define-c-proc bytevector-ieee-double-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bytevector-ieee-double-native-ref bv index 7)
    (bv-check-align bytevector-ieee-double-native-ref index 8)
    (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleNativeRef bv index))))

  (define-c-proc bytevector-ieee-double-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bytevector-ieee-double-ref bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleBigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleLittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-ieee-double-ref "unsupported endianness" endian))))
  
  (define-c-proc bytevector-ieee-double-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bytevector-ieee-double-native-set! bv index 7)
    (bv-check-align bytevector-ieee-double-native-set! index 8)
    (check-real bytevector-ieee-double-native-set! v)
    (let ((value::double (Sg_GetDouble v)))
      (Sg_ByteVectorIEEEDoubleNativeSet bv index value)))

  (define-c-proc bytevector-ieee-double-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bytevector-ieee-double-set! bv index 7)
    (check-real bytevector-ieee-double-set! v)
    (let ((value::double (Sg_GetDouble v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorIEEEDoubleBigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorIEEEDoubleLittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-ieee-double-set! "unsupported endianness" endian)))))
  ;; 2.9 operations on strings
  ;; converter
  ;; utf8 <-> string
  (define-c-proc utf8->string (bv::ByteVector) ::Object
    (let ((transcoder (Sg_MakeTranscoder (Sg_MakeUtf8Codec) LF SG_REPLACE_ERROR)))
      (result (Sg_ByteVectorToString bv transcoder 0 -1))))

  (define-c-proc string->utf8 (s::String) ::Object
    (let ((transcoder (Sg_MakeTranscoder (Sg_MakeUtf8Codec) LF SG_REPLACE_ERROR)))
      (result (Sg_StringToByteVector s transcoder 0 -1))))

  ;; utf16 <-> string
  (define-c-proc utf16->string (bv::ByteVector endian::Symbol :optional mandatory) ::Object
    (let ((endianness::Endianness NO_BOM)
	  (skipBOM::int FALSE))
      (when (SG_UNBOUNDP mandatory)
	(set! endianness (Sg_Utf16CheckBOM bv))
	(if (not (== endianness NO_BOM))
	    (set! skipBOM TRUE)))
      (when (or (and (not (SG_UNBOUNDP mandatory))
		     (not (SG_FALSEP mandatory)))
		(== endianness  NO_BOM))
	(cond ((SG_EQ endian 'little)
	       (set! endianness UTF_16LE))
	      ((SG_EQ endian 'big)
	       (set! endianness UTF_16BE))
	      (else
	       (assertion-violation 'utf16->string "endianness should be little or big" endian))))
      (let ((skipSize::int 0)
	    (codec SG_UNDEF)
	    (transcoder SG_UNDEF))
	(if skipBOM
	    (set! skipSize 2))
	(set! codec (Sg_MakeUtf16Codec endianness))
	(set! transcoder (Sg_MakeTranscoder codec LF SG_REPLACE_ERROR))
	;; TODO guard
	(result (Sg_ByteVectorToString bv transcoder skipSize (- (SG_BVECTOR_SIZE bv) skipSize))))))

  (define-c-proc string->utf16 (s::String :optional (endian::Symbol SG_UNBOUND)) ::Object
    (let ((endianness::Endianness UTF_16BE))
      (if (not (SG_UNBOUNDP endian))
	  (cond ((SG_EQ endian 'little)
		 (set! endianness UTF_16LE))
		((SG_EQ endian 'big)
		 (set! endianness UTF_16BE))
		(else
		 (assertion-violation 'string->utf16 "endianness should be little or big"  endian))))
      (result (Sg_StringToByteVector s (Sg_MakeTranscoder (Sg_MakeUtf16Codec endianness)
							  LF
							  SG_REPLACE_ERROR)
				     0 -1))))


  (define-c-proc string->utf32 (s::String :optional (endian::Symbol SG_UNBOUND)) ::Object
    (let ((endianness::Endianness UTF_32BE))
      (if (not (SG_UNBOUNDP endian))
	  (cond ((SG_EQ endian 'little)
		 (set! endianness UTF_32LE))
		((SG_EQ endian 'big)
		 (set! endianness UTF_32BE))
		(else
		 (assertion-violation 'string->utf32 "endianness should be little or big"  endian))))
      (result (Sg_StringToByteVector s (Sg_MakeTranscoder (Sg_MakeUtf32Codec endianness)
							  LF
							  SG_REPLACE_ERROR)
				     0 -1))))

  (define-c-proc utf32->string (bv::ByteVector endian::Symbol :optional mandatory) ::Object
    (let ((endianness::Endianness NO_BOM)
	  (skipBOM::int FALSE))
      (when (SG_UNBOUNDP mandatory)
	(set! endianness (Sg_Utf32CheckBOM bv))
	(if (not (== endianness NO_BOM))
	    (set! skipBOM TRUE)))
      (when (or (and (not (SG_UNBOUNDP mandatory))
		     (not (SG_FALSEP mandatory)))
		(== endianness NO_BOM))
	(cond ((SG_EQ endian 'little)
	       (set! endianness UTF_32LE))
	      ((SG_EQ endian 'big)
	       (set! endianness UTF_32BE))
	      (else
	       (assertion-violation 'utf32->string "endianness should be little or big" endian))))
      (let ((skipSize::int 0)
	    (codec SG_UNDEF)
	    (transcoder SG_UNDEF))
	(if skipBOM
	    (set! skipSize 4))
	(set! codec (Sg_MakeUtf32Codec endianness))
	(set! transcoder (Sg_MakeTranscoder codec LF SG_REPLACE_ERROR))
	;; TODO guard
	(result (Sg_ByteVectorToString bv transcoder skipSize (- (SG_BVECTOR_SIZE bv) skipSize))))))
  
  ;; 3 List utilities
  (define-c-proc memq (arg0 arg1) ::Object
    (result (Sg_Memq arg0 arg1)))

  (define-c-proc memv (arg0 arg1) ::Object
    (result (Sg_Memv arg0 arg1)))

  (define-c-proc assq (obj alist) ::Object
    (unless (SG_LISTP alist)
      (wrong-type-of-argument-violation 'assq
					"list"
					alist
					(SG_LIST2 obj alist)))
    (result (Sg_Assq obj alist)))

  (define-c-proc assv (obj alist) ::Object
    (unless (SG_LISTP alist)
      (wrong-type-of-argument-violation 'assv
					"list"
					alist
					(SG_LIST2 obj alist)))
    (result (Sg_Assv obj alist)))

  (define-c-proc cons* (:rest rest) ::Object
    (let ((h '()) (t '()))
      (when (SG_PAIRP rest)
	(dopairs (cp rest)
	  (unless (SG_PAIRP (SG_CDR cp))
	    (if (SG_NULLP h)
		(set! h (SG_CAR cp))
		(SG_SET_CDR t (SG_CAR cp)))
	    (break))
	  (SG_APPEND1 h t (SG_CAR cp))))
      (result h)))

  ;; 7 Exceptions and conditions
  ;; 7.1 exceptions
  (define-c-proc with-exception-handler (handler thunk) ::Object
    (result (Sg_VMWithExceptionHandler handler thunk)))

  (define-c-proc raise (c) ::Object
    (result (Sg_Raise c FALSE)))

  (define-c-proc raise-continuable (c) ::Object
    (result (Sg_Raise c TRUE)))

  ;; 8 I/O
  ;; 8.2 port i/o
  ;; 8.2.3 buffer modes
  (define-c-proc buffer-mode? (o) ::boolean
    (result (or (SG_EQ o 'none)
		(SG_EQ o 'line)
		(SG_EQ o 'block))))
  
  ;; 8.2.4 transcoders
  (define-c-proc latin-1-codec () ::Object
    (result (Sg_MakeLatin1Codec)))

  (define-c-proc utf-8-codec () ::Object
    (result (Sg_MakeUtf8Codec)))

  (define-c-proc utf-16-codec () ::Object
    (result (Sg_MakeUtf16Codec UTF_16CHECK_BOM)))

  (define-c-proc native-eol-style () ::Object
    (let ((style::EolStyle (Sg_NativeEol)))
      (cond ((== style LF)
	     (result 'lf))
	    ((== style CR)
	     (result 'cr))
	    ((== style LS)
	     (result 'ls))
	    ((== style NEL)
	     (result 'nel))
	    ((== style CRNEL)
	     (result 'crnel))
	    ((== style CRLF)
	     (result 'crlf))
	    ((== style E_NONE)
	     (result 'none))
	    (else
	     ;; all plat form should return eol style by Sg_NativeEol.
	     ;; so this never happen. just dummy
	     (assertion-violation 'native-eol-style
				  "platform native eol style not found"
				  '())))))

  (define-c-proc make-transcoder (c::Codec :optional (eol::Symbol 'lf)
					             (mode::Symbol 'replace))
                                 ::Object
    (let ((style::EolStyle LF)
	  (handling::ErrorHandlingMode SG_REPLACE_ERROR))
      (cond ((SG_EQ eol 'lf)) ;; do nothing
	    ((SG_EQ eol 'cr)
	     (set! style CR))
	    ((SG_EQ eol 'ls)
	     (set! style LS))
	    ((SG_EQ eol 'nel)
	     (set! style NEL))
	    ((SG_EQ eol 'crnel)
	     (set! style CRNEL))
	    ((SG_EQ eol 'crlf)
	     (set! style CRLF))
	    ((SG_EQ eol 'none)
	     (set! style E_NONE))
	    (else
	     (assertion-violation 'make-transcoder
				  "invalid eol-style"
				  eol)))
      (cond ((SG_EQ mode 'replace)) ;; do nothing
	    ((SG_EQ mode 'raise)
	     (set! handling SG_RAISE_ERROR))
	    ((SG_EQ mode 'ignore)
	     (set! handling SG_IGNORE_ERROR))
	    (else
	     (assertion-violation 'make-transcoder
				  "invalid error-handling-mode"
				  mode)))
      (result (Sg_MakeTranscoder c style handling))))

  (define-c-proc native-transcoder () ::Object
    (result (Sg_MakeNativeTranscoder)))

  (define-c-proc transcoder-codec (t::Transcoder) ::Object
    (result (SG_TRANSCODER_CODEC t)))

  (define-c-proc transcoder-eol-style (t::Transcoder) ::Object
    (let ((style::EolStyle (SG_TRANSCODER_EOL_STYLE t)))
      (cond ((== style LF)
	     (result 'lf))
	    ((== style CR)
	     (result 'cr))
	    ((== style LS)
	     (result 'ls))
	    ((== style NEL)
	     (result 'nel))
	    ((== style CRNEL)
	     (result 'crnel))
	    ((== style CRLF)
	     (result 'crlf))
	    ((== style E_NONE)
	     (result 'none))
	    (else
	     ;; never happen
	     (assertion-violation 'transcoder-eol-style
				  "transcoder had unknown eol-style. this must be a bug, please report it"
				  '())))))

  (define-c-proc transcoder-error-handling-mode (t::Transcoder) ::Object
    (let ((mode::ErrorHandlingMode (SG_TRANSCODER_MODE t)))
      (cond ((SG_EQ mode SG_REPLACE_ERROR)
	     (result SG_SYMBOL_REPLACE))
	    ((SG_EQ mode SG_IGNORE_ERROR)
	     (result SG_SYMBOL_IGNORE))
	    ((SG_EQ mode SG_RAISE_ERROR)
	     (result SG_SYMBOL_RAISE))
	    (else
	     (assertion-violation 'transcoder-error-handling-mode
				  "transcoder had unknown error-handling-mode. this must be a bug, please report it"
				  '())))))

  (define-c-proc bytevector->string (b::ByteVector t::Transcoder) ::Object
    (result (Sg_ByteVectorToString b t 0 -1)))

  (define-c-proc string->bytevector (s::String t::Transcoder) ::Object
    (result (Sg_StringToByteVector s t 0 -1)))

  ;; 8.2.5 end-of-file object
  (define-c-proc eof-object () ::Object
    (result SG_EOF))

  (define-c-proc eof-object? (o) ::boolean
    (result (SG_EOFP o)))

  ;; 8.2.6 input port and output port
  ;; check utility for opened port
  (define-cgen-stmt check-port-open
    ((_ name p)
     (dispatch
      `(when (Sg_PortClosedP ,p)
	 (wrong-type-of-argument-violation ',name
					   "opened port"
					   ,p)))))

  (define-cgen-stmt check-binary-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_BINARY_PORTP ,p)
		   (and (SG_CUSTOM_PORTP ,p)
			(SG_EQ (-> (SG_CUSTOM_PORT ,p) type)
			       SG_BINARY_CUSTOM_PORT_TYPE)))
	 (wrong-type-of-argument-violation ',name
					   "binary-port"
					   ,p)))))

  (define-c-proc port? (obj) ::boolean
    (result (SG_PORTP obj)))

  (define-c-proc port-transcoder (p::Port) ::Object
    (cond ((SG_BINARY_PORTP p)
	   (result #f))
	  ((SG_TEXTUAL_PORTP p)
	   (if (== (-> (SG_TEXTUAL_PORT p) type)
		   SG_TRANSCODED_TEXTUAL_PORT_TYPE)
	       (result (SG_TRANSCODED_TEXTUAL_PORT_TRANSCODER p))
	       (result #f)))
	  (else
	   ;; TODO custom port
	   (result #f))))

  (define-c-proc textual-port? (p::Port) ::boolean
    (result (SG_TEXTUAL_PORTP p)))

  (define-c-proc binary-port? (p::Port) ::boolean
    (result (SG_BINARY_PORTP p)))

  (define-c-proc transcoded-port (p::Port t::Transcoder) ::Object
    (check-binary-port transcoded-port p)
    (check-port-open transcoded-port p)
    (Sg_PseudoClosePort p)
    (cond ((SG_EQ (-> p direction) SG_INPUT_PORT)
	   (result (Sg_MakeTranscodedInputPort p t)))
	  ((SG_EQ (-> p direction) SG_OUTPUT_PORT)
	   (result (Sg_MakeTranscodedOutputPort p t)))
	  ((SG_EQ (-> p direction) SG_IN_OUT_PORT)
	   (result (Sg_MakeTranscodedInputOutputPort p t)))
	  (else
	   (assertion-violation 'transcoded-port
				"port had unknown direction. this must be a bug, please report it"
				  '()))))

  (define-c-proc port-has-port-position? (p::Port) ::boolean
    (result (Sg_HasPortPosition p)))

  (define-c-proc port-has-set-port-position!? (p::Port) ::boolean
    (result (Sg_HasSetPortPosition p)))

  (define-c-proc port-position (p::Port) ::Object
    (check-port-open port-position p)
    (result (Sg_MakeIntegerFromS64 (Sg_PortPosition p))))

  (define-c-proc set-port-position! (p::Port off::number) ::void
    (check-port-open set-port-position! p)
    (Sg_SetPortPosition p (Sg_GetIntegerU64Clamp off SG_CLAMP_NONE NULL)))

  (define-c-proc close-port (p::Port) ::void
    (Sg_ClosePort p))

  ;; 8.2.7 input port
  (define-cgen-stmt check-input-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_INPORTP ,p)
		   (SG_INOUTPORTP ,p))
	 (wrong-type-of-argument-violation ',name
					   "input port"
					   ,p)))))

  (define-c-proc input-port? (obj) ::boolean
    (result (or (SG_INPORTP obj)
		(SG_INOUTPORTP obj))))

  (define-c-proc port-eof? (p::Port) ::boolean
    (cond ((SG_BINARY_PORTP p)
	   (let ((ch::int (Sg_Peekb p)))
	     (result (or (== ch EOF)))))
	  ((SG_TEXTUAL_PORTP p)
	   (let ((ch::SgChar (Sg_Peekc p)))
	     (result (or (== ch EOF)))))
	  (else
	   ;; TODO custom port
	   (assertion-violation 'port-eof
				"custom port is not supported yet"
				p))))

  (define-c-proc open-file-input-port (file::String 
				       :optional option
				                 (mode::Symbol 'block)
				                 (transcoder::Transcoder #f))
                                       ::Object
    ;; we can ignore option
    (let ((fo (Sg_OpenFile file SG_READ))
	  (bufferMode::int SG_BUFMODE_BLOCK))
      (unless (SG_FILEP fo)
	(throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
			 'open-file-input-port "file not exist" file))
      ;; we only support 'block or none for now.
      (if (SG_EQ mode 'none)
	  (set! bufferMode SG_BUFMODE_NONE))
      (if (SG_FALSEP transcoder)
	  (result (Sg_MakeFileBinaryInputPort fo bufferMode))
	  (let ((in (Sg_MakeFileBinaryInputPort fo bufferMode)))
	    (result (Sg_MakeTranscodedInputPort in transcoder))))))

  (define-c-proc open-bytevector-input-port
    (bv::ByteVector :optional (t::Transcoder #f)) ::Object
    (let ((bp (Sg_MakeByteVectorInputPort bv 0)))
      (if (SG_FALSEP t)
	  (result bp)
	  (result (Sg_MakeTranscodedInputPort bp t)))))

  (define-c-proc open-string-input-port (s::String) ::Object
    (result (Sg_MakeStringInputPort s FALSE)))

  (define-c-proc standard-input-port () ::Object
    (result (Sg_StandardInputPort)))

  (define-c-proc current-input-port (:optional (p::Port SG_UNBOUND)) ::Object
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP p)
	  (result (-> vm currentInputPort))
	  (begin
	    (check-input-port current-input-port p)
	    (set! (-> vm currentInputPort) p)
	    (result SG_UNDEF)))))
  
  (define-cgen-stmt check-procedure-or-false
    ((_ name proc)
     (dispatch
      `(unless (or (SG_FALSEP ,proc)
		   (SG_PROCEDUREP ,proc))
	 (wrong-type-of-argument-violation ',name
					   "procedure or #f"
					   ,proc)))))

  (define-c-proc make-custom-binary-input-port
    (id::String read::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-binary-input-port getter)
    (check-procedure-or-false make-custom-binary-input-port setter)
    (check-procedure-or-false make-custom-binary-input-port close)
    (result (Sg_MakeCustomBinaryPort id SG_INPUT_PORT read #f
				     getter setter close)))

  (define-c-proc make-custom-textual-input-port
    (id::String read::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-textual-input-port getter)
    (check-procedure-or-false make-custom-textual-input-port setter)
    (check-procedure-or-false make-custom-textual-input-port close)
    (result (Sg_MakeCustomTextualPort id SG_INPUT_PORT read #f
				      getter setter close)))

  ;; 8.2.8 binary input
  (decl-code
   (.include <string.h>))

  (define-c-proc get-u8 (p::Port) ::Object
    (check-port-open get-u8 p)
    (check-binary-port get-u8 p)
    (check-input-port get-u8 p)
    (let ((b::int (Sg_Getb p)))
      (if (== EOF b)
	  (result SG_EOF)
	  (result (SG_MAKE_INT b)))))
  
  (define-c-proc lookahead-u8 (p::Port) ::Object
    (check-port-open lookahead-u8 p)
    (check-binary-port lookahead-u8 p)
    (check-input-port lookahead-u8 p)
    (let ((b::int (Sg_Peekb p)))
      (if (== EOF b)
	  (result SG_EOF)
	  (result (SG_MAKE_INT b)))))

  (define-cgen-stmt check-non-negative-fixnum
    ((_ name n)
     (dispatch
      `(when (< ,n 0)
	 (wrong-type-of-argument-violation 'name
					   "non negative exact integer"
					   (SG_MAKE_INT ,n))))))

  (define-cgen-stmt check-fixnum-range
    ((_ name t start end start-op end-op)
     (dispatch
      `(unless (and (,start-op ,start ,t)
		    (,end-op ,t ,end))
	 (assertion-violation ',name
			      "out of range"
			      (SG_MAKE_INT ,t)))))
    ((_ name t range op)
     (dispatch
      `(unless (,op ,t ,range)
	 (assertion-violation ',name
			      "out of range"
			      (SG_MAKE_INT ,t))))))

  (define-c-proc get-bytevector-n (p::Port count::fixnum :optional (reckless #f)) ::Object
    (check-port-open get-bytevector-n p)
    (when (SG_FALSEP reckless)
      (check-binary-port get-bytevector-n p))
    (check-input-port get-bytevector-n p)
    (check-non-negative-fixnum get-bytevector-n count)
    (let ((buf::uint8_t* (SG_NEW_ATOMIC2 uint8_t* count))
	  (res::int64_t (Sg_Readb p buf count)))
      (if (== res 0)
	  (result SG_EOF)
	  (result (Sg_MakeByteVectorFromU8Array buf res)))))

  (define-c-proc get-bytevector-n!
    (p::Port bv::ByteVector start::fixnum count::fixnum :optional (reckless #f)) ::Object
    (check-port-open get-bytevector-n! p)
    (when (SG_FALSEP reckless)
      (check-binary-port get-bytevector-n p))
    (check-input-port get-bytevector-n! p)
    (check-non-negative-fixnum get-bytevector-n! start)
    (check-non-negative-fixnum get-bytevector-n! count)
    (check-fixnum-range get-bytevector-n! (SG_BVECTOR_SIZE bv)
			(+ start count) >)
    (let ((buf::uint8_t* (SG_NEW_ATOMIC2 uint8_t* count))
	  (res::int64_t (Sg_Readb p buf count)))
      (cond ((== res 0)
	     (result SG_EOF))
	    (else
	     (memcpy (+ (SG_BVECTOR_ELEMENTS bv) start)
		     buf res)
	     (result (SG_MAKE_INT res))))))

  ;; TODO this allocates memory twice.
  (define-c-proc get-bytevector-some (p::Port :optional (reckless #f)) ::Object
    (check-port-open get-bytevector-some p)
    (when (SG_FALSEP reckless)
      (check-binary-port get-bytevector-n p))
    (check-input-port get-bytevector-some p)
    (let ((buf::uint8_t* (SG_NEW_ATOMIC2 uint8_t* 512)) ;; some
	  (res::int64_t (Sg_Readb p buf 512)))
      (if (== res 0)
	  (result SG_EOF)
	  (result (Sg_MakeByteVectorFromU8Array buf res)))))

  (define-c-proc get-bytevector-all (p::Port :optional (reckless #f)) ::Object
    (check-port-open get-bytevector-all p)
    (when (SG_FALSEP reckless)
      (check-binary-port get-bytevector-n p))
    (check-input-port get-bytevector-all p)
    ;; TODO we need to get the rest size to reduce memory allocation.
    ;; but for now I implement like this
    (let ((buf::uint8_t* NULL)
	  (res::int64_t (Sg_ReadbAll p &buf)))
      (if (== res 0)
	  (result SG_EOF)
	  (result (Sg_MakeByteVectorFromU8Array buf res)))))

  ;; 8.2.9 textual port
  (define-cgen-stmt check-textual-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_TEXTUAL_PORTP ,p)
		   (and (SG_CUSTOM_PORTP ,p)
			(SG_EQ (-> (SG_CUSTOM_PORT ,p) type)
			       SG_TEXTUAL_CUSTOM_PORT_TYPE)))
	 (wrong-type-of-argument-violation ',name
					   "textual-port"
					   ,p)))))

  (define-c-proc get-char (p::Port) ::Object
    (check-port-open get-char p)
    (check-textual-port get-char p)
    (check-input-port get-char p)
    (let ((c::SgChar (Sg_Getc p)))
      (if (== c EOF)
	  (result SG_EOF)
	  (result (SG_MAKE_CHAR c)))))

  (define-c-proc lookahead-char (p::Port) ::Object
    (check-port-open lookahead-char p)
    (check-textual-port lookahead-char p)
    (check-input-port lookahead-char p)
    (let ((c::SgChar (Sg_Peekc p)))
      (if (== c EOF)
	  (result SG_EOF)
	  (result (SG_MAKE_CHAR c)))))

  ;; TODO this implementation might waste some memory
  ;; when the port doesn't have enough character
  (define-c-proc get-string-n (p::Port count::fixnum) ::Object
    (check-port-open get-string-n p)
    (check-textual-port get-string-n p)
    (check-input-port get-string-n p)
    (check-non-negative-fixnum get-string-n count)
    (let ((ch::SgChar (Sg_Peekc p)))
      (cond ((== ch EOF)
	     (result SG_EOF))
	    (else
	     ;; TODO it's not *RIGHT* implementation
	     ;; we should use string-output-port as buffer
	     ;; but this is match faster (i guess...)
	     (let ((buf::SgChar* (SG_NEW_ATOMIC2 SgChar* (* (sizeof SgChar) (+ count 1))))
		   (i::int 0)
		   (ret (Sg_MakeEmptyString)))
	       (loop 
		(cond ((or (== i count)
			   (== EOF (Sg_Peekc p)))
		       (break))
		      (else
		       (set! (arrayref buf i) (Sg_Getc p))
		       (post++ i))))
	       (set! (arrayref buf count) 0)
	       (set! (SG_STRING_SIZE ret) i)
	       (set! (SG_STRING_VALUE ret) buf)
	       (result ret))))))

  (define-c-proc get-string-n! (p::Port s::String start::fixnum count::fixnum) ::Object
    (check-port-open get-string-n! p)
    (check-textual-port get-string-n! p)
    (check-input-port get-string-n! p)
    (check-non-negative-fixnum get-string-n! start)
    (check-non-negative-fixnum get-string-n! count)
    (check-fixnum-range get-string-n! (SG_STRING_SIZE s)
			(+ start count) >=)
    ;; string must not be literal
    (when (SG_LITERAL_STRINGP s)
      (assertion-violation 'get-string-n!
			   "attempt to modify a literal string"
			   s))
    (let ((ch::SgChar (Sg_Peekc p)))
      (cond ((== ch EOF)
	     (result SG_EOF))
	    (else
	     (let ((buf::SgChar* (SG_STRING_VALUE s))
		   (i::int start))
	       (loop 
		(cond ((or (== i count)
			   (== EOF (Sg_Peekc p)))
		       (break))
		      (else
		       (set! (arrayref buf i) (Sg_Getc p))
		       (post++ i))))
	       (result (SG_MAKE_INT (- i start))))))))

  (define-c-proc get-string-all (p::Port) ::Object
    (check-port-open get-string-all p)
    (check-textual-port get-string-all p)
    (check-input-port get-string-all p)
    (let ((ch::SgChar (Sg_Peekc p)))
      (cond ((== ch EOF)
	     (result SG_EOF))
	    (else
	     ;; TODO how much should we allocate as default size?
	     (let ((buf (Sg_MakeStringOutputPort 512)))
	       (loop
		(let ((c::SgChar (Sg_Getc p)))
		  (cond ((== c EOF)
			 (break))
			(else
			 (Sg_PutcUnsafe buf c)))))
	       (result (Sg_GetStringFromStringPort buf)))))))

  (define-c-proc get-line (p::Port) ::Object
    (check-port-open get-line p)
    (check-textual-port get-line p)
    (check-input-port get-line p)
    (let ((ch::SgChar (Sg_Peekc p)))
      (cond ((== ch EOF)
	     (result SG_EOF))
	    (else
	     ;; TODO how much should we allocate as default size?
	     (let ((buf (Sg_MakeStringOutputPort 512)))
	       (loop
		(let ((c::SgChar (Sg_Getc p)))
		  ;; transcoder return LF as eol.
		  ;; TODO string-port doesn't have any indication for eol
		  (cond ((or (== c LF)
			     (== c EOF))
			 (break))
			(else
			 (Sg_PutcUnsafe buf c)))))
	       (result (Sg_GetStringFromStringPort buf)))))))

  (define-c-proc get-datum (p::Port) ::Object
    (check-port-open get-dutum p)
    (check-textual-port get-datum p)
    (check-input-port get-dutum p)
    ;; TODO should get-datum read shared-object too?
    (result (Sg_Read p FALSE)))

  ;; 8.2.10 output port
  (define-cgen-stmt check-output-port
    ((_ name p)
     (dispatch
      `(unless (or (SG_OUTPORTP ,p)
		   (SG_INOUTPORTP ,p))
	 (wrong-type-of-argument-violation ',name
					   "output port"
					   ,p)))))

  (define-c-proc output-port? (obj) ::boolean
    (result (or (SG_OUTPORTP obj)
		(SG_INOUTPORTP obj))))

  (define-c-proc flush-output-port (p::Port) ::void
    (Sg_FlushPort p))

  (define-c-proc output-port-buffer-mode (p::Port) ::Object
    (cond ((SG_EQ (-> p bufferMode) SG_BUFMODE_NONE)
	   (result 'none))
	  ((SG_EQ (-> p bufferMode) SG_BUFMODE_LINE)
	   (result 'line))
	  ((SG_EQ (-> p bufferMode) SG_BUFMODE_BLOCK)
	   (result 'block))
	  (else
	   (assertion-violation 'output-port-buffer-mode
				"port has invalid buffer mode. may be bug?"
				p))))

  (define-cgen-stmt logor
    ((_ v1 v2 . more)
     (begin
       ((renderer) (format "~a | ~a" v1 v2))
       (if (null? more)
	   #t
	   (let loop ((more more))
	     (unless (null? more)
	       ((renderer) (format " | ~a" (car more)))
	       (loop (cdr more))))))))

  (define-c-proc open-file-output-port (file::String 
					:optional (option #f)
					          (mode::Symbol 'block)
						  (transcoder::Transcoder #f))
                                       ::Object
    (let ((fo SG_UNDEF)
	  (isFileExist::int (Sg_FileExistP file))
	  (openFlags::int (logor SG_WRITE SG_CREATE))
	  (bufferMode::int SG_BUFMODE_BLOCK))
      (cond ((SG_EQ mode 'none)
	     (set! bufferMode SG_BUFMODE_NONE))
	    ((SG_EQ mode 'line)
	     (set! bufferMode SG_BUFMODE_LINE)))
      (cond ((SG_FALSEP option)
	     (if isFileExist
		 (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
				  'open-file-output-port "file already exists" file))
	     (set! fo (Sg_OpenFile file openFlags))
	     (unless (SG_FILEP fo)
	       (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
				'open-file-output-port
				"file not exist" file))
	     (result (Sg_MakeFileBinaryOutputPort fo bufferMode)))
	    (else
	     (unless (SG_INSTANCEP option)
	       (assertion-violation 'open-file-output-port "invalid file options" option))
	     (let ((isEmpty::int (SG_NULLP (Sg_GenericRef option 'members)))
		   (noCreate (Sg_Memq 'no-create (Sg_GenericRef option 'members)))
		   (noTruncate (Sg_Memq 'no-truncate (Sg_GenericRef option 'members)))
		   (noFail (Sg_Memq 'no-fail (Sg_GenericRef option 'members))))
	       (cond ((and isFileExist isEmpty)
		      (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
				       'open-file-output-port "file already exists" file))
		     ((and (not (SG_FALSEP noCreate))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
					   'open-file-output-port
					   "file-options no-create: file not exist" file)))
		     ((not (SG_FALSEP noCreate))
		      (if isFileExist
			  (set! openFlags (logor SG_TRUNCATE openFlags))
			  (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
					   'open-file-output-port "file-options no-create: file not exist" file)))
		     ((and (not (SG_FALSEP noFail))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (set! openFlags (logor SG_TRUNCATE openFlags))))
		     ((not (SG_FALSEP noFail))
		      (set! openFlags (logor SG_TRUNCATE openFlags)))
		     ((not (SG_FALSEP noTruncate))
		      (if isFileExist
			  (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
					   'open-file-output-port "file-options no-truncate: file already exist" file)
			  (set! openFlags (logor SG_TRUNCATE openFlags)))))
	       (set! fo (Sg_OpenFile file openFlags))
	       (unless (SG_FILEP fo)
		 (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
				  'open-file-output-port "file not exist" file))
	       (if (SG_FALSEP transcoder)
		   (result (Sg_MakeFileBinaryOutputPort fo bufferMode))
		   (let ((out (Sg_MakeFileBinaryOutputPort fo bufferMode)))
		     (result (Sg_MakeTranscodedOutputPort out transcoder)))))))))

  (define-c-proc open-output-bytevector (:optional t) ::Object
    ;; TODO how much should I reserve for intial buffer?
    ;; for now use default.
    (let ((bp (Sg_MakeByteArrayOutputPort -1)))
      (if (or (SG_UNBOUNDP t) (SG_FALSEP t))
	  (result bp)
	  (result (Sg_MakeTranscodedOutputPort bp t)))))

  (define-c-proc get-output-bytevector (p::Port) ::Object
    (check-port-open get-output-bytevector p)
    (check-output-port get-output-bytevector p)
    ;; I'm not quite sure if I should reset the port position
    ;; if it's textual port.
    (cond ((SG_BINARY_PORTP p)
	   (result (Sg_GetByteVectorFromBinaryPort p))
	   (Sg_SetPortPosition p 0))
	  (else
	   (result (Sg_GetByteVectorFromBinaryPort 
		    (-> (SG_TEXTUAL_PORT p) src.transcoded.port)))
	   (Sg_SetPortPosition (-> (SG_TEXTUAL_PORT p) src.transcoded.port)  0)
	   ;; we also need to reset transcoder's buffer position,
	   ;; but we don't reset buffer.
	   (set! (-> (SG_TRANSCODED_TEXTUAL_PORT_TRANSCODER p)
		     bufferPosition) 0))))
	  
  
  ;; these functions are for open-string-output-port
  (define-c-proc open-output-string () ::Object
    (result (Sg_MakeStringOutputPort 32)))

  (define-c-proc get-output-string (p::Port) ::Object
    (check-port-open get-output-string p)
    (check-output-port get-output-string p)
    (check-textual-port get-output-string p)
    (unless (SG_EQ (-> (SG_TEXTUAL_PORT p) type)
		   SG_STRING_TEXTUAL_PORT_TYPE)
      (wrong-type-of-argument-violation 'get-output-string
					"string port"
					p))
    (result (Sg_GetStringFromStringPort p))
    (Sg_SetPortPosition p 0))

  (define-c-proc standard-output-port () ::Object
    (result (Sg_StandardOutputPort)))

  (define-c-proc standard-error-port () ::Object
    (result (Sg_StandardErrorPort)))

  (define-c-proc current-output-port (:optional (p::Port SG_UNBOUND)) ::Object
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP p)
	  (result (-> vm currentOutputPort))
	  (begin
	    (check-output-port current-output-port p)
	    (set! (-> vm currentOutputPort) p)
	    (result SG_UNDEF)))))

  (define-c-proc current-error-port (:optional (p::Port SG_UNBOUND)) ::Object
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP p)
	  (result (-> vm currentErrorPort))
	  (begin
	    (check-output-port current-error-port p)
	    (set! (-> vm currentErrorPort) p)
	    (result SG_UNDEF)))))

  (define-c-proc make-custom-binary-output-port
    (id::String write::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-binary-output-port getter)
    (check-procedure-or-false make-custom-binary-output-port setter)
    (check-procedure-or-false make-custom-binary-output-port close)
    (result (Sg_MakeCustomBinaryPort id SG_OUTPUT_PORT #f write
				     getter setter close)))

  (define-c-proc make-custom-textual-output-port
    (id::String write::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-textual-output-port getter)
    (check-procedure-or-false make-custom-textual-output-port setter)
    (check-procedure-or-false make-custom-textual-output-port close)
    (result (Sg_MakeCustomTextualPort id SG_OUTPUT_PORT #f write
				      getter setter close)))

  ;; 8.2.11 binary output
  (define-c-proc put-u8 (p::Port octet::fixnum) ::void
    (check-port-open put-u8 p)
    (check-binary-port put-u8 p)
    (check-output-port put-u8 p)
    (check-fixnum-range put-u8 octet 0 255 <= <=)
    (Sg_Putb p octet))

  (define-c-proc put-bytevector
    (p::Port bv::ByteVector
     :optional (start::fixnum 0)
               (count::fixnum (- (SG_BVECTOR_SIZE bv)
				 start)))
    ::void
    (check-port-open put-bytevector p)
    (check-binary-port put-bytevector p)
    (check-output-port put-bytevector p)
    (check-non-negative-fixnum put-bytevector start)
    (check-non-negative-fixnum put-bytevector count)
    (unless (and (< start (SG_BVECTOR_SIZE bv))
		 (<= count (- (SG_BVECTOR_SIZE bv) start)))
      (assertion-violation 'put-bytevector
			   "invalid range"))
    (Sg_Writeb p (SG_BVECTOR_ELEMENTS bv) start count))

  ;; 8.2.13 textual output
  (define-c-proc put-char (p::Port ch) ::void
    (check-port-open put-char p)
    (check-output-port put-char p)
    (check-textual-port put-char p)
    (check-char put-char ch)
    (Sg_Putc p (SG_CHAR_VALUE ch)))

  (define-c-proc put-string
    (p::Port s::String
     :optional (start::fixnum 0)
               (count::fixnum (- (SG_STRING_SIZE s)
				 start)))
    ::void
    (check-port-open put-string p)
    (check-output-port put-string p)
    (check-textual-port put-string p)
    (check-non-negative-fixnum put-string start)
    (check-non-negative-fixnum put-string count)
    (unless (and (< start (SG_STRING_SIZE s))
		 (<= count (- (SG_STRING_SIZE s) start)))
      (assertion-violation 'put-string
			   "invalid range"))
    ;; TODO not so pretty
    (SG_PORT_LOCK p)
    (let ((i::int start))
      (loop
       (cond ((== i (+ count start))
	      (break))
	     (else
	      (Sg_PutcUnsafe p (SG_STRING_VALUE_AT s i))
	      (post++ i))))
      (SG_PORT_UNLOCK p)))

  (define-c-proc put-datum (p::Port datum) ::void
    (check-port-open put-datum p)
    (check-output-port put-datum p)
    (check-textual-port put-datum p)
    (Sg_Write datum p SG_WRITE_WRITE))

  ;; 8.2.13 input output ports
  (define-c-proc open-file-input/output-port (file::String 
					      :optional (option #f)
					                (mode::Symbol 'block)
							(transcoder::Transcoder #f))
					     ::Object
    (let ((fo SG_UNDEF)
	  (isFileExist::int (Sg_FileExistP file))
	  (openFlags::int (logor SG_READ SG_WRITE SG_CREATE))
	  (bufferMode::int SG_BUFMODE_BLOCK))
      (cond ((SG_EQ mode 'none)
	     (set! bufferMode SG_BUFMODE_NONE))
	    ((SG_EQ mode 'line)
	     (set! bufferMode SG_BUFMODE_LINE)))
      (cond ((SG_FALSEP option)
	     (if isFileExist
		 (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
				  'open-file-input/output-port
				  "file already exists" file))
	     (set! fo (Sg_OpenFile file openFlags))
	     (unless (SG_FILEP fo)
	       (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
				'open-file-input/output-port "file not exist" file))
	     (result (Sg_MakeFileBinaryInputOutputPort fo bufferMode)))
	    (else
	     (unless (SG_INSTANCEP option)
	       (assertion-violation 'open-file-output-port "invalid file options" option))
	     (let ((isEmpty::int (SG_NULLP (Sg_GenericRef option 'members)))
		   (noCreate (Sg_Memq 'no-create (Sg_GenericRef option 'members)))
		   (noTruncate (Sg_Memq 'no-truncate (Sg_GenericRef option 'members)))
		   (noFail (Sg_Memq 'no-fail (Sg_GenericRef option 'members))))
	       (cond ((and isFileExist isEmpty)
		      (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
				       'open-file-input/output-port
				       "file already exists" file))
		     ((and (not (SG_FALSEP noCreate))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
					   'open-file-input/output-port "file-options no-create: file not exist" file)))
		     ((not (SG_FALSEP noCreate))
		      (if isFileExist
			  (set! openFlags (logor SG_TRUNCATE openFlags))
			  (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
					   'open-file-input/output-port "file-options no-create: file not exist" file)))
		     ((and (not (SG_FALSEP noFail))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (set! openFlags (logor SG_TRUNCATE openFlags))))
		     ((not (SG_FALSEP noFail))
		      (set! openFlags (logor SG_TRUNCATE openFlags)))
		     ((not (SG_FALSEP noTruncate))
		      (if isFileExist
			  (throw-i/o-error SG_IO_FILE_ALREADY_EXIST_ERROR
					   'open-file-input/output-port "file-options no-truncate: file already exist" file)
			  (set! openFlags (logor SG_TRUNCATE openFlags)))))
	       (set! fo (Sg_OpenFile file openFlags))
	       (unless (SG_FILEP fo)
		 (throw-i/o-error SG_IO_FILE_NOT_EXIST_ERROR
				  'open-file-input/output-port "file not exist" file))
	       (if (SG_FALSEP transcoder)
		   (result (Sg_MakeFileBinaryInputOutputPort fo bufferMode))
		   (let ((out (Sg_MakeFileBinaryInputOutputPort fo bufferMode)))
		     (result (Sg_MakeTranscodedInputOutputPort out transcoder)))))))))

  (define-c-proc make-custom-binary-input/output-port
    (id::String read::Procedure write::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-binary-input/output-port getter)
    (check-procedure-or-false make-custom-binary-input/output-port setter)
    (check-procedure-or-false make-custom-binary-input/output-port close)
    (result (Sg_MakeCustomBinaryPort id SG_IN_OUT_PORT read write
				     getter setter close)))

  (define-c-proc make-custom-textual-input/output-port
    (id::String read::Procedure write::Procedure getter setter close) ::Object
    (check-procedure-or-false make-custom-textual-input/output-port getter)
    (check-procedure-or-false make-custom-textual-input/output-port setter)
    (check-procedure-or-false make-custom-textual-input/output-port close)
    (result (Sg_MakeCustomTextualPort id SG_IN_OUT_PORT read write
				      getter setter close)))

  ;; 8.3 simple i/o
  (define-c-proc close-input-port (p::Port) ::void
    (if (not (SG_INPORTP p))
	(wrong-type-of-argument-violation 'close-input-port "input port" p))
    (Sg_ClosePort p))

  (define-c-proc close-output-port (p::Port) ::void
    (if (not (SG_OUTPORTP p))
	(wrong-type-of-argument-violation 'close-output-port "output port" p))
    (Sg_ClosePort p))

  (define-c-proc read-char (:optional (p::Port (Sg_CurrentInputPort))) ::Object
    (check-input-port read-char p)
    (let ((c::SgChar (Sg_Getc p)))
      (if (== c EOF)
	  (result SG_EOF)
	  (result (SG_MAKE_CHAR c)))))

  (define-c-proc peek-char (:optional (p::Port (Sg_CurrentInputPort))) ::Object
    (check-input-port peek-char p)
    (let ((c::SgChar (Sg_Peekc p)))
      (if (== c EOF)
	  (result SG_EOF)
	  (result (SG_MAKE_CHAR c)))))

  (define-c-proc read (:optional (p::Port (Sg_CurrentInputPort))) ::Object
    (check-input-port read p)
    (result (Sg_Read p FALSE)))

  (define-c-proc write-char (ch :optional (p::Port (Sg_CurrentOutputPort))) :void
    (check-char write-char ch)
    (check-output-port write-char p)
    (Sg_Putc p (SG_CHAR_VALUE ch)))
  
  (define-c-proc newline (:optional (p::Port (Sg_CurrentOutputPort))) ::void
    (check-port-open newline p)
    (check-output-port newline p)
    (Sg_Putc p #\linefeed))

  (define-c-proc display (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (check-port-open display p)
    (check-output-port display p)
    (Sg_Write o p SG_WRITE_DISPLAY))

  (define-c-proc write (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (check-port-open write p)
    (check-output-port write p)
    (Sg_Write o p SG_WRITE_WRITE))

  ;; 9 file system
  (define-c-proc file-exists? (filename::String) ::boolean
    (result (Sg_FileExistP filename)))

  (define-c-proc delete-file (filename::String) ::void
    (Sg_DeleteFile filename))

  ;; 10 Command-line access and exit values
  (define-c-proc command-line () ::Object
    (result (-> (Sg_VM) commandLineArgs)))

  (define-c-proc exit (:optional obj) ::void
    ;; TODO thread
    (if (SG_UNBOUNDP obj)
	(Sg_Exit EXIT_SUCCESS)
	(cond ((SG_INTP obj)
	       (Sg_Exit (SG_INT_VALUE obj)))
	      ((SG_FALSEP obj)
	       (Sg_Exit EXIT_FAILURE))
	      (else
	       (Sg_Exit EXIT_FAILURE)))))

  ;; 11 Arithmetic
  ;; 11.2 fixnum
  (define-c-proc fixnum? (o) ::boolean
    (result (SG_INTP o)))

  (define-c-proc fixnum-width () ::fixnum
    (result (+ SG_INT_SIZE 1)))

  (define-c-proc least-fixnum () ::fixnum
    (result SG_INT_MIN))

  (define-c-proc greatest-fixnum () ::fixnum
    (result SG_INT_MAX))

  (define-cgen-stmt check-fixnum
    ((_ name value)
     (dispatch
      `(unless (SG_INTP ,value)
	 (wrong-type-of-argument-violation ',name
					   "fixnum"
					   ,value)))))

  (define-cgen-stmt fixnum-compare
    ((_ name compare first second rest)
     (dispatch
      `(begin
	 (unless (,compare ,first ,second)
	   (return #f))
	 (let ((prev::int ,second)
	       (target::int 0))
	   (dolist (v ,rest)
	     (check-fixnum ,name v)
	     (set! target (SG_INT_VALUE v))
	     (unless (,compare prev target)
	       (return #f))
	     (set! prev target))
	   (result TRUE))))))

  (define-c-proc fx=? (fx1::fixnum fx2::fixnum :rest rest) ::boolean
    (fixnum-compare fx=? == fx1 fx2 rest))

  (define-c-proc fx<? (fx1::fixnum fx2::fixnum :rest rest) ::boolean
    (fixnum-compare fx<? < fx1 fx2 rest))

  (define-c-proc fx>? (fx1::fixnum fx2::fixnum :rest rest) ::boolean
    (fixnum-compare fx>? > fx1 fx2 rest))

  (define-c-proc fx<=? (fx1::fixnum fx2::fixnum :rest rest) ::boolean
    (fixnum-compare fx<=? <= fx1 fx2 rest))

  (define-c-proc fx>=? (fx1::fixnum fx2::fixnum :rest rest) ::boolean
    (fixnum-compare fx>=? >= fx1 fx2 rest))

  (define-c-proc fxzero? (fx::fixnum) ::boolean
    (result (SG_EQ fx 0)))

  (define-c-proc fxpositive? (fx::fixnum) ::boolean
    (result (> fx  0)))

  (define-c-proc fxnegative? (fx::fixnum) ::boolean
    (result (< fx 0)))

  (define-c-proc fxodd? (fx::fixnum) ::boolean
    (result (== (fxlogand fx 1) 1)))

  (define-c-proc fxeven? (fx::fixnum) ::boolean
    (result (== (fxlogand fx 1) 0)))

  (define-c-proc fxmax (fx::fixnum :rest rest) ::fixnum
    (let ((r::int fx))
      (dolist (v rest)
	(check-fixnum fxmac v)
	(if (> (SG_INT_VALUE v) r)
	    (set! r (SG_INT_VALUE v))))
      (result r)))

  (define-c-proc fxmin (fx::fixnum :rest rest) ::fixnum
    (let ((r::int fx))
      (dolist (v rest)
	(check-fixnum fxmac v)
	(if (< (SG_INT_VALUE v) r)
	    (set! r (SG_INT_VALUE v))))
      (result r)))

  (define-cgen-stmt fixnum-fits?
    ((_ fx)
     (dispatch
      `(and (<= SG_INT_MIN ,fx)
	    (<= ,fx SG_INT_MAX)))))

  (define-c-proc fx+ (fx1::fixnum fx2::fixnum) ::fixnum
    (let ((ret::int (+ fx1 fx2)))
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fx+
	   "sum is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))

  (define-c-proc fx* (fx1::fixnum fx2::fixnum) ::fixnum
    (let ((ret::int64_t (* fx1 fx2)))
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fx*
	   "product is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))

  (define-c-proc fx- (fx1::fixnum :optional o) ::fixnum
    (if (SG_UNBOUNDP o)
	(if (== fx1 SG_INT_MIN)
	    (implementation-restriction-violation
	     'fx-
	     "result is not a fixnum"
	     (SG_MAKE_INT fx1))
	    (result (- 0 fx1)))
	(begin
	  (check-fixnum fx- o)
	  (let ((fx2::int (SG_INT_VALUE o))
		(ret::int (- fx1 fx2)))
	    (if (fixnum-fits? ret)
		(result ret)
		(implementation-restriction-violation
		 'fx-
		 "difference is not a fixnum"
		 (SG_LIST2 (SG_MAKE_INT fx1)
			   (SG_MAKE_INT fx2))))))))
  
  (define-cgen-stmt fixnum-div
    ((_ ret x y)
     (dispatch
      `(cond ((== ,x 0)
	      (set! ,ret 0))
	     ((> ,x 0)
	      (set! ,ret (/ ,x ,y)))
	     ((> ,y 0)
	      (set! ,ret (/ (+ (- ,x ,y) 1) ,y)))
	     (else
	      (set! ,ret (/ (+ ,x ,y 1) ,y)))))))

  (define-cgen-stmt fixnum-mod
    ((_ ret x y)
     (dispatch
      `(begin
	 (fixnum-div ,ret ,x ,y)
	 (set! ,ret (- ,x (* ,ret ,y)))))))

  (define-c-proc fxdiv (fx1::fixnum fx2::fixnum) ::fixnum
    (if (== fx2 0)
	(assertion-violation 'fxdiv
			     "dividing by zero"))
    (let ((ret::int 0))
      (fixnum-div ret fx1 fx2)
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fxdiv
	   "result is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))

  (define-c-proc fxmod (fx1::fixnum fx2::fixnum) ::fixnum
    (if (== fx2 0)
	(assertion-violation 'fxmod
			     "dividing by zero"))
    (let ((ret::int 0))
      (fixnum-mod ret fx1 fx2)
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fxmod
	   "result is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))
  
  (define-cgen-stmt fixnum-div0
    ((_ ret x y)
     (let ((d (gen-temporary))
	   (m (gen-temporary)))
       (dispatch
	`(let ((,(string->symbol (format "~a::int" d)) 0)
	       (,(string->symbol (format "~a::int" m)) 0))
	   (fixnum-div ,d ,x ,y)
	   (fixnum-mod ,m ,x ,y)
	   (cond ((<= ,m (/ (abs ,y) 2))
		  (set! ,ret ,d))
		 ((> ,y 0)
		  (set! ,ret (+ ,d 1)))
		 (else
		  (set! ,ret (- ,d 1)))))))))

  (define-cgen-stmt fixnum-mod0
    ((_ ret x y)
     (let ((tmp (gen-temporary)))
       (dispatch
	`(let ((,(string->symbol (format "~a::int" tmp)) 0))
	   (fixnum-div0 ,tmp ,x ,y)
	   (set! ,ret (- ,x (* ,y ,tmp))))))))
    
  (define-c-proc fxdiv0 (fx1::fixnum fx2::fixnum) ::fixnum
    (if (== fx2 0)
	(assertion-violation 'fxdiv0
			     "dividing by zero"))
    (let ((ret::int 0))
      (fixnum-div0 ret fx1 fx2)
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fxdiv0
	   "result is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))

  (define-c-proc fxmod0 (fx1::fixnum fx2::fixnum) ::fixnum
    (if (== fx2 0)
	(assertion-violation 'fxmod0
			     "dividing by zero"))
    (let ((ret::int 0))
      (fixnum-mod0 ret fx1 fx2)
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation
	   'fxmod0
	   "result is not a fixnum"
	   (SG_LIST2 (SG_MAKE_INT fx1)
		     (SG_MAKE_INT fx2))))))

  (define-cgen-stmt fxlogop-helper
    ((_ op x y)
     ((renderer) (format "(~a ~a SG_INT_VALUE(~a))" x op y))))

  (define-cgen-stmt fxlogop
    ((_ name ret op args)
     (dispatch
      `(dolist (v ,args)
	 (check-fixnum ,name v)
	 (set! ,ret (fxlogop-helper ,op ,ret v))))))

  (define-c-proc fxand (:rest rest) ::fixnum
    (let ((ret::int -1))
      (fxlogop fxand ret "&" rest)
      (result ret)))

  (define-c-proc fxior (:rest rest) ::fixnum
    (let ((ret::int 0))
      (fxlogop fxior ret "|" rest)
      (result ret)))

  (define-c-proc fxxor (:rest rest) ::fixnum
    (let ((ret::int 0))
      (fxlogop fxxor ret "^" rest)
      (result ret)))

  (define-c-proc fxnot (fx::fixnum) ::fixnum
    (result (fxlognot fx)))

  (define-c-proc fxif (fx1::fixnum fx2::fixnum fx3::fixnum) ::fixnum
    (result (fxlogif fx1 fx2 fx3)))

  (define-c-proc fxbit-count (fx::fixnum) ::fixnum
    ;; umm...
    (result (Sg_BitCount (SG_MAKE_INT fx))))

  (define-c-proc fxlength (fx::fixnum) ::fixnum
    ;; umm...
    (result (Sg_BitSize (SG_MAKE_INT fx))))

  (define-c-proc fxfirst-bit-set (fx::fixnum) ::fixnum
    ;; umm...
    (result (Sg_FirstBitSet (SG_MAKE_INT fx))))

  (define-c-proc fxbit-set? (fx1::fixnum fx2::fixnum) ::boolean
    (result (fxlogand (ashr fx1 fx2) 1)))

  (define-c-proc fxcopy-bit (fx1::fixnum fx2::fixnum fx3::fixnum) ::fixnum
    (check-fixnum-range fxcopy-bit fx2 0 SG_INT_SIZE <= <=)
    (check-fixnum-range fxcopy-bit fx3 0 1 <= <=)
    (let ((mask::int (ashl 1 fx2)))
      (result (fxlogif mask (ashl fx3 fx2) fx1))))

  (define-c-proc fxbit-field (fx1::fixnum fx2::fixnum fx3::fixnum) ::fixnum
    (check-fixnum-range fxbit-field fx2 0 SG_INT_SIZE <= <=)
    (check-fixnum-range fxbit-field fx3 0 SG_INT_SIZE <= <=)
    (when (> fx2 fx3)
      (assertion-violation 'fxbit-field
			   "out of range"
			   (SG_LIST3 (SG_MAKE_INT fx1)
				     (SG_MAKE_INT fx2)
				     (SG_MAKE_INT fx3))))
    (let ((mask::int (fxlognot (ashl -1 fx3))))
      (result (ashr (fxlogand fx1 mask) fx2))))

  (define-c-proc fxcopy-bit-field (fx1::fixnum fx2::fixnum fx3::fixnum fx4::fixnum) ::fixnum
    (check-fixnum-range fxbit-field fx2 0 SG_INT_SIZE <= <=)
    (check-fixnum-range fxbit-field fx3 0 SG_INT_SIZE <= <=)
    (when (> fx2 fx3)
      (assertion-violation 'fxbit-field
			   "out of range"
			   (SG_LIST4 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2)
				     (SG_MAKE_INT fx3) (SG_MAKE_INT fx4))))
    (let ((mask1::int (ashl -1 fx2))
	  (mask2::int (fxlognot (ashl -1 fx3)))
	  (mask::int (fxlogand mask1 mask2)))
      (result (fxlogif mask (ashl fx4 fx2) fx1))))

  (define-c-proc fxarithmetic-shift (fx1::fixnum fx2::fixnum) ::fixnum
    (when (> (abs fx2) SG_INT_SIZE)
      (assertion-violation 'fxarithmetic-shift "out of range"
			   (SG_LIST2 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2))))
    (let ((ret::int 0))
      (if (>= fx2 0)
	  (set! ret (ashl fx1 fx2))
	  (set! ret (ashr fx1 (negate fx2))))
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation 'fxarithmetic-shift
						"result is not a fixnum"
						(SG_LIST2 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2))))))

  (define-c-proc fxarithmetic-shift-left (fx1::fixnum fx2::fixnum) ::fixnum
    (check-fixnum-range fxbit-field fx2 0 SG_INT_SIZE <= <=)
    (let ((ret::int (ashl fx1 fx2)))
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation 'fxarithmetic-shift-left
						"result is not a fixnum"
						(SG_LIST2 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2))))))

  (define-c-proc fxarithmetic-shift-right (fx1::fixnum fx2::fixnum) ::fixnum
    (check-fixnum-range fxbit-field fx2 0 SG_INT_SIZE <= <=)
    (let ((ret::int (ashr fx1 fx2)))
      (if (fixnum-fits? ret)
	  (result ret)
	  (implementation-restriction-violation 'fxarithmetic-shift-left
						"result is not a fixnum"
						(SG_LIST2 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2))))))

  (decl-code 
   (.typedef "unsigned int" "uint"))

  (define-c-proc fxreverse-bit-field (fx1::fixnum fx2::fixnum fx3::fixnum) ::fixnum
    (check-fixnum-range fxbit-field fx2 0 SG_INT_SIZE <= <=)
    (check-fixnum-range fxbit-field fx3 0 SG_INT_SIZE <= <=)
    (when (> fx2 fx3)
      (assertion-violation 'fxreverse-bit-field "out of range"
			   (SG_LIST3 (SG_MAKE_INT fx1) (SG_MAKE_INT fx2) (SG_MAKE_INT fx3))))
    (let ((bits::uint  fx1)
	  (start::int fx2)
	  (end::int   (- fx3 1)))
      (while (< start end)
	(let ((sbit::int (fxlogand (ashr bits start) 1))
	      (ebit::int (fxlogand (ashr bits end) 1)))
	  (set! bits (fxlogand bits (- (cast uint -1) (ashl 1 end))))
	  (set! bits (fxlogor bits (ashl sbit end)))
	  (set! bits (fxlogand bits (- (cast uint -1) (ashl 1 start))))
	  (set! bits (fxlogor bits (ashl ebit start)))
	  (post++ start)
	  (post-- end)))
      (result bits)))

  ;; 11.3 flonums
  (decl-code
   (.include <math.h>)
   (.include <float.h>)) ;; for VC

  (define-c-proc flonum? (o) ::boolean
    (result (SG_FLONUMP o)))

  (define-c-proc real->flonum (n::number) ::Object
    (check-real-valued real->flonum n)
    (if (SG_FLONUMP n)
	(result n)
	(result (Sg_MakeFlonum (Sg_GetDouble n)))))

  (define-cgen-stmt check-flonum
    ((_ name v)
     (dispatch
      `(unless (SG_FLONUMP ,v)
	 (wrong-type-of-argument-violation ',name
					   "flonum"
					   (SG_LIST1 ,v))))))
  (define-cgen-stmt flonum-value
    ((_ fl)
     (dispatch
      `(-> (SG_FLONUM ,fl) value))))

  (define-cgen-stmt flonum-compare
    ((_ name compare first second rest)
     (dispatch
      `(begin
	 (unless (,compare (flonum-value ,first)
			   (flonum-value ,second))
	   (return #f))
	 (let ((prev::double (flonum-value ,second))
	       (target::double 0.0))
	   (dolist (v ,rest)
	     (check-flonum ,name v)
	     (set! target (flonum-value v))
	     (unless (,compare prev target)
	       (return #f))
	     (set! prev target))
	   (result TRUE))))))

  (define-c-proc fl=? (fl1::number fl2::number :rest rest) ::boolean
    (flonum-compare fl=? == fl1 fl2 rest))

  (define-c-proc fl<? (fl1::number fl2::number :rest rest) ::boolean
    (flonum-compare fl<? < fl1 fl2 rest))

  (define-c-proc fl>? (fl1::number fl2::number :rest rest) ::boolean
    (flonum-compare fl>? > fl1 fl2 rest))

  (define-c-proc fl<=? (fl1::number fl2::number :rest rest) ::boolean
    (flonum-compare fl<=? <= fl1 fl2 rest))

  (define-c-proc fl>=? (fl1::number fl2::number :rest rest) ::boolean
    (flonum-compare fl>=? >= fl1 fl2 rest))

  (define-cgen-stmt flonum-integer?
    ((_ fl)
     (dispatch
      `(cond ((or (isinf (flonum-value ,fl))
	       (isnan (flonum-value ,fl)))
	   (result FALSE))
	  (else
	   (result (== (flonum-value ,fl) (floor (flonum-value ,fl)))))))))

  (define-c-proc flinteger? (fl::number) ::boolean
    (check-flonum flinteger? fl)
    (flonum-integer? fl))

  (define-c-proc flzero? (fl::number) ::boolean
    (check-flonum flzero? fl)
    (result (== (flonum-value fl) 0.0)))
  
  (define-c-proc flpositive? (fl::number) ::boolean
    (check-flonum flpositive? fl)
    (result (> (flonum-value fl) 0.0)))

  (define-c-proc flnegative? (fl::number) ::boolean
    (check-flonum flnegative? fl)
    (result (< (flonum-value fl) 0.0)))

  (define-c-proc flodd? (fl::number) ::boolean
    (check-flonum flodd? fl)
    (flonum-integer? fl)
    (if SG_RETURN
	(result (not (== (* (flonum-value fl) 0.5)
			 (floor (* (flonum-value fl) 0.5)))))
	(wrong-type-of-argument-violation 'flodd?
					  "integer flonum"
					  (SG_LIST1 fl))))

  (define-c-proc fleven? (fl::number) ::boolean
    (check-flonum fleven? fl)
    (flonum-integer? fl)
    (if SG_RETURN
	(result (== (* (flonum-value fl) 0.5)
		    (floor (* (flonum-value fl) 0.5))))
	(wrong-type-of-argument-violation 'fleven?
					  "integer flonum"
					  (SG_LIST1 fl))))
  (define-c-proc flfinite? (fl::number) ::boolean
    (check-flonum flfinite? fl)
    (result (not (isinf (flonum-value fl)))))

  (define-c-proc flinfinite? (fl::number) ::boolean
    (check-flonum flinfinite? fl)
    (result (isinf (flonum-value fl))))

  (define-c-proc flnan? (fl::number) ::boolean
    (check-flonum flnan? fl)
    (result (isnan (flonum-value fl))))

  (define-c-proc flmax (fl::number :rest rest) ::Object
    (check-flonum flmax fl)
    (if (isnan (flonum-value fl))
	(return fl))
    (let ((max::double (flonum-value fl)))
      (dolist (v rest)
	(check-flonum flmax v)
	(if (isnan (flonum-value v))
	    (return v))
	(if (> (flonum-value v) max)
	    (set! max (flonum-value v))))
      (result (Sg_MakeFlonum max))))

  (define-c-proc flmin (fl::number :rest rest) ::Object
    (check-flonum flmin fl)
    (if (isnan (flonum-value fl))
	(return fl))
    (let ((min::double (flonum-value fl)))
      (dolist (v rest)
	(check-flonum flmin v)
	(if (isnan (flonum-value v))
	    (return v))
	(if (< (flonum-value v) min)
	    (set! min (flonum-value v))))
      (result (Sg_MakeFlonum min))))

  (define-cgen-stmt flonum-op
    ((_ name op ret first rest)
     (dispatch
      `(begin
	 (set! ,ret (flonum-value ,first))
	 (dolist (v ,rest)
	   (check-flonum ,name v)
	   (set! ,ret (,op ,ret (flonum-value v))))))))

  (define-c-proc fl+ (:rest rest) ::Object
    (if (SG_NULLP rest)
	(result (Sg_MakeFlonum 0.0))
	(let ((len::int (Sg_Length rest)))
	  (cond ((== len 1)
		 (check-flonum fl+ (SG_CAR rest))
		 (result (SG_CAR rest)))
		(else
		 (let ((ret::double 0.0))
		   (flonum-op fl+ + ret (SG_CAR rest) (SG_CDR rest))
		   (result (Sg_MakeFlonum ret))))))))

  (define-c-proc fl* (:rest rest) ::Object
    (if (SG_NULLP rest)
	(result (Sg_MakeFlonum 1.0))
	(let ((len::int (Sg_Length rest)))
	  (cond ((== len 1)
		 (check-flonum fl* (SG_CAR rest))
		 (result (SG_CAR rest)))
		(else
		 (let ((ret::double 1.0))
		   (flonum-op fl* * ret (SG_CAR rest) (SG_CDR rest))
		   (result (Sg_MakeFlonum ret))))))))

  (define-c-proc fl- (fl::number :rest rest) ::Object
    (check-flonum fl- fl)
    (cond ((SG_NULLP rest)
	   (result (Sg_MakeFlonum (* -1 (flonum-value fl)))))
	  (else
	   (let ((ret::double 1.0))
	     (flonum-op fl- - ret fl rest)
	     (result (Sg_MakeFlonum ret))))))

  (define-c-proc fl/ (fl::number :rest rest) ::Object
    (check-flonum fl/ fl)
    (cond ((SG_NULLP rest)
	   (if (== (flonum-value fl) 0.0)
	       (assertion-violation 'fl/ "undefined for 0" (SG_LIST1 fl))
	       (result (Sg_Div (Sg_MakeFlonum 1.0) fl))))
	  (else
	   (let ((ret::double 1.0))
	     (flonum-op fl/ / ret fl rest)
	     (result (Sg_MakeFlonum ret))))))

  (define-cgen-stmt flonum-div
    ((_ ret d1 d2)
     (dispatch
      `(if (> ,d2 0.0)
	   (set! ,ret (floor (/ ,d1 ,d2)))
	   (set! ,ret (negate (floor (/ ,d1 (negate ,d2)))))))))

  (define-cgen-stmt flonum-mod
    ((_ ret d1 d2)
     (dispatch
      (let ((tmp (gen-temporary)))
	`(let ((,(string->symbol (format "~a::double" tmp)) 0.0))
	   (flonum-div ,tmp ,d1 ,d2)
	   (set! ,ret (- ,d1 (* ,d2 ,tmp))))))))

  (define-c-proc fldiv (fl1::number fl2::number) ::Object
    (check-flonum fldiv fl1)
    (check-flonum fldiv fl2)
    (let ((d1::double (flonum-value fl1))
	  (d2::double (flonum-value fl2))
	  (ret::double 0.0))
      (flonum-div ret d1 d2)
      (result (Sg_MakeFlonum ret))))

  (define-c-proc flmod (fl1::number fl2::number) ::Object
    (check-flonum flmod fl1)
    (check-flonum flmod fl2)
    (let ((d1::double (flonum-value fl1))
	  (d2::double (flonum-value fl2))
	  (ret::double 0.0))
      (flonum-mod ret d1 d2)
      (result (Sg_MakeFlonum ret))))

  (define-cgen-stmt flonum-div0
    ((_ ret d1 d2)
     (dispatch
      (let ((div (gen-temporary))
	    (mod (gen-temporary)))
	`(let ((,(string->symbol (format "~a::double" div)) 0.0)
	       (,(string->symbol (format "~a::double" mod)) 0.0))
	   (flonum-div ,div ,d1 ,d2)
	   (flonum-mod ,mod ,d1 ,d2)
	   (cond ((< ,mod (/ (fabs ,d2) 2.0))
		  (set! ,ret ,div))
		 ((> ,d2 0.0)
		  (set! ,ret (+ ,div 1.0)))
		 (else(set! ,ret (- ,div 1.0)))))))))

  (define-cgen-stmt flonum-mod0
    ((_ ret d1 d2)
     (dispatch
      (let ((div (gen-temporary)))
	`(let ((,(string->symbol (format "~a::double" div)) 0.0))
	   (flonum-div0 ,div ,d1 ,d2)
	   (set! ,ret (- ,d1 (* ,d2 ,div))))))))

  (define-c-proc fldiv0 (fl1::number fl2::number) ::Object
    (check-flonum fldiv0 fl1)
    (check-flonum fldiv0 fl2)
    (let ((d1::double (flonum-value fl1))
	  (d2::double (flonum-value fl2))
	  (ret::double 0.0))
      (flonum-div0 ret d1 d2)
      (result (Sg_MakeFlonum ret))))

  (define-c-proc flmod0 (fl1::number fl2::number) ::Object
    (check-flonum flmod0 fl1)
    (check-flonum flmod0 fl2)
    (let ((d1::double (flonum-value fl1))
	  (d2::double (flonum-value fl2))
	  (ret::double 0.0))
      (flonum-mod0 ret d1 d2)
      (result (Sg_MakeFlonum ret))))

  (define-c-proc flnumerator (fl::number) ::Object
    (check-flonum flnumerator fl)
    (result (Sg_Numerator fl)))

  (define-c-proc fldenominator (fl::number) ::Object
    (check-flonum fldenominator fl)
    (result (Sg_Denominator fl)))

  (define-c-proc flfloor (fl::number) ::Object
    (check-flonum flfloorr fl)
    (result (Sg_Round fl SG_ROUND_FLOOR)))

  (define-c-proc flceiling (fl::number) ::Object
    (check-flonum flceiling fl)
    (result (Sg_Round fl SG_ROUND_CEIL)))

  (define-c-proc fltruncate (fl::number) ::Object
    (check-flonum fltruncate fl)
    (result (Sg_Round fl SG_ROUND_TRUNC)))

  (define-c-proc flround (fl::number) ::Object
    (check-flonum flround fl)
    (result (Sg_Round fl SG_ROUND_ROUND)))

  (define-c-proc flexp (fl::number) ::Object
    (check-flonum flexp fl)
    (result (Sg_MakeFlonum (exp (flonum-value fl)))))

  (define-c-proc flexpt (fl1::number fl2::number) ::Object
    (check-flonum flexpt fl1)
    (check-flonum flexpt fl2)
    (result (Sg_MakeFlonum (pow (flonum-value fl1) (flonum-value fl2)))))

  (define-c-proc fllog (fl1::number :optional fl2) ::Object
    (check-flonum fllog fl1)
    (if (SG_UNBOUNDP fl2)
	(result (Sg_MakeFlonum (log (flonum-value fl1))))
	(begin
	  (check-flonum fllog fl2)
	  (result (Sg_MakeFlonum (/ (log (flonum-value fl1))
				    (log (flonum-value fl2))))))))
  
  (define-c-proc flsin (fl::number) ::Object
    (check-flonum flsin fl)
    (result (Sg_MakeFlonum (sin (flonum-value fl)))))

  (define-c-proc flcos (fl::number) ::Object
    (check-flonum flcos fl)
    (result (Sg_MakeFlonum (cos (flonum-value fl)))))

  (define-c-proc fltan (fl::number) ::Object
    (check-flonum fltan fl)
    (result (Sg_MakeFlonum (tan (flonum-value fl)))))

  (define-c-proc flasin (fl::number) ::Object
    (check-flonum flasin fl)
    (result (Sg_MakeFlonum (asin (flonum-value fl)))))

  (define-c-proc flacos (fl::number) ::Object
    (check-flonum flacos fl)
    (result (Sg_MakeFlonum (acos (flonum-value fl)))))

  (define-c-proc flatan (fl1::number :optional fl2) ::Object
    (check-flonum flatan fl1)
    (if (SG_UNBOUNDP fl2)
	(result (Sg_MakeFlonum (atan (flonum-value fl1))))
	(begin
	  (check-flonum flatan fl2)
	  (result (Sg_MakeFlonum (atan2 (flonum-value fl1)
					(flonum-value fl2)))))))

  (define-c-proc flabs (fl::number) ::Object
    (check-flonum flabs fl)
    (result (Sg_MakeFlonum (fabs (flonum-value fl)))))

  (define-c-proc flsqrt (fl::number) ::Object
    (check-flonum flsqrt fl)
    (let ((v::double (flonum-value fl)))
      (if (< v 0.0)
	  (result (Sg_MakeComplex (Sg_MakeFlonum 0.0)
				  (Sg_MakeFlonum (sqrt (fabs v)))))
	  (result (Sg_MakeFlonum (sqrt v))))))

  (define-c-proc fixnum->flonum (fx::fixnum) ::Object
    (result (Sg_MakeFlonum fx)))

  ;; 11.4 exact bitwise arithmetic
  (define-c-proc bitwise-not (ei::number) ::Object
    (unless (Sg_ExactP ei)
      (wrong-type-of-argument-violation 'bitwise-not "exact integer required" ei))
    (result (Sg_LogNot ei)))

  (define-cgen-stmt logop
    ((_ fn x y rest)
     (dispatch
      `(let ((r (,fn ,x ,y)))
	 (for-each (lambda (v) (set! r (,fn r v))) ,rest)
	 (result r)))))

  (define-c-proc bitwise-and (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogAnd ei (SG_CAR rest) (SG_CDR rest))))

  (define-c-proc bitwise-ior (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogIor ei (SG_CAR rest) (SG_CDR rest))))

  (define-c-proc bitwise-xor (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogXor ei (SG_CAR rest) (SG_CDR rest))))

  (define-cgen-stmt logif
    ((_ n1 n2 n3)
     (dispatch
      `(Sg_LogIor (Sg_LogAnd ,n1 ,n2)
		  (Sg_LogAnd (Sg_LogNot ,n1) ,n3)))))

  (define-c-proc bitwise-if (ei1::number ei2::number ei3::number) ::Object
    (result (logif ei1 ei2 ei3)))

  (define-c-proc bitwise-bit-count (ei::number) ::fixnum
    (result (Sg_BitCount ei)))

  (define-c-proc bitwise-length (ei::number) ::fixnum
    (result (Sg_BitSize ei)))

  (define-c-proc bitwise-first-bit-set (ei::number) ::fixnum
    (result (Sg_FirstBitSet ei)))

  (define-c-proc bitwise-bit-set? (ei1::number ei2::fixnum) ::boolean
    (result (not (Sg_ZeroP (Sg_LogAnd (Sg_Ash (SG_MAKE_INT 1) ei2) ei1)))))

  (define-c-proc bitwise-copy-bit (ei1::number ei2::fixnum ei3::number) ::Object
    (let ((mask (Sg_Ash (SG_MAKE_INT 1) ei2)))
      (result (logif mask (Sg_Ash ei3 ei2) ei1))))

  (define-c-proc bitwise-bit-field (ei1::number ei2::fixnum ei3::fixnum) ::Object
    (when (> ei2 ei3)
      (assertion-violation 'bitwise-bit-field "2nd parameter must be less than or equal to 3rd parameter"
			   (SG_LIST3 ei1 (SG_MAKE_INT ei2) (SG_MAKE_INT ei3))))
    (let ((mask (Sg_LogNot (Sg_Ash (SG_MAKE_INT -1) ei3))))
      (result (Sg_Ash (Sg_LogAnd ei1 mask) (- 0 ei2)))))

  (define-c-proc bitwise-copy-bit-field (ei1::number ei2::fixnum ei3::fixnum ei4::number) ::Object
    (let ((to ei1)
	  (start::int ei2)
	  (end::int ei3)
	  (from ei4)
	  (mask1 (Sg_Ash (SG_MAKE_INT -1) start))
	  (mask2 (Sg_LogNot (Sg_Ash (SG_MAKE_INT -1) end)))
	  (mask (Sg_LogAnd mask1 mask2)))
      (result (logif mask (Sg_Ash from start) to))))

  (define-c-proc bitwise-arithmetic-shift (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 ei2)))

  (define-c-proc bitwise-arithmetic-shift-left (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 ei2)))

  (define-c-proc bitwise-arithmetic-shift-right (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 (- 0 ei2))))

  ;; 12 syntax-case
  ;; 12.5 identifier predicates
  (define-c-proc identifier? (id) ::boolean
    (result (or (SG_IDENTIFIERP id)
		(SG_USER_DEFINED_SYNTXP id))))

  (define-c-proc bound-identifier=? (id1::Identifier id2::Identifier) ::boolean
    (result (and (SG_EQ (SG_IDENTIFIER_NAME id1)
			(SG_IDENTIFIER_NAME id2))
		 (SG_EQ (SG_IDENTIFIER_ENVS id1)
			(SG_IDENTIFIER_ENVS id2)))))
  ;; TODO dummy
  (define-c-proc free-identifier=? (id1::Identifier id2::Identifier) ::boolean
    (result (SG_EQ (SG_IDENTIFIER_NAME id1)
		   (SG_IDENTIFIER_NAME id2))))

  ;; 13 Hashtables
  ;; 13.1 constructors
  (define-c-proc make-eq-hashtable (:optional (k::fixnum 200)) ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_EQ k)))

  (define-c-proc make-eqv-hashtable (:optional (k::fixnum 200)) ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_EQV k)))

  (define-c-proc make-hashtable (hasher::Procedure equiv::Procedure :optional (k::fixnum 200)) ::Object
    (result (Sg_MakeHashTableForScheme hasher equiv k)))

  ;; 13.2 procedures
  (define-c-proc hashtable? (o) ::boolean
    (result (SG_HASHTABLE_P o)))

  (define-c-proc hashtable-size (ht::HashTable) ::fixnum
    (result (-> (SG_HASHTABLE_CORE ht) entryCount)))

  (define-c-proc hashtable-ref (ht::HashTable key fallback) ::Object
    (result (Sg_HashTableRef ht key fallback)))

  (define-cgen-stmt check-mutable-hashtable
    ((_ name t)
     (dispatch
      `(when (SG_IMMUTABLE_HASHTABLE_P ,t)
	 (assertion-violation ',name "attemp to modify an immutable hashtable" ,t)))))

  (define-c-proc hashtable-set! (ht::HashTable key value) ::void
    (check-mutable-hashtable hashtable-set! ht)
    (Sg_HashTableSet ht key value 0))

  (define-c-proc hashtable-delete! (ht::HashTable key) ::void
    (check-mutable-hashtable hashtable-set! ht)
    (Sg_HashTableDelete ht key))

  (define-c-proc hashtable-contains? (ht::HashTable key) ::boolean
    (let ((r (Sg_HashTableRef ht key SG_UNBOUND)))
      (result (not (SG_UNBOUNDP r)))))

  (define-c-proc hashtable-copy (ht::HashTable :optional (mutableP::boolean FALSE)) ::Object
    (result (Sg_HashTableCopy ht mutableP)))

  (define-c-proc hashtable-clear! (ht::HashTable :optional (k::fixnum -1)) ::void
    (check-mutable-hashtable hashtable-clear! ht)
    (Sg_HashCoreClear (SG_HASHTABLE_CORE ht) k))

  (define-c-proc hashtable-keys (ht::HashTable) ::Object
    (result (Sg_ListToVector (Sg_HashTableKeys ht) 0 -1)))

  ;; 13.3 inspection
  (define-c-proc hashtable-mutable? (ht::HashTable) ::boolean
    (result (not (SG_IMMUTABLE_HASHTABLE_P ht))))

  ;; 13.4
  (define-c-proc equal-hash (o) ::fixnum
    (result (Sg_EqualHash o)))

  ;; for srfi-13 we need to take bound as an argument
  (define-c-proc string-hash (o::String :optional bound) ::fixnum
    (let ((modulo::uint32_t 0))
      (cond ((SG_UNBOUNDP bound) (set! modulo SG_INT_MAX))
	    ((SG_INTP bound) (set! modulo (SG_INT_VALUE bound)))
	    ((SG_BIGNUMP bound)
	     (set! modulo (Sg_BignumToUI (SG_BIGNUM bound) SG_CLAMP_BOTH NULL))))
      (when (== modulo 0)
	(assertion-violation 'string-hash
			     "argument out of domain"
			     bound))
      (result (Sg_StringHash o modulo))))

  (define-c-proc string-ci-hash (o::String :optional bound) ::fixnum
    (let ((modulo::uint32_t 0))
      (cond ((SG_UNBOUNDP bound) (set! modulo SG_INT_MAX))
	    ((SG_INTP bound) (set! modulo (SG_INT_VALUE bound)))
	    ((SG_BIGNUMP bound)
	     (set! modulo (Sg_BignumToUI (SG_BIGNUM bound) SG_CLAMP_BOTH NULL))))
      (when (== modulo 0)
	(assertion-violation 'string-hash
			     "argument out of domain"
			     bound))
      (result (Sg_StringHash (Sg_StringFoldCase o) modulo))))

  (define-c-proc symbol-hash (o::Symbol) ::fixnum
    (result (Sg_EqHash o)))

  ;; 15 composit library
  ;; 16 eval
  (define-c-proc eval (sexp env) ::Object
    (result (Sg_Eval sexp env)))

  (define-c-proc environment (spec :rest more) ::Object
    (result (Sg_Environment (Sg_VMCurrentLibrary) (Sg_Cons spec more))))

  ;; 17 mutable pairs
  (define-c-proc set-car! (o v) ::void
    (SG_SET_CAR o v))

  (define-c-proc set-cdr! (o v) ::void
    (SG_SET_CDR o v))

  ;; 18 mutable strings
  (define-c-proc string-set! (s::String k::fixnum c) ::void
    (when (< k 0)
      (wrong-type-of-argument-violation 'string-set! "non negative exact integer"
					(SG_MAKE_INT k)
					(SG_LIST3 s (SG_MAKE_INT k) c)))
    (when (> k (SG_STRING_SIZE s))
      (assertion-violation 'string-set! "index out of bounds"
			   (SG_LIST3 s (SG_MAKE_INT k) c)))
    (unless (SG_CHARP c)
      (wrong-type-of-argument-violation 'string-set! "character"
					c
					(SG_LIST3 s (SG_MAKE_INT k) c)))
    (when (SG_LITERAL_STRINGP s)
      (assertion-violation 'string-set! "attempted to modify an immutable string"
			   s))
    (set! (SG_STRING_VALUE_AT s k) (SG_CHAR_VALUE c)))
  
  ;; we take start and end as optional arguments for srfi-13
  (define-c-proc string-fill! (s::String c :optional (start::fixnum 0) (end::fixnum -1)) ::void
    (check-char string-fill! c)
    (when (SG_LITERAL_STRINGP s)
      (assertion-violation 'string-set! "attempted to modify an immutable string"
			   s))
    (Sg_StringFill s (SG_CHAR_VALUE c) start end))

  ;; conditions
  (define-c-proc condition (:rest components) ::Object
    (result (Sg_Condition components)))

  (define-c-proc simple-conditions (obj) ::Object
    (result (Sg_SimpleConditions obj)))

  (define-c-proc compound-condition-component (obj) ::Object
    (result (Sg_CompoundConditionComponent obj)))

  (define-c-proc compound-condition? (obj) ::boolean
    (result (Sg_CompoundConditionP obj)))

  (define-c-proc simple-condition? (obj) ::boolean
    (result (Sg_SimpleConditionP obj)))
  
  (define-c-proc condition? (obj) ::boolean
    (result (Sg_ConditionP obj)))

  (define-c-proc condition-predicate (rtd) ::Object
    (result (Sg_ConditionPredicate rtd)))

  (define-c-proc condition-accessor (rtd proc) ::Object
    (result (Sg_ConditionAccessor rtd proc)))

  ;; record
  (define-c-proc make-record-type (name::Symbol rtd rcd) ::Object
    (result (Sg_MakeRecordType name rtd rcd)))
  (set-toplevel-variable! make-record-type make-record-type)

  (define-c-proc record-type-rtd (rt::RecordType) ::Object
    (result (SG_RECORD_TYPE_RTD rt)))
  (set-toplevel-variable! record-type-rtd record-type-rtd)

  (define-c-proc record-type-rcd (rt::RecordType) ::Object
    (result (SG_RECORD_TYPE_RCD rt)))
  (set-toplevel-variable! record-type-rcd record-type-rcd)

  (define-c-proc make-record-type-descriptor
    (name::Symbol parent uid sealedP::boolean opaqueP::boolean fields::Vector) ::Object
    (result (Sg_MakeRecordTypeDescriptor name parent uid sealedP opaqueP fields)))

  (define-c-proc make-record-constructor-descriptor (rtd parent protocol) ::Object
    (result (Sg_MakeRecordConstructorDescriptor rtd parent protocol)))

  (define-c-proc record? (o) ::boolean
    (result (Sg_RecordP o)))

  (define-c-proc record-rtd (o) ::Object
    (result (Sg_RecordRtd o)))

  (define-c-proc record-type-descriptor? (o) ::boolean
    (result (Sg_RecordTypeDescriptorP o)))

  (define-c-proc record-constructor-descriptor? (o) ::boolean
    (result (Sg_RecordConstructorDescriptorP o)))

  (define-c-proc record-constructor (rcd) ::Object
    (result (Sg_RecordConstructor rcd)))

  (define-c-proc record-accessor (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-accessor "record-type-descriptor" rtd (SG_LIST2 rtd (SG_MAKE_INT k))))
    (unless (and (< -1 k)
		 (< k (Sg_Length (Sg_RtdFields rtd))))
      (assertion-violation 'record-accessor "field index out of range"))
    (result (Sg_RecordAccessor rtd k)))

  (define-c-proc record-predicate (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-predicate "record-type-descriptor" rtd))
    (result (Sg_RecordPredicate rtd)))

  (define-c-proc record-mutator (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-mutator "record-type-descriptor" rtd (SG_LIST2 rtd (SG_MAKE_INT k))))
    (unless (and (< -1 k)
		 (< k (Sg_Length (Sg_RtdFields rtd))))
      (assertion-violation 'record-mutator "field index out of range" (SG_LIST2 rtd (SG_MAKE_INT k))))
    (when (SG_FALSEP (SG_CAR (Sg_ListRef (Sg_RtdFields rtd) k SG_UNBOUND)))
      (assertion-violation 'record-mutator "specified field is immutable" (SG_LIST2 rtd (SG_MAKE_INT k))))
    (result (Sg_RecordMutator rtd k)))

  (define-c-proc record-type-name (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdName rtd)))

  (define-c-proc record-type-parent (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdParent rtd)))

  (define-c-proc record-type-uid (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdUid rtd)))

  (define-c-proc record-type-generative? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (SG_FALSEP (Sg_RtdUid rtd))))

  (define-c-proc record-type-opaque? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdOpaqueP rtd)))

  (define-c-proc record-type-sealed? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
	(wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdSealedP rtd)))
  ;; for convenience, it returns list
  (define-c-proc rtd-fields (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdFields rtd)))

  (define-c-proc record-type-field-names (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (let ((fields (Sg_RtdFields rtd))
	  (h '())
	  (t '()))
      (dolist (field fields)
	(ASSERT (SG_PAIRP field))
	(SG_APPEND1 h t (SG_CDR field)))
      (result (Sg_ListToVector h 0 -1))))

  (define-c-proc record-field-mutable? (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (SG_CAR (Sg_ListRef (Sg_RtdFields rtd) k SG_UNBOUND))))

  (define-c-proc rtd-inherited-field-count (rtd) ::fixnum
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdInheritedFieldCount rtd)))

  (define-c-proc rtd-total-field-count (rtd) ::fixnum
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdTotalFieldCount rtd)))

  (define-c-proc rtd-ancestor? (parent rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd (SG_LIST2 parent rtd)))
    (unless (Sg_RecordTypeDescriptorP parent)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" parent (SG_LIST2 parent rtd)))
    (result (Sg_RtdAncestorP parent rtd)))

  (define-c-proc rcd-protocol (rcd) ::Object
    (result (Sg_RcdProtocol rcd)))

  (define-c-proc rcd-parent (rcd) ::Object
    (result (Sg_RcdParent rcd)))

  ;; tuple of record helper
  (define-c-proc make-tuple (size::fixnum printer) ::Object
    (result (Sg_MakeTuple size SG_UNDEF printer)))

  (define-c-proc tuple-list-set! (tuple lst) ::void
    (Sg_TupleListSet tuple lst))

  (define-c-proc tuple-ref (tuple i::fixnum) ::Object
    (result (Sg_TupleRef tuple i #f)))

  (define-c-proc tuple-set! (tuple i::fixnum value) ::void
    (Sg_TupleSet tuple i value))

  (define-c-proc tuple-size (tuple) ::fixnum
    (result (Sg_TupleSize tuple)))

  )
