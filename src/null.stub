;; -*- scheme -*-
#!compatible ;; for ypsilon
(library null
    (export values
	    ;; base arithmetic
	    + +. - -. * *. / /.
	    = < <= > >=
	    
	    zero? positive? negative? odd? even?
	    finite? infinite? nan?
	    max min abs div-and-mod div mod
	    div0-and-mod0 div0 mod0 %gcd
	    numerator denominator floor ceiling
	    truncate round rationalize exp log
	    sin cos tan asin acos atan sqrt
	    exact-integer-sqrt expt
	    make-rectangular make-polar
	    real-part imag-part magnitude angle
	    ;; for comaptibility
	    quotient remainder modulo
	    ;; misc
	    integer-length

	    bitwise-not
	    bitwise-and
	    bitwise-ior
	    bitwise-xor
	    bitwise-if
	    bitwise-bit-count
	    bitwise-length
	    bitwise-first-bit-set
	    bitwise-bit-set?
	    bitwise-copy-bit
	    bitwise-bit-field
	    bitwise-copy-bit-field
	    bitwise-arithmetic-shift
	    bitwise-arithmetic-shift-left
	    bitwise-arithmetic-shift-right
	    ;; in scmlib.scm
	    ;;bitwise-rotate-bit-field
	    ;;bitwise-reverse-bit-field

	    ;; apply
	    apply

	    ;; io
	    display newline write write/ss
	    ;; ports
	    port? input-port? output-port?
	    flush-output-port current-output-port
	    open-file-input-port open-file-output-port
	    close-input-port close-output-port
	    format read

	    ;; error
	    error raise raise-continuable

	    ;; transcoder
	    native-transcoder

	    ;; list 
	    cons car cdr caar cadr cdar cddr acons cons*
	    list length append append! reverse
	    memq memv member assq assv assoc
	    list->vector list-transpose+ list-tail

	    set-car! set-cdr!

	    ;; string
	    string-length number->string string-append
	    string->symbol string->list list->string

	    ;; vector
	    vector? vector vector-set! vector-ref
	    vector-length make-vector
	    vector->list vector-fill!

	    ;; byte-vector
	    ;;endianness
	    native-endianness
	    bytevector? make-bytevector bytevector-length bytevector=?
	    bytevector-fill! bytevector-copy! bytevector-copy
	    bytevector-u8-ref bytevector-s8-ref bytevector-u8-set! bytevector-s8-set!
	    bytevector->u8-list u8-list->bytevector
	    bytevector-u16-ref bytevector-s16-ref bytevector-u16-native-ref bytevector-s16-native-ref
	    bytevector-u16-set! bytevector-s16-set! bytevector-u16-native-set! bytevector-s16-native-set!
	    bytevector-u32-ref bytevector-s32-ref bytevector-u32-native-ref bytevector-s32-native-ref
	    bytevector-u32-set! bytevector-s32-set! bytevector-u32-native-set! bytevector-s32-native-set!
	    bytevector-u64-ref bytevector-s64-ref bytevector-u64-native-ref bytevector-s64-native-ref
	    bytevector-u64-set! bytevector-s64-set! bytevector-u64-native-set! bytevector-s64-native-set!
	    bytevector-ieee-single-ref bytevector-ieee-single-native-ref
	    bytevector-ieee-single-set! bytevector-ieee-single-native-set!
	    bytevector-ieee-double-ref bytevector-ieee-double-native-ref
	    bytevector-ieee-double-set! bytevector-ieee-double-native-set!
	    ;;bytevector-uint-ref bytevector-sint-ref
	    ;;bytevector-uint-set!  bytevector-sint-set!
	    ;;bytevector->uint-list bytevector->sint-list
	    ;;uint-list->bytevector sint-list->bytevector
	    string->utf8 utf8->string
	    string->utf16 utf16->string
	    string->utf32 utf32->string

	    ;; conditions
	    eq? eqv? equal?
	    integer? number? exact? inexact? pair? real?
	    complex?
	    null? list? eof-object?
	    keyword?
	    not and

	    ;; hashtable
	    make-eq-hashtable hashtable-ref
	    hashtable-set! hashtable->alist
	    hashtable-keys hashtable-values

	    ;; call/cc
	    call/cc call-with-current-continuation
	    dynamic-wind with-exception-handler

	    ;; conditions
	    condition simple-conditions compound-condition-component
	    compound-condition? simple-condition? condition?
	    condition-predicate condition-accessor

	    ;; record
	    make-record-type
	    record-type-rtd record-type-rcd
	    make-record-type-descriptor
	    make-record-constructor-descriptor
	    record? record-rtd
	    record-type-descriptor?
	    record-constructor-descriptor?
	    record-constructor
	    record-accessor record-predicate record-mutator
	    record-type-name record-type-parent
	    record-type-uid record-type-generative?
	    record-type-opaque? record-type-sealed?
	    record-type-field-names
	    record-field-mutable?
	    ;; record helpers
	    rtd-fields
	    rtd-inherited-field-count rtd-total-field-count
	    rtd-ancestor?
	    rcd-protocol rcd-parent
	    ;; tuple for record helper
	    make-tuple tuple-list-set! tuple-ref ruple-set!

	    ;; misc
	    unbound undefined undefined? add-load-path
	    gensym)
    (import :none)
;; for Ypsilon
#!compatible
  (decl-code
   (.include <sagittarius/instruction.h>))

  (define-cgen-stmt assertion-violation
    ((_ who msg)
     (dispatch
      `(Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) '())))
    ((_ who msg irritants)
     (dispatch
      `(Sg_AssertionViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,irritants))))

  (define-cgen-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     (dispatch
      `(Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got '())))
    ((_ who msg got irritants)
     (dispatch
      `(Sg_WrongTypeOfArgumentViolation ,who (Sg_MakeString ,msg SG_LITERAL_STRING) ,got ,irritants))))

  (define-c-proc values (:rest rest) (inline VALUES) ::Object
    (let ((len (Sg_Length rest)))
      (cond ((== len 1) (result (SG_CAR rest)))
	    (else
	     (let ((v (Sg_MakeValues len))
		   (i::int 0))
	       (dolist (e rest)
		 (set! (SG_VALUES_ELEMENT v i) e)
		 (set! i (+ i 1)))
	       (result v))))))

  ;; arithmetic
  (define-c-proc + (:rest rest) ::Object
    (cond ((not (SG_PAIRP rest)) (result (SG_MAKE_INT 0)))
	  ((not (SG_NUMBERP (SG_CAR rest)))
	   (wrong-type-of-argument-violation '+ "number" (SG_CAR rest) rest)
	   (result SG_UNDEF))		; dummy
	  (else (let ((r::SgObject (SG_CAR rest)))
		  (dolist (v (SG_CDR rest)) (set! r (Sg_Add r v)))
		  (result r)))))
  (define-c-proc +. (:rest rest::Object) ::Object
    (let ((a (Sg_MakeFlonum 0.0)))
      (dolist (x rest) (set! a (Sg_Add a (Sg_Inexact x))))
      (result a)))

  (define-c-proc * (:rest rest::Object) ::Object
    (cond ((not (SG_PAIRP rest)) (result (SG_MAKE_INT 1)))
	  ((not (SG_NUMBERP (SG_CAR rest)))
	   (wrong-type-of-argument-violation '+ "number" (SG_CAR rest) rest)
	   (result SG_UNDEF))		; dummy
	  (else (let ((r::SgObject (SG_CAR rest)))
		  (dolist (v (SG_CDR rest)) (set! r (Sg_Mul r v)))
		  (result r)))))
  (define-c-proc *. (:rest rest::Object) ::Object
    (let ((a (Sg_MakeFlonum 0.0)))
      (dolist (x rest) (set! a (Sg_Mul a (Sg_Inexact x))))
      (result a)))

  (define-c-proc - (arg1 :rest rest::Object) ::Object
    (if (SG_NULLP rest)
	(result (Sg_Negate arg1))
	(begin (dolist (v rest) (set! arg1 (Sg_Sub arg1 v)))
	       (result arg1))))
  (define-c-proc -. (arg1 :rest rest::Object) ::Object
    (cond ((SG_NULLP rest) (result (Sg_Negate (Sg_Inexact arg1))))
	  (else (dolist (x rest) (set! arg1 (Sg_Sub arg1 (Sg_Inexact x))))
		(result arg1))))

  (define-c-proc / (arg1 :rest rest::Object) ::Object
    (if (SG_NULLP rest)
	(result (Sg_Inverse arg1))
	(begin (dolist (v rest) (set! arg1 (Sg_Div arg1 v)))
	       (result arg1))))
  (define-c-proc /. (arg1 :rest rest::Object) ::Object
    (cond ((SG_NULLP rest) (result (Sg_Inverse (Sg_Inexact arg1))))
	  (else (dolist (x rest) (set! arg1 (Sg_Div arg1 (Sg_Inexact x))))
		(result arg1))))
  ;; base arithmetic
  (define-c-proc zero? (arg0::number) ::boolean
    (result (and (SG_REALP arg0) (== (Sg_Sign arg0) 0))))

  (define-c-proc positive? (x::number) ::boolean
    (result (Sg_PositiveP x)))

  (define-c-proc negative? (x::number) ::boolean
    (result (Sg_NegativeP x)))

  (define-c-proc odd? (x::number) ::boolean
    (result (Sg_OddP x)))

  (define-c-proc even? (x::number) ::boolean
    (result (not (Sg_OddP x))))

  (define-c-proc finite? (x::number) ::boolean
    (result (Sg_FiniteP x)))

  (define-c-proc infinite? (x::number) ::boolean
    (result (Sg_InfiniteP x)))

  (define-c-proc nan? (x::number) ::boolean
    (result (Sg_NanP x)))
    
  (define-c-proc max (arg0 :rest rest) ::Object
    (Sg_MinMax arg0 rest NULL (& SG_RETURN)))

  (define-c-proc min (arg0 :rest rest) ::Object
    (Sg_MinMax arg0 rest (& SG_RETURN) NULL))

  (define-c-proc abs (x::number) ::Object
    (result (Sg_Abs x)))

  (define-c-proc numerator (x::number) ::Object
    (result (Sg_Numerator x)))

  (define-c-proc denominator (x::number) ::Object
    (result (Sg_Denominator x)))

  (define-c-proc floor (x::number) ::Object
    (result (Sg_Round x SG_ROUND_FLOOR)))

  (define-c-proc ceiling (x::number) ::Object
    (result (Sg_Round x SG_ROUND_CEIL)))

  (define-c-proc truncate (x::number) ::Object
    (result (Sg_Round x SG_ROUND_TRUNC)))

  (define-c-proc round (x::number) ::Object
    (result (Sg_Round x SG_ROUND_ROUND)))

  (define-c-proc div (x::number y::number) ::Object
    (result (Sg_IntegerDiv x y)))

  (define-c-proc mod (x::number y::number) ::Object
    (result (Sg_IntegerMod x y)))

  (define-c-proc div0 (x::number y::number) ::Object
    (result (Sg_IntegerDiv0 x y)))

  (define-c-proc mod0 (x::number y::number) ::Object
    (result (Sg_IntegerMod0 x y)))

  ;; takes 2. r6rs implementation is in scmlib.scm
  (define-c-proc %gcd (x::number y::number) ::Object
    (result (Sg_Gcd x y)))

  (define-c-proc exp (x::number) ::Object
    (result (Sg_Exp x)))

  (define-c-proc expt (x::number y::number) ::Object
    (result (Sg_Expt x y)))

  (define-c-proc log (x::number :optional (base::number SG_UNBOUND)) ::Object
    (if (SG_UNBOUNDP base)
	(result (Sg_Log x))
	(result (Sg_Div (Sg_Log x) (Sg_Log base)))))

  (define-c-proc make-rectangular (a::number b::number) ::Object
    (unless (SG_REALP a)
      (wrong-type-of-argument-violation 'make-rectangular "real number required" a (SG_LIST2 a b)))
    (unless (SG_REALP b)
      (wrong-type-of-argument-violation 'make-rectangular "real number required" b (SG_LIST2 a b)))
    (result (Sg_MakeComplex a b)))

  (define-c-proc make-polar (r::number t::number) ::Object
    (unless (SG_REALP r)
      (wrong-type-of-argument-violation 'make-polar "real number required" r (SG_LIST2 r t)))
    (unless (SG_REALP t)
      (wrong-type-of-argument-violation 'make-polar "real number required" t (SG_LIST2 r t)))
    (result (Sg_MakeComplexPolar r t)))

  (define-c-proc real-part (r::number) ::Object
    (cond ((SG_COMPLEXP r)
	   (result (-> (SG_COMPLEX r) real)))
	  ((SG_REALP r)
	   (result (SG_MAKE_INT 0)))
	  (else
	   ;; never happen
	   (wrong-type-of-argument-violation 'real-part "number required" r))))

  (define-c-proc imag-part (r::number) ::Object
    (cond ((SG_COMPLEXP r)
	   (result (-> (SG_COMPLEX r) imag)))
	  ((SG_REALP r)
	   (result (SG_MAKE_INT 0)))
	  (else
	   (wrong-type-of-argument-violation 'imag-part "number required" r))))

  (define-c-proc magnitude (n::number) ::Object
    (result (Sg_Magnitude n)))

  (define-c-proc angle (n::number) ::Object
    (result (Sg_Angle n)))

  (define-c-proc sin (n::number) ::Object
    (result (Sg_Sin n)))

  (define-c-proc cos (n::number) ::Object
    (result (Sg_Cos n)))

  (define-c-proc tan (n::number) ::Object
    (result (Sg_Tan n)))

  (define-c-proc asin (n::number) ::Object
    (result (Sg_Asin n)))

  (define-c-proc acos (n::number) ::Object
    (result (Sg_Acos n)))

  (define-c-proc atan (n::number) ::Object
    (result (Sg_Atan n)))

  (define-c-proc sqrt (n::number) ::Object
    (result (Sg_Sqrt n)));

  (define-c-proc exact-integer-sqrt (n::number) ::Object
    (when (or (Sg_NegativeP n)
	      (not (SG_EXACT_INTP n)))
      (wrong-type-of-argument-violation 'exact-integer-sqrt "non-negative exact integer required" n))
    (result (Sg_ExactIntegerSqrt n)))
#|
  rationalize
|#
  (define-c-proc quotient (n1::number n2::number) ::Object
    (result (Sg_Quotient n1 n2 NULL)))

  (define-c-proc remainder (n1::number n2::number) ::Object
    (result (Sg_Modulo n1 n2 TRUE)))

  (define-c-proc modulo (n1::number n2::number) ::Object
    (result (Sg_Modulo n1 n2 FALSE)))

  (define-c-proc integer-length (n::number) ::fixnum
    (result (Sg_IntegerLength n)))

  ;; arithmetic bitwise
  (define-c-proc bitwise-not (ei::number) ::Object
    (when (Sg_Exact ei)
      (wrong-type-of-argument-violation 'bitwise-not "exact integer required" ei))
    (result (Sg_LogNot ei)))

  (define-cgen-stmt logop
    ((_ fn x y rest)
     (dispatch
      `(let ((r (,fn ,x ,y)))
	 (for-each (lambda (v) (set! r (,fn r v))) ,rest)
	 (result r)))))

  (define-c-proc bitwise-and (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogAnd ei (SG_CAR rest) (SG_CDR rest))))

  (define-c-proc bitwise-ior (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogIor ei (SG_CAR rest) (SG_CDR rest))))

  (define-c-proc bitwise-xor (ei :rest rest) ::Object
    (if (SG_NULLP rest)
	(result ei)
	(logop Sg_LogXor ei (SG_CAR rest) (SG_CDR rest))))

  (define-cgen-stmt logif
    ((_ n1 n2 n3)
     (dispatch
      `(Sg_LogIor (Sg_LogAnd ,n1 ,n2)
		  (Sg_LogAnd (Sg_LogNot ,n1) ,n3)))))

  (define-c-proc bitwise-if (ei1::number ei2::number ei3::number) ::Object
    (result (logif ei1 ei2 ei3)))

  (define-c-proc bitwise-bit-count (ei::number) ::fixnum
    (result (Sg_BitCount ei)))

  (define-c-proc bitwise-length (ei::number) ::fixnum
    (result (Sg_BitSize ei)))

  (define-c-proc bitwise-first-bit-set (ei::number) ::fixnum
    (result (Sg_FirstBitSet ei)))

  (define-c-proc bitwise-bit-set? (ei1::number ei2::fixnum) ::boolean
    (result (not (Sg_ZeroP (Sg_LogAnd (Sg_Ash (SG_MAKE_INT 1) ei2) ei1)))))

  (define-c-proc bitwise-copy-bit (ei1::number ei2::fixnum ei3::number) ::Object
    (let ((mask (Sg_Ash (SG_MAKE_INT 1) ei2)))
      (result (logif mask (Sg_Ash ei3 ei2) ei1))))

  (define-c-proc bitwise-bit-field (ei1::number ei2::fixnum ei3::fixnum) ::Object
    (when (> ei2 ei3)
      (assertion-violation 'bitwise-bit-field "2nd parameter must be less than or equal to 3rd parameter"
			   (SG_LIST3 ei1 ei2 ei3)))
    (let ((mask (Sg_LogNot (Sg_Ash (SG_MAKE_INT -1) ei3))))
      (result (Sg_Ash (Sg_LogAnd ei1 mask) (- 0 ei2)))))

  (define-c-proc bitwise-copy-bit-field (ei1::number ei2::fixnum ei3::fixnum ei4::number) ::Object
    (let ((to ei1)
	  (start::int ei2)
	  (end::int ei3)
	  (from ei4)
	  (mask1 (Sg_Ash (SG_MAKE_INT -1) start))
	  (mask2 (Sg_LogNot (Sg_Ash (SG_MAKE_INT -1) end)))
	  (mask (Sg_LogAnd mask1 mask2)))
      (result (logif mask (Sg_Ash from start) to))))

  (define-c-proc bitwise-arithmetic-shift (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 ei2)))

  (define-c-proc bitwise-arithmetic-shift-left (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 ei2)))

  (define-c-proc bitwise-arithmetic-shift-right (ei1::number ei2::fixnum) ::Object
    (result (Sg_Ash ei1 (- 0 ei2))))

  ;; arithmetic compare
  (define-cgen-stmt (aref args index)
    (dispatch `(argumentRef ,args ,index)))

  (define-cgen-stmt numcmp
    ((_ op compar)
     (dispatch 
      `(begin 
	 (result FALSE)
	 (loop (cond ((not (,op (,compar arg0 arg1) 0)) (break))
		     ((SG_NULLP rest) (result TRUE) (break))
		     (else (set! arg0 arg1)
			   (set! arg1 (SG_CAR rest))
			   (set! rest (SG_CDR rest)))))))))

  (define-c-proc = (arg0 arg1 :rest rest) ::boolean
    (result (numcmp == Sg_NumEq)))

  (define-c-proc < (arg0 arg1 :rest rest) ::boolean
    (result (numcmp < Sg_NumCmp)))
  (define-c-proc <= (arg0 arg1 :rest rest) ::boolean
    (result (numcmp <= Sg_NumCmp)))
  (define-c-proc > (arg0 arg1 :rest rest) ::boolean
    (result (numcmp > Sg_NumCmp)))
  (define-c-proc >= (arg0 arg1 :rest rest) ::boolean
    (result (numcmp >= Sg_NumCmp)))

  (define-c-proc integer? (o) ::boolean
    (result (Sg_IntegerP o)))

  (define-c-proc number? (o) ::boolean
    (result (SG_NUMBERP o)))

  (define-c-proc real? (o) ::boolean
    (result (SG_REALP o)))

  (define-c-proc complex? (o) ::boolean
    (result (SG_COMPLEXP o)))

  (define-c-proc exact? (o) ::boolean
    (result (Sg_ExactP o)))

  (define-c-proc inexact? (o) ::boolean
    (result (Sg_InexactP o)))

  ;; compare
  (define-c-proc eq? (a b) (inline EQ) ::boolean
    (result (SG_EQ a b)))

  (define-c-proc eqv? (a b) (inline EQV) ::boolean
    (result (Sg_EqvP a b)))

  (define-c-proc equal? (a b) ::boolean
    (result (Sg_EqualP a b)))

  ;; apply
  (define-c-proc apply (proc::Procedure arg1 :rest rest) ::Object
    (let ((head::SgObject '()) (tail::SgObject '()))
      (cond ((SG_NULLP rest) (result (Sg_Apply proc arg1)))
	    (else 
	     (set! head (Sg_Cons arg1 '()))
	     (set! tail head)
	     (dopairs (cp rest)
	       (when (SG_NULLP (SG_CDR cp))
		 (SG_APPEND head tail (SG_CAR cp))
		 (break))
	       (unless (SG_PAIRP (SG_CDR cp))
		 (assertion-violation 'apply "improper list not allowed" (SG_CDR cp)))
	       (SG_APPEND1 head tail (SG_CAR cp)))
	     (result (Sg_Apply proc head))))))

  #;(define-c-proc vm/apply (code :rest rest) ::Object
    (result (Sg_VMApply code rest)))

  ;; io
  (define-c-proc newline (:optional (p::Port (Sg_CurrentOutputPort))) ::void
    (Sg_Putc p #\linefeed))

  (define-c-proc display (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (Sg_Write o p SG_WRITE_DISPLAY))

  (define-c-proc write (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (Sg_Write o p SG_WRITE_WRITE))

  (define-c-proc write/ss (o :optional (p::Port (Sg_CurrentOutputPort))) ::void
    (Sg_Write o p SG_WRITE_SHARED))

  (define-c-proc format (p :rest rest) ::Object
    (cond ((SG_PORTP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (Sg_Format p fmt objs FALSE)
	     (result SG_UNDEF)))
	  ((SG_BOOLP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (if (SG_FALSEP p)
		 (let ((out (Sg_MakeStringOutputPort 16)))
		   (Sg_Format out fmt objs FALSE)
		   (result (Sg_GetStringFromStringPort out)))
		 (let ((out (Sg_CurrentOutputPort)))
		   (Sg_Format out fmt objs FALSE)
		   (result SG_UNDEF)))))
	  ((SG_STRINGP p)
	   (let ((out (Sg_MakeStringOutputPort 16)))
	     (Sg_Format out p rest FALSE)
	     (result (Sg_GetStringFromStringPort out))))))

  ;; port
  (define-c-proc port? (obj) ::boolean
    (result (SG_PORTP obj)))
  (define-c-proc input-port? (obj) ::boolean
    (result (SG_INPORTP obj)))
  (define-c-proc output-port? (obj) ::boolean
    (result (SG_OUTPORTP obj)))

  (define-c-proc open-output-string () ::Object
    (result (Sg_MakeStringOutputPort 32)))

  (define-c-proc get-output-string (p::Port) ::Object
    (result (Sg_GetStringFromStringPort p)))

  (define-c-proc port-has-port-position? (p::Port) ::boolean
    (result (Sg_HasPortPosition p)))

  (define-c-proc port-has-set-port-position!? (p::Port) ::boolean
    (result (Sg_HasSetPortPosition p)))

  (define-c-proc port-position (p::Port) ::Object
    (result (Sg_MakeIntegerFromS64 (Sg_PortPosition p))))

  (define-c-proc set-port-position! (p::Port off::number) ::void
    (Sg_SetPortPosition p (Sg_GetIntegerU64Clamp off SG_CLAMP_NONE NULL)))

  (define-c-proc open-file-input-port (file::String 
				       :optional option
				                 (mode::Symbol 'block)
				                 (transcoder::Transcoder #f))
                                       ::Object
    ;; we can ignore option
    (let ((fo (Sg_OpenFile file SG_READ)))
    ;; TODO mode check
      (if (SG_FALSEP transcoder)
	  (result (Sg_MakeFileBinaryInputPort fo))
	  (let ((in (Sg_MakeFileBinaryInputPort fo)))
	    (result (Sg_MakeTranscodedInputPort in transcoder))))))

  (define-cgen-stmt logor
    ((_ v1 v2 . more)
     (begin
       ((renderer) (format "~a | ~a" v1 v2))
       (if (null? more)
	   #t
	   (let loop ((more more))
	     (unless (null? more)
	       ((renderer) format " | ~a" (car more))
	       (loop (cdr more))))))))

  (define-c-proc open-file-output-port (file::String 
					:optional (option #f)
					          (mode::Symbol 'block)
						  (transcoder::Transcoder #f))
                                       ::Object
    (let ((fo SG_UNDEF)
	  (isFileExist::int (Sg_FileExistP file))
	  (openFlags::int (logor SG_WRITE SG_CREATE)))
      (cond ((SG_FALSEP option)
	     (if isFileExist
		 (assertion-violation 'open-file-output-port "file already exists" file))
	     (set! fo (Sg_OpenFile file openFlags))
	     (result (Sg_MakeFileBinaryOutputPort fo)))
	    (else
	     (unless (SG_INSTANCEP option)
	       (assertion-violation 'open-file-output-port "invalid file options" option))
	     (let ((isEmpty::int (SG_NULLP (Sg_GenericRef option 'options)))
		   (noCreate (Sg_Memq 'no-create (Sg_GenericRef option 'options)))
		   (noTruncate (Sg_Memq 'no-truncate (Sg_GenericRef option 'options)))
		   (noFail (Sg_Memq 'no-fail (Sg_GenericRef option 'options))))
	       (cond ((and isFileExist isEmpty)
		      (assertion-violation 'open-file-output-port "file already exists" file))
		     ((and (not (SG_FALSEP noCreate))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (assertion-violation 'open-file-output-port "file-options no-create: file not exist" file)))
		     ((not (SG_FALSEP noCreate))
		      (if isFileExist
			  (set! openFlags (logor SG_TRUNCATE openFlags))
			  (assertion-violation 'open-file-output-port "file-options no-create: file not exist" file)))
		     ((and (not (SG_FALSEP noFail))
			   (not (SG_FALSEP noTruncate)))
		      (if (not isFileExist)
			  (set! openFlags (logor SG_TRUNCATE openFlags))))
		     ((not (SG_FALSEP noFail))
		      (set! openFlags (logor SG_TRUNCATE openFlags)))
		     ((not (SG_FALSEP noTruncate))
		      (if isFileExist
			  (assertion-violation 'open-file-output-port "File-options no-truncate: file not exist" file)
			  (set! openFlags (logor SG_TRUNCATE openFlags)))))
	       (set! fo (Sg_OpenFile file openFlags))
	       (if (SG_FALSEP transcoder)
		   (result (Sg_MakeFileBinaryOutputPort fo))
		   (let ((out (Sg_MakeFileBinaryOutputPort fo)))
		     (result (Sg_MakeTranscodedOutputPort out transcoder)))))))))
  
  (define-c-proc close-input-port (p::Port) ::void
    (if (not (SG_INPORTP p))
	(wrong-type-of-argument-violation 'close-input-port "input port" p))
    (Sg_ClosePort p))

  (define-c-proc close-output-port (p::Port) ::void
    (if (not (SG_OUTPORTP p))
	(wrong-type-of-argument-violation 'close-output-port "output port" p))
    (Sg_ClosePort p))

  (define-c-proc read (:optional (p (Sg_CurrentInputPort))) ::Object
    (if (not (SG_INPORTP p))
	(wrong-type-of-argument-violation 'read "input port" p))
    (result (Sg_Read p FALSE)))

  (define-c-proc error (who msg :rest irritant) ::void
    (Sg_Error "%S %S %S" who msg irritant))

  (define-c-proc raise (condition) ::Object
    (result (Sg_Raise condition FALSE)))
 
  (define-c-proc raise-continuable (condition) ::Object
    (result (Sg_Raise condition TRUE)))

  ;; transcoder
  (define-c-proc native-transcoder () ::Object
    (result (Sg_MakeNativeTranscoder)))

  ;; list
  (define-c-proc cons (o1 o2) (inline CONS) ::Object
    (result (Sg_Cons o1 o2)))

  (define-c-proc car (o) (inline CAR) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'car "pair" o))
    (result (SG_CAR o)))

  (define-c-proc cdr (o) (inline CDR) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cdr "pair" o))
    (result (SG_CDR o)))

  (define-c-proc caar (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'caar "pair" o))
    (result (SG_CAAR o)))

  (define-c-proc cadr (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cadr "pair" o))
    (result (SG_CADR o)))

  (define-c-proc cdar (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cdar "pair" o))
    (result (SG_CDAR o)))

  (define-c-proc cddr (o) ::Object
    (unless (SG_PAIRP o)
      (wrong-type-of-argument-violation 'cddr "pair" o))
    (result (SG_CDDR o)))

  (define-c-proc acons (a b alist) ::Object
    (result (Sg_Acons a b alist)))

  (define-c-proc cons* (:rest rest) ::Object
    (let ((h '()) (t '()))
      (when (SG_PAIRP rest)
	(dopairs (cp rest)
	  (unless (SG_PAIRP (SG_CDR cp))
	    (if (SG_NULLP h)
		(set! h (SG_CAR cp))
		(SG_SET_CDR t (SG_CAR cp)))
	    (break))
	  (SG_APPEND1 h t (SG_CAR cp))))
      (result h)))

  (define-c-proc list (:rest rest) (inline LIST) ::Object
    (result rest))

  (define-c-proc length (lst) ::fixnum
    (result (Sg_Length lst)))

  (define-c-proc append (:rest lst) ::Object
    (result (Sg_Append lst)))

  (define-c-proc append! (:rest lst) ::Object
    (let ((h '()) (t '()))
      (dopairs (cp lst)
	(when (and (not (SG_PAIRP (SG_CAR cp)))
		   (SG_NULLP (SG_CDR cp)))
	  (if (SG_NULLP h)
	      (set! h (SG_CAR cp))
	      (SG_SET_CDR t (SG_CAR cp)))
	  (break))
	(SG_APPEND h t (SG_CAR cp)))
      (result h)))

  (define-c-proc memq (arg0 arg1) ::Object
    (result (Sg_Memq arg0 arg1)))

  (define-c-proc memv (arg0 arg1) ::Object
    (result (Sg_Memv arg0 arg1)))

  (define-c-proc assq (obj alist) ::Object
    (result (Sg_Assq obj alist)))

  (define-c-proc assv (obj alist) ::Object
    (result (Sg_Assv obj alist)))

  (define-c-proc reverse (lst) ::Object
    (result (Sg_Reverse lst)))

  (define-c-proc set-car! (o v) ::void
    (SG_SET_CAR o v))

  (define-c-proc set-cdr! (o v) ::void
    (SG_SET_CDR o v))

  (define-cgen-stmt do-transpose
    ((_ lst)
     (dispatch
      `(let ((h '())(t '())
	     (count::int (Sg_Length ,lst))
	     (argv (Sg_ListToVector ,lst 0 -1))
	     (lst0 (SG_VECTOR_ELEMENT argv 0)))
	 (dolist (l lst0)
	   (let ((elt (Sg_Cons l '()))
		 (elt_tail elt)
		 (n::int 1))
	     (while (< n count)
	       (SG_SET_CDR elt_tail (Sg_Cons (SG_CAR (SG_VECTOR_ELEMENT argv n)) '()))
	       (set! elt_tail (SG_CDR elt_tail))
	       (set! (SG_VECTOR_ELEMENT argv n)
		     (SG_CDR (SG_VECTOR_ELEMENT argv n)))
	       (set! n (+ n 1)))
	     (SG_APPEND1 h t elt)))
	 (result h)))))

  (define-c-proc list-transpose+ (lst0 :rest rest) ::Object
    (cond ((not (SG_LISTP lst0)) (result #f))
	  (else
	   (let ((each_len::int (Sg_Length lst0)))
	     (dolist (x rest)
	       (if (SG_LISTP x)
		   (unless (not (== (Sg_Length x) each_len))
		     (result #f))
		   (result #f)))
	     (let ((tmp (Sg_Cons lst0 rest)))
	       (do-transpose tmp))))))

  (define-c-proc list-tail (lst k::fixnum :optional fallback) ::Object
    (result (Sg_ListTail lst k fallback)))

  ;; string
  (define-c-proc string-length (s::String) ::fixnum
    (result s->size))

  (define-c-proc string-append (:rest rest) ::Object
    (result (Sg_StringAppend rest)))

  (define-c-proc number->string (z::number
				 :optional (radix::fixnum 10)
				           (precision::fixnum 1)) ::Object
    ;; ignore precision
    (result (Sg_NumberToString z radix FALSE)))

  (define-c-proc string->symbol (z::String) ::Object
    (result (Sg_Intern z)))

  (define-c-proc symbol->string (z::Symbol) ::Object
    (result (-> z name)))

  (define-c-proc string->list (s::String) ::Object
    (result (Sg_StringToList s)))

  (define-c-proc list->string (o) ::Object
    (result (Sg_ListToString o)))

  ;; vector
  (define-c-proc vector (:rest rest) (inline VECTOR) ::Object
    (result (Sg_ListToVector rest 0 -1)))

  (define-c-proc make-vector (size::fixnum :optional (fill SG_UNDEF)) ::Object
    (result (Sg_MakeVector size fill)))

  (define-c-proc vector-length (vec::Vector) (inline VEC_LEN) ::fixnum
    (result (SG_VECTOR_SIZE vec)))

  (define-c-proc vector-ref (vec::Vector i::fixnum :optional fallback) ::Object
    (cond ((or (< i 0)
	       (>= i (SG_VECTOR_SIZE vec)))
	   (when (SG_UNBOUNDP fallback)
	     (assertion-violation 'vector-ref "index out of range" i))
	   (result fallback))
	  (else (result (SG_VECTOR_ELEMENT vec i)))))
     
  (define-c-proc vector-set! (vec::Vector i::fixnum obj) ::void
    (cond ((or (< i 0)
	       (>= i (SG_VECTOR_SIZE vec)))
	   (assertion-violation 'vector-ref "index out of range" i))
	  (else (set! (SG_VECTOR_ELEMENT vec i) obj))))

  (define-c-proc vector->list (vec::Vector :optional (start::fixnum 0) (end::fixnum -1)) ::Object
    (result (Sg_VectorToList vec start end)))
  
  (define-c-proc list->vector (arg0) ::Object
    (result (Sg_ListToVector arg0 0 -1)))

  (define-c-proc vector-fill! (vec::Vector fill) ::Object
    (Sg_VectorFill vec fill 0 -1))

  ;; byte-vector
#|
string->utf8 utf8->string
string->utf16 utf16->string
string->utf32 utf32->string
|#
  (define-c-proc native-endianness () ::Object
    (result (Sg_NativeEndianness)))

  (define-c-proc bytevector=? (bv1::ByteVector bv2::ByteVector) ::boolean
    (result (Sg_ByteVectorEqP bv1 bv2)))

  (define-c-proc bytevector-copy (src::ByteVector) ::Object
    (result (Sg_ByteVectorCopy src)))

  (define-c-proc bytevector-copy! (src::ByteVector sstart::fixnum
				   dst::ByteVector dstart::fixnum
				   k::fixnum) ::void
    (Sg_ByteVectorCopyX src sstart dst dstart k))

  (define-c-proc make-bytevector (len::fixnum :optional (fill::fixnum 0)) ::Object
    (result (Sg_MakeByteVector len fill)))

  (define-c-proc bytevector? (o) ::boolean
    (result (SG_BVECTORP o)))

  (define-c-proc bytevector-length (bv::ByteVector) ::fixnum
    (result (SG_BVECTOR_SIZE bv)))

  (define-c-proc bytevector-fill! (bv::ByteVector fill::fixnum) ::void
    (Sg_ByteVectorFill bv fill))

  (define-c-proc u8-list->bytevector (lst) ::Object
    (result (Sg_ListToByteVector lst 8 FALSE)))

  (define-c-proc bytevector->u8-list (lst) ::Object
    (result (Sg_ByteVectorToList lst 8 FALSE)))

  (define-cgen-stmt bv-check-index
    ((_ bv index)
     (dispatch
      `(unless (> (SG_BVECTOR_SIZE ,bv) ,index)
	 (assertion-violation 'bytevector "index out of range" ,index))))
    ((_ bv index offset)
     (dispatch
      `(let ((len::int (SG_BVECTOR_SIZE ,bv)))
	 (unless (and (> len ,offset)
		      (< ,index (- len ,offset)))
	   (assertion-violation 'bytevector "index out of range" ,index))))))

  (define-c-proc bytevector-u8-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bv index)
    (result (Sg_ByteVectorU8Ref bv index)))

  (define-c-proc bytevector-u8-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bv index)
    (unless (SG_IS_OCTET value)
      (assertion-violation 'bytevector-u8-set! "value out of range. must be 0 <= value <= 255" value))
    (Sg_ByteVectorU8Set bv index value))

  (define-c-proc bytevector-s8-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bv index)
    (result (Sg_ByteVectorS8Ref bv index)))

  (define-c-proc bytevector-s8-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bv index)
    (unless (SG_IS_BYTE value)
      (assertion-violation 'bytevector-s8-set! "value out of range. must be -127 <= value <= 128" value))
    (Sg_ByteVectorS8Set bv index value))

  (define-cgen-stmt bv-check-align
    ((_ index align)
     (dispatch
      `(unless (== (% ,index ,align) 0)
	 (assertion-violation 'bytevector "index not aligned" ,index)))))

  (define-cgen-stmt bv-check-value
    ((_ value min max)
     (dispatch
      `(unless (and (<= ,min ,value)
		    (<= ,value ,max))
	 (assertion-violation 'bytevector "value out of range %S" ,value)))))
  ;; u16
  (define-c-proc bytevector-u16-native-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bv index 1)
    (bv-check-align index 2)
    (result (Sg_ByteVectorU16NativeRef bv index)))

  (define-c-proc bytevector-u16-native-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bv index 1)
    (bv-check-value value 0 #xFFFF)
    (Sg_ByteVectorU16NativeSet bv index value))

  (define-c-proc bytevector-u16-ref (bv::ByteVector index::fixnum endian::Symbol) ::fixnum
    (bv-check-index bv index 1)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_ByteVectorU16BigRef bv index)))
	  ((SG_EQ endian 'little)
	   (result (Sg_ByteVectorU16LittleRef bv index)))
	  (else
	   (assertion-violation 'bytevector-u16-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u16-set! (bv::ByteVector index::fixnum value::fixnum endian::Symbol) ::void
    (bv-check-index bv index 1)
    (bv-check-value value 0 #xFFFF)
    (cond ((SG_EQ endian 'big)
	   (Sg_ByteVectorU16BigSet bv index value))
	  ((SG_EQ endian 'little)
	   (Sg_ByteVectorU16LittleSet bv index value))
	  (else
	   (assertion-violation 'bytevector-u16-set! "unsupported endianness" endian))))

  ;; s16
  (define-c-proc bytevector-s16-native-ref (bv::ByteVector index::fixnum) ::fixnum
    (bv-check-index bv index 1)
    (bv-check-align index 2)
    (result (Sg_ByteVectorS16NativeRef bv index)))

  (define-c-proc bytevector-s16-native-set! (bv::ByteVector index::fixnum value::fixnum) ::void
    (bv-check-index bv index 1)
    (bv-check-value value #x-8000 #x7FFF)
    (Sg_ByteVectorS16NativeSet bv index value))

  (define-c-proc bytevector-s16-ref (bv::ByteVector index::fixnum endian::Symbol) ::fixnum
    (bv-check-index bv index 1)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_ByteVectorS16BigRef bv index)))
	  ((SG_EQ endian 'little)
	   (result (Sg_ByteVectorS16LittleRef bv index)))
	  (else
	   (assertion-violation 'bytevector-s16-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s16-set! (bv::ByteVector index::fixnum value::fixnum endian::Symbol) ::void
    (bv-check-index bv index 1)
    (bv-check-value value #x-8000 #x7FFF)
    (cond ((SG_EQ endian 'big)
	   (Sg_ByteVectorS16BigSet bv index value))
	  ((SG_EQ endian 'little)
	   (Sg_ByteVectorS16LittleSet bv index value))
	  (else
	   (assertion-violation 'bytevector-s16-set! "unsupported endianness" endian))))

  ;; u32
  (define-c-proc bytevector-u32-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 3)
    (bv-check-align index 4)
    (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32NativeRef bv index))))

  (define-c-proc bytevector-u32-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 3)
    (let ((value::uint32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u32-native-set! "value out of range" v))
	     (set! value (cast uint32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u32-native-set! "exact integer" v)))
      (Sg_ByteVectorU32NativeSet bv index value)))

  (define-c-proc bytevector-u32-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromU32 (Sg_ByteVectorU32LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-u32-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u32-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 3)
    (let ((value::uint32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u32-set! "value out of range" v))
	     (set! value (cast uint32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u32-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorU32BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorU32LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-u32-set! "unsupported endianness" endian)))))
  ;; s32
  (define-c-proc bytevector-s32-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 3)
    (bv-check-align index 4)
    (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32NativeRef bv index))))

  (define-c-proc bytevector-s32-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 3)
    (let ((value::int32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s32-native-set! "value out of range" v))
	     (set! value (cast int32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s32-native-set! "exact integer" v)))
      (Sg_ByteVectorS32NativeSet bv index value)))

  (define-c-proc bytevector-s32-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromS32 (Sg_ByteVectorS32LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-s32-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s32-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 3)
    (let ((value::int32_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s32-set! "value out of range" v))
	     (set! value (cast int32_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS32 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s32-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorS32BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorS32LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-s32-set! "unsupported endianness" endian)))))
  ;; u64
  (define-c-proc bytevector-u64-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 7)
    (bv-check-align index 8)
    (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64NativeRef bv index))))

  (define-c-proc bytevector-u64-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 7)
    (let ((value::uint64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u64-native-set! "value out of range" v))
	     (set! value (cast uint64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u64-native-set! "exact integer" v)))
      (Sg_ByteVectorU64NativeSet bv index value)))

  (define-c-proc bytevector-u64-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromU64 (Sg_ByteVectorU64LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-u64-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-u64-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 7)
    (let ((value::uint64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-u64-set!  "value out of range" v))
	     (set! value (cast uint64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToU64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-u64-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorU64BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorU64LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-u64-set! "unsupported endianness" endian)))))
  ;; s64
  (define-c-proc bytevector-s64-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 7)
    (bv-check-align index 8)
    (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64NativeRef bv index))))

  (define-c-proc bytevector-s64-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 7)
    (let ((value::int64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s64-native-set! "value out of range" v))
	     (set! value (cast int64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s64-native-set! "exact integer" v)))
      (Sg_ByteVectorS64NativeSet bv index value)))

  (define-c-proc bytevector-s64-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64BigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeIntegerFromS64 (Sg_ByteVectorS64LittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-s64-ref "unsupported endianness" endian))))

  (define-c-proc bytevector-s64-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 7)
    (let ((value::int64_t 0))
      (cond ((SG_INTP v)
	     (when (< (SG_INT_VALUE v) 0)
	       (assertion-violation 'bytevector-s64-set! "value out of range" v))
	     (set! value (cast int64_t (SG_INT_VALUE v))))
	    ((SG_BIGNUMP v)
	     (set! value (Sg_BignumToS64 v SG_CLAMP_NONE NULL)))
	    (else
	     (wrong-type-of-argument-violation 'bytevector-s64-set! "exact integer" v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorS64BigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorS64LittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-s64-set! "unsupported endianness" endian)))))
  ;; ieee util
  (define-cgen-stmt check-real
    ((_ o)
     (dispatch
      `(unless (SG_REALP ,o)
	 (wrong-type-of-argument-violation 'bytevector "real number" ,o)))))

  ;; ieee-single
  (define-c-proc bytevector-ieee-single-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 3)
    (bv-check-align index 4)
    (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleNativeRef bv index))))

  (define-c-proc bytevector-ieee-single-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 3)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleBigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEESingleLittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-ieee-single-ref "unsupported endianness" endian))))
  
  (define-c-proc bytevector-ieee-single-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 3)
    (bv-check-align index 4)
    (check-real v)
    (let ((value::double (Sg_GetDouble v)))
      (Sg_ByteVectorIEEESingleNativeSet bv index (cast float value))))

  (define-c-proc bytevector-ieee-single-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 3)
    (check-real v)
    (let ((value::double (Sg_GetDouble v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorIEEESingleBigSet bv index (cast float value)))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorIEEESingleLittleSet bv index (cast float value)))
	    (else
	     (assertion-violation 'bytevector-ieee-single-set! "unsupported endianness" endian)))))
  ;; ieee-double
  (define-c-proc bytevector-ieee-double-native-ref (bv::ByteVector index::fixnum) ::Object
    (bv-check-index bv index 7)
    (bv-check-align index 8)
    (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleNativeRef bv index))))

  (define-c-proc bytevector-ieee-double-ref (bv::ByteVector index::fixnum endian::Symbol) ::Object
    (bv-check-index bv index 7)
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleBigRef bv index))))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeFlonum (Sg_ByteVectorIEEEDoubleLittleRef bv index))))
	  (else
	   (assertion-violation 'bytevector-ieee-double-ref "unsupported endianness" endian))))
  
  (define-c-proc bytevector-ieee-double-native-set! (bv::ByteVector index::fixnum v::number) ::void
    (bv-check-index bv index 7)
    (bv-check-align index 8)
    (check-real v)
    (let ((value::double (Sg_GetDouble v)))
      (Sg_ByteVectorIEEEDoubleNativeSet bv index value)))

  (define-c-proc bytevector-ieee-double-set! (bv::ByteVector index::fixnum v::number endian::Symbol) ::void
    (bv-check-index bv index 7)
    (check-real v)
    (let ((value::double (Sg_GetDouble v)))
      (cond ((SG_EQ endian 'big)
	     (Sg_ByteVectorIEEEDoubleBigSet bv index value))
	    ((SG_EQ endian 'little)
	     (Sg_ByteVectorIEEEDoubleLittleSet bv index value))
	    (else
	     (assertion-violation 'bytevector-ieee-double-set! "unsupported endianness" endian)))))

  ;; converter
  ;; utf8 <-> string
  (define-c-proc utf8->string (bv::ByteVector) ::Object
    (let ((transcoder (Sg_MakeTranscoder (Sg_MakeUtf8Codec) LF SG_REPLACE_ERROR)))
      (result (Sg_ByteVectorToString bv transcoder 0 -1))))

  (define-c-proc string->utf8 (s::String) ::Object
    (let ((transcoder (Sg_MakeTranscoder (Sg_MakeUtf8Codec) LF SG_REPLACE_ERROR)))
      (result (Sg_StringToByteVector s transcoder 0 -1))))

  ;; utf16 <-> string
  (define-c-proc utf16->string (bv::ByteVector endian::Symbol :optional mandatory) ::Object
    (let ((endianness::Endianness NO_BOM)
	  (skipBOM::int FALSE))
      (when (SG_UNBOUNDP mandatory)
	(set! endianness (Sg_Utf16CheckBOM bv))
	(if (not (== endianness NO_BOM))
	    (set! skipBOM TRUE)))
      (when (or (not (SG_FALSEP mandatory))
		(== endianness  NO_BOM))
	(cond ((SG_EQ endian 'little)
	       (set! endianness UTF_16LE))
	      ((SG_EQ endian 'big)
	       (set! endianness UTF_16BE))
	      (else
	       (assertion-violation 'bytevector-ieee-double-set! "endianness should be little or big" endian))))
      (let ((skipSize::int 0)
	    (codec SG_UNDEF)
	    (transcoder SG_UNDEF))
	(if skipBOM
	    (set! skipSize 2))
	(set! codec (Sg_MakeUtf16Codec endianness))
	(set! transcoder (Sg_MakeTranscoder codec LF SG_REPLACE_ERROR))
	;; TODO guard
	(result (Sg_ByteVectorToString bv transcoder skipSize (- (SG_BVECTOR_SIZE bv) skipSize))))))

  (define-c-proc string->utf16 (s::String :optional (endian::Symbol SG_UNBOUND)) ::Object
    (let ((endianness::Endianness UTF_16BE))
      (if (not (SG_UNBOUNDP endian))
	  (cond ((SG_EQ endian 'little)
		 (set! endianness UTF_16LE))
		((SG_EQ endian 'big)
		 (set! endianness UTF_16BE))
		(else
		 (assertion-violation 'bytevector-ieee-double-set! "endianness should be little or big"  endian))))
      (result (Sg_StringToByteVector s (Sg_MakeTranscoder (Sg_MakeUtf16Codec endianness)
							  LF
							  SG_REPLACE_ERROR)
				     0 -1))))
  
  ;; conditions
  (define-c-proc vector? (arg0::Object) (inline VECTORP) ::boolean
    (result (SG_VECTORP arg0)))

  (define-c-proc null? (arg0::Object) (inline NULLP) ::boolean
    (result (SG_NULLP arg0)))

  (define-c-proc list? (arg0::Object) ::boolean
    (result (SG_PROPER_LISTP arg0)))

  (define-c-proc symbol? (arg0::Object) ::boolean
    (result (SG_SYMBOLP arg0)))

  (define-c-proc pair? (arg0::Object) ::boolean
    (result (SG_PAIRP arg0)))

  (define-c-proc eof-object? (o) ::boolean
    (result (SG_EOFP o)))

  (define-c-proc keyword? (o) ::boolean
    (result (SG_KEYWORDP o)))

  (define-c-proc not (arg0) ::boolean
    (result (SG_FALSEP arg0)))

  ;; hashtable
  (define-c-proc make-eq-hashtable () ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_EQ 200)))

  (define-c-proc make-eqv-hashtable () ::Object
    (result (Sg_MakeHashTableSimple SG_HASH_EQV 200)))

  (define-c-proc hashtable-ref (ht::HashTable key fallback) ::Object
    (result (Sg_HashTableRef ht key fallback)))

  (define-c-proc hashtable-set! (ht::HashTable key value) ::void
    (result (Sg_HashTableSet ht key value 0)))

  (define-c-proc hashtable-keys (ht::HashTable) ::Object
    (result (Sg_HashTableKeys ht)))

  (define-c-proc hashtable-values (ht::HashTable) ::Object
    (result (Sg_HashTableValues ht)))

  ;; call/cc
  (define-c-proc call/cc (proc::Procedure) ::Object
    (result (Sg_VMCallCC proc)))
  
  (define-c-proc call-with-current-continuation (proc::Procedure) ::Object
    (result (Sg_VMCallCC proc)))

  (define-c-proc dynamic-wind (before thunk after) ::Object
    (result (Sg_VMDynamicWind before thunk after)))

  (define-c-proc current-exception-handler () ::Object
    (result (-> (Sg_VM) exceptionHandler)))

  (define-c-proc with-exception-handler (handler thunk) ::Object
    (result (Sg_VMWithExceptionHandler handler thunk)))

  ;; conditions
  (define-c-proc condition (:rest components) ::Object
    (result (Sg_Condition components)))

  (define-c-proc simple-conditions (obj) ::Object
    (result (Sg_SimpleConditions obj)))

  (define-c-proc compound-condition-component (obj) ::Object
    (result (Sg_CompoundConditionComponent obj)))

  (define-c-proc compound-condition? (obj) ::boolean
    (result (Sg_CompoundConditionP obj)))

  (define-c-proc simple-condition? (obj) ::boolean
    (result (Sg_SimpleConditionP obj)))
  
  (define-c-proc condition? (obj) ::boolean
    (result (Sg_ConditionP obj)))

  (define-c-proc condition-predicate (rtd) ::Object
    (result (Sg_ConditionPredicate rtd)))

  (define-c-proc condition-accessor (rtd proc) ::Object
    (result (Sg_ConditionAccessor rtd proc)))

  ;; record
  (define-c-proc make-record-type (name::Symbol rtd rcd) ::Object
    (result (Sg_MakeRecordType name rtd rcd)))

  (define-c-proc record-type-rtd (rt::RecordType) ::Object
    (result (SG_RECORD_TYPE_RTD rt)))

  (define-c-proc record-type-rcd (rt::RecordType) ::Object
    (result (SG_RECORD_TYPE_RCD rt)))

  (define-c-proc make-record-type-descriptor
    (name::Symbol parent uid sealedP::boolean opaqueP::boolean fields::Vector) ::Object
    (result (Sg_MakeRecordTypeDescriptor name parent uid sealedP opaqueP fields)))

  (define-c-proc make-record-constructor-descriptor (rtd parent protocol) ::Object
    (result (Sg_MakeRecordConstructorDescriptor rtd parent protocol)))

  (define-c-proc record? (o) ::boolean
    (result (Sg_RecordP o)))

  (define-c-proc record-rtd (o) ::Object
    (result (Sg_RecordRtd o)))

  (define-c-proc record-type-descriptor? (o) ::boolean
    (result (Sg_RecordTypeDescriptorP o)))

  (define-c-proc record-constructor-descriptor? (o) ::boolean
    (result (Sg_RecordConstructorDescriptorP o)))

  (define-c-proc record-constructor (rcd) ::Object
    (result (Sg_RecordConstructor rcd)))

  (define-c-proc record-accessor (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-accessor "record-type-descriptor" rtd (SG_LIST2 rtd (SG_MAKE_INT k))))
    (unless (and (< -1 k)
		 (< k (Sg_Length (Sg_RtdFields rtd))))
      (assertion-violation 'record-accessor "field index out of range"))
    (result (Sg_RecordAccessor rtd k)))

  (define-c-proc record-predicate (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-predicate "record-type-descriptor" rtd))
    (result (Sg_RecordPredicate rtd)))

  (define-c-proc record-mutator (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-mutator "record-type-descriptor" rtd (SG_LIST2 rtd (SG_MAKE_INT k))))
    (unless (and (< -1 k)
		 (< k (Sg_Length (Sg_RtdFields rtd))))
      (assertion-violation 'record-mutator "field index out of range" (SG_LIST2 rtd (SG_MAKE_INT k))))
    (when (SG_FALSEP (SG_CAR (Sg_ListRef (Sg_RtdFields rtd) k SG_UNBOUND)))
      (assertion-violation 'record-mutator "specified field is immutable" (SG_LIST2 rtd (SG_MAKE_INT k))))
    (result (Sg_RecordMutator rtd k)))

  (define-c-proc record-type-name (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdName rtd)))

  (define-c-proc record-type-parent (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdParent rtd)))

  (define-c-proc record-type-uid (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdUid rtd)))

  (define-c-proc record-type-generative? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (not (SG_FALSEP (Sg_RtdUid rtd)))))

  (define-c-proc record-type-opaque? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdOpaqueP rtd)))

  (define-c-proc record-type-sealed? (rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
	(wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdSealedP rtd)))
  ;; for convenience, it returns list
  (define-c-proc rtd-fields (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdFields rtd)))

  (define-c-proc record-type-field-names (rtd) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (let ((fields (Sg_RtdFields rtd))
	  (h '())
	  (t '()))
      (dolist (field fields)
	(SG_APPEND1 h t field))
      (result (Sg_ListToVector h 0 -1))))

  (define-c-proc record-field-mutable? (rtd k::fixnum) ::Object
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (SG_CAR (Sg_ListRef (Sg_RtdFields rtd) k SG_UNBOUND))))

  (define-c-proc rtd-inherited-field-count (rtd) ::fixnum
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdInheritedFieldCount rtd)))

  (define-c-proc rtd-total-field-count (rtd) ::fixnum
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd))
    (result (Sg_RtdTotalFieldCount rtd)))

  (define-c-proc rtd-ancestor? (parent rtd) ::boolean
    (unless (Sg_RecordTypeDescriptorP rtd)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" rtd (SG_LIST2 parent rtd)))
    (unless (Sg_RecordTypeDescriptorP parent)
      (wrong-type-of-argument-violation 'record-type-name "record-type-descriptor" parent (SG_LIST2 parent rtd)))
    (result (Sg_RtdAncestorP parent rtd)))

  (define-c-proc rcd-protocol (rcd) ::Object
    (result (Sg_RcdProtocol rcd)))

  (define-c-proc rcd-parent (rcd) ::Object
    (result (Sg_RcdParent rcd)))

  ;; tuple of record helper
  (define-c-proc make-tuple (size::fixnum printer) ::Object
    (result (Sg_MakeTuple size SG_UNDEF printer)))

  (define-c-proc tuple-list-set! (tuple lst) ::void
    (Sg_TupleListSet tuple lst))

  (define-c-proc tuple-ref (tuple i::fixnum) ::Object
    (result (Sg_TupleRef tuple i SG_FALSE)))

  (define-c-proc ruple-set! (tuple i::fixnum value) ::void
    (Sg_TupleSet tuple i value))

  ;; misc
  (define-c-proc unbound () ::Object
    (result SG_UNBOUND))

  (define-c-proc undefined () ::Object
    (result SG_UNDEF))

  (define-c-proc undefined? (o) ::boolean
    (result (SG_UNDEFP o)))

  (define-c-proc add-load-path (path::String) ::Object
    (result (Sg_AddLoadPath path)))

  (define-c-proc gensym (:optional (prefix::String NULL)) ::Object
    (result (Sg_Gensym prefix)))
  )
