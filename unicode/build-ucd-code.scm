;; -*- scheme -*-
;; the input files are alist of pairs.
;; so we make struct for the pairs likes this:
;; struct {
;;    SgChar in;
;;    SgChar out;
;; } simple_lower_case[10] = {
;;    { 111, 113 }, // so on
;; }
(import (rnrs)
	(srfi :13))

(define (input-file-path f)
  (format "ucd/~a.datum" f))

(define (output-file-path f)
  (format "~a.inc" f))

(define (write-head out struct datum)
  (format out
"
/* -*- C -*-
   This file was generated by build-ucd-code.scm. DO NOT EDIT!
 */
static struct {
  SgChar in;
  SgChar out;
} ~a[~a] = {~%" struct (length datum)))

(define (write-foot out)
  (display
"};
" 
out))

(define (generate-struct-name file)
  (format "s_~a" (string-map (lambda (ch)
			       (if (char=? ch #\-)
				   #\_
				   ch))
			     file)))


(define (convert file)
  (let* ((in (open-file-input-port (input-file-path file)
				   (file-options no-truncate)
				   'block
				   (native-transcoder)))
	 (datum (read in)))
    (close-port in)
    (delete-file (output-file-path file))
    (call-with-output-file (output-file-path file)
      (lambda (out)
	(define (c-out datum)
	  (cond ((number? datum) (format "~aL" datum))
		((boolean? datum)
		 (if datum 'TRUE 'FALSE))
		((symbol? datum) datum)
		(else
		 (error 'convert "unknown datum" datum))))
	(write-head out (generate-struct-name file) datum)
	(for-each (lambda (p)
		    (format out "  { ~a, ~a },~%" 
			    (c-out (car p))
			    (c-out (cdr p))))
		  datum)
	(write-foot out)))))


;(convert "case-folding")
(convert "numeric-property")
(convert "other-alphabetic")
(convert "other-lowercase")
(convert "other-uppercase")
(convert "simple-lowercase")
(convert "simple-titlecase")
(convert "simple-uppercase")
;(convert "special-casing-lower")
;(convert "special-casing-title")
;(convert "special-casing-upper")
(convert "canonical-class")
;(convert "decompose")
(convert "compose")
(convert "compatibility")

(convert "general-category-1")
(convert "general-category-2")