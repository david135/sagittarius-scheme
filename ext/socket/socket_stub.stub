;; -*- scheme -*-
#!compatible
(decl-code
 (.include <sagittarius.h>)
 (.define "LIBSAGITTARIUS_EXT_BODY")
 (.include <sagittarius/extend.h>
	   "socket.h"))

(define-cise-stmt check-string-or-false
  ((_ name o)
   `(unless (or (SG_STRINGP ,o)
		(SG_FALSEP ,o))
      (Sg_WrongTypeOfArgumentViolation ',name
				       (SG_MAKE_STRING "string or #f")
				       ,o
				       '()))))

(define-type <socket> "SgSocket*")

(define-c-proc make-client-socket 
  (node service :optional
	(ai_family::<fixnum> (SG_MAKE_INT AF_INET))
	(ai_socktype::<fixnum> (SG_MAKE_INT SOCK_STREAM))
	(ai_flags::<fixnum> (SG_MAKE_INT (+ AI_V4MAPPED AI_ADDRCONFIG)))
	(ai_protocol::<fixnum> 0))
  
  (check-string-or-false make-client-socket node)
  (check-string-or-false make-client-socket service)
  (when (SG_FALSEP node)
    (set! node NULL))
  (when (SG_FALSEP service)
    (set! service NULL))
  (let ((sock (Sg_CreateClientSocket (SG_STRING node)
				     (SG_STRING service)
				     ai_family
				     ai_socktype
				     ai_flags
				     ai_protocol)))
    (if (Sg_SocketOpenP (SG_SOCKET sock))
	(result sock)
	(Sg_IOError (cast SgIOErrorType -1) 'make-client-socket
		    (Sg_GetLastErrorMessageWithErrorCode
		     (-> (SG_SOCKET sock) lastError))
		    #f (SG_LIST2 node service)))))

(define-c-proc make-server-socket 
  (service :optional
	   (ai_family::<fixnum> (SG_MAKE_INT AF_INET))
	   (ai_socktype::<fixnum> (SG_MAKE_INT SOCK_STREAM))
	   (ai_protocol::<fixnum> 0))
  (check-string-or-false make-server-socket service)
  (when (SG_FALSEP service)
    (set! service NULL))
  (let ((sock (Sg_CreateServerSocket (SG_STRING service)
				     ai_family ai_socktype ai_protocol)))
    (if (Sg_SocketOpenP (SG_SOCKET sock))
	(result sock)
	(Sg_IOError (cast SgIOErrorType -1)
		    'make-server-socket
		    (Sg_GetLastErrorMessageWithErrorCode 
		     (-> (SG_SOCKET sock) lastError))
		    #f service))))

(define-c-proc socket? (o) ::<boolean>
  (result (SG_SOCKETP o)))

(define-c-proc socket-port (o::<socket>) 
  (result (Sg_MakeSocketPort (SG_SOCKET o))))

(define-c-proc shutdown-output-port (o::<port>) ::<void>
  (Sg_ShutdownPort o))

(define-c-proc socket-accept (o::<socket>) 
  (result (Sg_SocketAccept (SG_SOCKET o))))

(define-c-proc socket-send
  (o::<socket> bv::<bytevector> :optional (flags::<fixnum> 0)) ::<fixnum>
  (result (Sg_SocketSend (SG_SOCKET o)
			 (SG_BVECTOR_ELEMENTS bv)
			 (SG_BVECTOR_SIZE bv)
			 flags)))

(define-c-proc socket-recv (o::<socket> len::<fixnum>
					:optional (flags::<fixnum> 0)) 
  (let ((data (Sg_MakeByteVector len 0))
	(res::int (Sg_SocketReceive (SG_SOCKET o)
				    (SG_BVECTOR_ELEMENTS data) len flags)))
    (cond ((== len res) (result data))
	  ((< res 0)
	   ;; most probably socket is non-blocking
	   (result #f))
	  (else
	   ;; shrink
	   (let ((r (Sg_MakeByteVector res 0)))
	     (Sg_ByteVectorCopyX (SG_BVECTOR data) 0 (SG_BVECTOR r) 0 res)
	     (result r))))))

(define-c-proc socket-shutdown (o::<socket> how::<fixnum>) ::<void>
  (Sg_SocketShutdown (SG_SOCKET o) how))

(define-c-proc socket-close  (o::<socket>) ::<void>
  (Sg_SocketClose (SG_SOCKET o)))

(define-c-proc socket-fd (o::<socket>) ::<fixnum>
  (result (-> o socket)))

(define-c-proc socket-nonblocking! (o::<socket>) ::<boolean>
  Sg_SocketNonblocking)
(define-c-proc socket-blocking! (o::<socket>) ::<boolean>
  Sg_SocketBlocking)
