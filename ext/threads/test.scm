;; -*- scheme -*-

;; testing mutil thread
;; this file will be called from one upper
;; so load path must be like this
(add-load-path "./threads/")
(library (threads test)
    (export run-threads-test)
    (import (srfi :64 testing)
	    (rnrs)
	    (sagittarius threads))

  (define (run-threads-test)
    (let ((t (make-thread (lambda () 'thread-1)
			  'thread-1)))
      (test-assert 'thread? (thread? t))
      (test-equal "thread name" (thread-name t) 'thread-1)
      (test-equal "thread state new" (thread-state t) 'new)
      (let ((t (thread-start! t)))
	(test-assert "thread-start" (thread? t))
	(thread-join! t) ;; just in case
	(test-equal "thread state terminated" (thread-state t) 'terminated)))

    (let ((m (make-mutex 'mutex-1)))
      (test-assert 'mutex? (mutex? m))
      (test-equal "mutex name" (mutex-name m) 'mutex-1)
      (mutex-specific-set! m 'specific-data)
      (test-equal "mutex specific" (mutex-specific m) 'specific-data)
      (test-equal "mutex state" (mutex-state m) 'not-abandoned)
      (test-assert "mutex locked" (mutex-lock! m))
      (test-assert "mutex state" (thread? (mutex-state m)))
      (test-equal "mutex state 2" (mutex-state m) (current-thread))
      (test-assert "mutex unlocked" (mutex-unlock! m))
      )

    (test-equal "lock and unlock - blocking (simple spin-lock)" 
		'((put a) (get a) (put b) (get b) (put c) (get c))
		(let ((log '())
		      (cell #f)
		      (m (make-mutex)))
		  (define (put! msg)
		    (mutex-lock! m)
		    (if cell
			(begin (mutex-unlock! m) (put! msg))
			(begin (set! cell msg)
			       (set! log (cons `(put ,msg) log))
			       (mutex-unlock! m))))
		  (define (get!)
		    (mutex-lock! m)
		    (if cell
			(let ((r cell))
			  (set! cell #f)
			  (set! log (cons `(get ,r) log))
			  (mutex-unlock! m)
			  r)
			(begin (mutex-unlock! m) (get!))))
		  (define (producer)
		    (put! 'a)
		    (put! 'b)
		    (put! 'c))
		  (define (consumer)
		    (get!)
		    (get!)
		    (get!))
		  (let ((tp (thread-start! (make-thread producer 'producer)))
			(tc (thread-start! (make-thread consumer 'consumer))))
		    (thread-join! tp)
		    (thread-join! tc)
		    (reverse log))))
    )
)