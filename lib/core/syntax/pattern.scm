;; -*- scheme -*-
(library (core syntax pattern)
    (export :all)
    (import (core)
	    (core base)
	    (core errors)
	    ;;(trace)
	    (sagittarius))

  (define (id-memq id lst)
    (if (identifier? id)
	(memq (id-name id) lst)
	(memq id lst)))

  ;; (p ...)
  (define (ellipsis-pair? form rename compare)
    (and (pair? form)
	 (pair? (cdr form))
	 (compare (cadr form) (rename '...))))

  ;; (p ... ...)
  (define (ellipsis-splicing-pair? form rename compare)
    (let ((ellipsis (rename '...)))
      (and (pair? form)
	   (pair? (cdr form))
	   (compare (cadr form) ellipsis)
	   (pair? (cddr form))
	   (compare (caddr form) ellipsis))))

  ;; (... p)
  (define (ellipsis-quote? form rename compare)
    (and (pair? form)
	 (compare (car form) (rename '...))
	 (pair? (cdr form))
	 (null? (cddr form))))

  ;; exclude '...
  (define (collect-unique-ids expr rename compare)
    (let loop ((lst expr) (ans '()))
      (cond ((pair? lst)
	     (loop (cdr lst)
		   (loop (car lst) ans)))
	    ((compare lst (rename '...)) ans)
	    ((variable? lst)
	     (if (id-memq lst ans) ans (cons lst ans)))
	    ((vector? lst)
	     (loop (vector->list lst) ans))
	    (else ans))))

  ;; this returns pattern alist of variable name and its depth.
  ;; we also need expression for template, so result alist will
  ;; be like this:
  ;; ((pvar expr . rank) ...)
  (define (collect-vars-ranks pat tmpl lites depth ranks rename compare)
    (define (rec pat expr lites depth ranks)
      (cond ((compare pat (rename '_)) ranks)
	    ((variable? pat)
	     (if (id-memq pat lites)
		 ranks
		 (acons pat (cons expr depth) ranks)))
	    ((ellipsis-pair? pat rename compare)
	     (rec (cddr pat) `(,(rename 'cddr) ,expr) lites depth
		  (if (variable? (car pat))
		      (acons (car pat) (cons expr (+ depth 1)) ranks)
		      (rec (car pat) `(,(rename 'car) ,expr) lites (+ depth 1) ranks))))
	    ((pair? pat)
	     (rec (cdr pat) `(,(rename 'cdr) ,expr) lites depth
		  (rec (car pat) `(,(rename 'car) ,expr) lites depth ranks)))
	    ((vector? pat)
	     (rec (vector->list pat) expr lites depth ranks))
	    (else ranks)))
    (rec pat tmpl lites depth ranks))

  (define (check-pattern pat lites rename compare)
    (let ((ellipsis (rename '...)))
      (define (check-duplicate-variable pat lites)
	(let loop ((lst pat) (pool '()))
	  (cond ((pair? lst)
		 (loop (cdr lst)
		       (loop (car lst) pool)))
		((compare lst ellipsis) pool)
		((compare lst (rename '_)) pool)
		((variable? lst)
		 (if (id-memq lst lites)
		     pool
		     (if (id-memq lst pool)
			 (syntax-violation "syntax pattern" "duplicate pattern variabl?" pat lst)
			 (cons lst pool))))
		((vector? lst)
		 (loop (vector->list lst) pool))
		(else pool))))
      (define (check-misplaced-ellipsis pat lite)
	(let loop ((lst pat))
	  (cond ((compare lst ellipsis)
		 (syntax-violation "syntax pattern" "improper use of ellipsis" pat))
		((ellipsis-pair? lst rename compare)
		 (and (variable? (car lst))
		      (id-memq (car lst) lites)
		      (syntax-violation "syntax pattern" "ellipsis following literal" pat lst))
		 (let loop ((lst (cddr lst)))
		   (and (pair? lst)
			(if (compare (car lst) ellipsis)
			    (syntax-violation "syntax pattern" "ambiguous use of ellipsis" pat)
			    (loop (cdr lst))))))
		((pair? lst)
		 (or (loop (car lst)) (loop (cdr lst))))
		((vector? lst)
		 (loop (vector->list lst)))
		(else #f))))
      (check-misplaced-ellipsis pat lites)
      (check-duplicate-variable pat lites)))
  
  ;; generate match
  (define (generate-match pattern literals rename compare expr)
    (let ((_if (rename 'if))    (_loop (rename 'loop))
	  (_let (rename 'let))  (_cdr (rename 'cdr))
	  (_car (rename 'car))  (_quote (rename 'quote))
	  (_lambda (rename 'lambda)) (_l (rename 'l))
	  (_letrec (rename 'letrec)) (_null? (rename 'null?))
	  (_pair? (rename 'pair?)) (_temp (rename 'temp))
	  (_vector? (rename 'vector?)) (_equal? (rename 'equal?))
	  (_or (rename 'or))    (_symbol? (rename 'symbol?))
	  (_list? (rename 'list?)) (_> (rename '>))
	  (_and (rename 'and))   (_n (rename 'n))
	  (_- (rename '-))      (_= (rename '=))
	  (_identifier? (rename 'identifier?))
	  (_rename (rename 'rename)) (_compare (rename 'compare)))
      (define (conjunction predicate consequent)
	(cond ((eq? predicate #t) consequent)
	      ((eq? consequent #t) predicate)
	      (else `(,_if ,predicate
			   ,consequent #f))))
      ;; match ellipsis
      (define (do-list pattern expr)
	`(,_letrec ((,_loop (,_lambda (,_l)
				(,_if (,_null? ,_l)
				      #t
				      (,_and (,_pair? ,_l)
					     ,(loop pattern `(,_car ,_l))
					     (,_loop (,_cdr ,_l)))))))
	     (,_loop ,expr)))
      (define (do-list-n pattern expr)
	`(,_letrec ((,_loop (,_lambda (,_l ,_n)
				(,_if (,_= ,_n 0)
				      #t
				      ,(conjunction
					`(,_pair? ,_l)
					(conjunction
					 (loop (car pattern)
					       `(,_car ,_l))
					 `(,_loop (,_cdr ,_l) (,_- ,_n 1)))))))
		    (,_n (,_- (,(rename 'count-pair) ,expr)
			      ,(count-pair (cddr pattern)))))
	     (,_if (,_= ,_n 0)
		   ,(loop (cddr pattern) expr)
		   (,_and (,_> ,_n 0)
			  (,_loop ,expr ,_n)
			  ,(loop (cddr pattern) `(,(rename 'list-tail) ,expr ,_n))))))
      (define (loop pattern expr)
	(cond ((variable? pattern) ;; pattern variable
	       (if (id-memq pattern literals)
		   `(,_let ((,_temp ,expr))
		       (,_if (,_or (,_symbol? ,_temp)
				   (,_identifier? ,_temp))
			     (,_compare ,_temp (,_rename (,_quote ,pattern)))
			     #f))
		   `#t))
	      ;; TODO
	      ((ellipsis-pair? pattern rename compare)
	       (if (null? (cddr pattern))
		   `(,_if (,_list? ,expr)
			  ,(if (symbol? (car pattern))
			       #t
			       (do-list (car pattern) expr))
			  ,(do-list-n pattern expr))
		   (do-list-n pattern expr)))
	      ((pair? pattern)
	       (let ((generate-pair (lambda (expr)
				      (conjunction
				       `(,_pair? ,expr)
				       (conjunction
					(loop (car pattern)
					      `(,_car ,expr))
					(loop (cdr pattern)
					      `(,_cdr ,expr)))))))
		 (if (variable? expr)
		     (generate-pair expr)
		     `(,_let ((,_temp ,expr))
			 ,(generate-pair _temp)))))
	      ((vector? pattern)
	       `(_if (,_vector? ,expr)
		     ,(loop (vector->list pattern) expr)
		     #f))
	      ((null? pattern)
	       `(,_null? ,expr))
	      (else
	       `(_equal? ,expr (,_quote ,pattern)))))
      ;;(trace loop do-list do-list-n conjunction)
      (loop pattern expr)))

  (define (count-pair p)
    (let loop ((lst p) (n 0))
      (if (pair? lst) (loop (cdr lst) (+ n 1)) n)))
)